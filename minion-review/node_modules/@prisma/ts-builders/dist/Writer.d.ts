import type { BasicBuilder } from './BasicBuilder';
export declare const INDENT_SIZE = 2;
/**
 * Helper class for building long multi-line formatted strings from building blocks.
 * Can use either plain strings or `Builder` objects, that would encapsulate formatting logic.
 */
export declare class Writer<ContextType = undefined> {
    readonly context: ContextType;
    private lines;
    private currentLine;
    private currentIndent;
    private marginSymbol?;
    private afterNextNewLineCallback?;
    constructor(startingIndent: number | undefined, context: ContextType);
    /**
     * Adds provided value to the current line. Does not end the line.
     *
     * @param value
     * @returns
     */
    write(value: string | BasicBuilder<ContextType>): this;
    /**
     * Adds several `values` to the current line, separated by `separator`. Both values and separator
     * can also be `Builder` instances for more advanced formatting.
     *
     * @param separator
     * @param values
     * @param writeItem allow to customize how individual item is written
     * @returns
     */
    writeJoined<T extends string | BasicBuilder<ContextType>>(separator: string | BasicBuilder<ContextType>, values: T[], writeItem?: (item: T, writer: this) => void): this;
    /**
     * Adds a string to current line, flushes current line and starts a new line.
     * @param line
     * @returns
     */
    writeLine(line: string | BasicBuilder<ContextType>): this;
    /**
     * Flushes current line and starts a new line. New line starts at previously configured indentation level
     * @returns
     */
    newLine(): this;
    /**
     * Increases indentation level by 1, calls provided callback and then decreases indentation again.
     * Could be used for writing indented blocks of text:
     *
     * @example
     * ```ts
     * writer
     *   .writeLine('{')
     *   .withIndent(() => {
     *      writer.writeLine('foo: 123');
     *      writer.writeLine('bar: 456');
     *   })
     *   .writeLine('}')
     * ```
     * @param callback
     * @returns
     */
    withIndent(callback: (writer: this) => void): this;
    /**
     * Calls provided callback next time when new line is started.
     * Callback is called after old line have already been flushed and a new
     * line have been started. Can be used for adding "between the lines" decorations,
     * such as underlines.
     *
     * @param callback
     * @returns
     */
    afterNextNewline(callback: () => void): this;
    /**
     * Increases indentation level of the current line by 1
     * @returns
     */
    indent(): this;
    /**
     * Decreases indentation level of the current line by 1, if it is possible
     * @returns
     */
    unindent(): this;
    /**
     * Adds a symbol, that will replace the first character of the current line (including indentation)
     * when it is flushed. Can be used for adding markers to the line.
     *
     * Note: if indentation level of the line is 0, it will replace the first actually printed character
     * of the line. Use with caution.
     * @param symbol
     * @returns
     */
    addMarginSymbol(symbol: string): this;
    toString(): string;
    getCurrentLineLength(): number;
    private indentedCurrentLine;
}
