"use strict";
var import_vitest = require("vitest");
var import_ArrayType = require("./ArrayType");
var import_ConditionalType = require("./ConditionalType");
var import_FunctionType = require("./FunctionType");
var import_IntersectionType = require("./IntersectionType");
var import_NamedType = require("./NamedType");
var import_ObjectType = require("./ObjectType");
var import_Parameter = require("./Parameter");
var import_Property = require("./Property");
var import_stringify = require("./stringify");
var import_UnionType = require("./UnionType");
const A = (0, import_NamedType.namedType)("A");
const B = (0, import_NamedType.namedType)("B");
const C = (0, import_NamedType.namedType)("C");
const D = (0, import_NamedType.namedType)("D");
(0, import_vitest.test)("basic conditional type", () => {
  const conditional = (0, import_ConditionalType.conditionalType)().check(A).extends(B).then(C).else(D);
  (0, import_vitest.expect)((0, import_stringify.stringify)(conditional)).toMatchInlineSnapshot(`"A extends B ? C : D"`);
});
(0, import_vitest.test)("with union type as check type", () => {
  const union = (0, import_UnionType.unionType)(A).addVariant(B);
  const conditional = (0, import_ConditionalType.conditionalType)().check(union).extends(C).then((0, import_NamedType.namedType)("true")).else((0, import_NamedType.namedType)("false"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(conditional)).toMatchInlineSnapshot(`"A | B extends C ? true : false"`);
});
(0, import_vitest.test)("with array type as extends type", () => {
  const conditional = (0, import_ConditionalType.conditionalType)().check(A).extends((0, import_ArrayType.array)(B)).then((0, import_NamedType.namedType)("IsArray")).else((0, import_NamedType.namedType)("NotArray"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(conditional)).toMatchInlineSnapshot(`"A extends B[] ? IsArray : NotArray"`);
});
(0, import_vitest.test)("with object types", () => {
  const objType = (0, import_ObjectType.objectType)().add((0, import_Property.property)("name", (0, import_NamedType.namedType)("string"))).add((0, import_Property.property)("age", (0, import_NamedType.namedType)("number")));
  const conditional = (0, import_ConditionalType.conditionalType)().check(A).extends(objType).then((0, import_NamedType.namedType)("IsObject")).else((0, import_NamedType.namedType)("NotObject"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(conditional)).toMatchInlineSnapshot(`
    "A extends {
      name: string
      age: number
    } ? IsObject : NotObject"
  `);
});
(0, import_vitest.test)("with function types", () => {
  const funcType = (0, import_FunctionType.functionType)().addParameter((0, import_Parameter.parameter)("x", (0, import_NamedType.namedType)("string"))).setReturnType((0, import_NamedType.namedType)("number"));
  const conditional = (0, import_ConditionalType.conditionalType)().check(A).extends(funcType).then((0, import_NamedType.namedType)("IsFunction")).else((0, import_NamedType.namedType)("NotFunction"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(conditional)).toMatchInlineSnapshot(`"A extends (x: string) => number ? IsFunction : NotFunction"`);
});
(0, import_vitest.test)("nested conditional types", () => {
  const innerConditional = (0, import_ConditionalType.conditionalType)().check(A).extends(B).then(C).else(D);
  const outerConditional = (0, import_ConditionalType.conditionalType)().check((0, import_NamedType.namedType)("T")).extends((0, import_NamedType.namedType)("string")).then(innerConditional).else((0, import_NamedType.namedType)("never"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(outerConditional)).toMatchInlineSnapshot(`"T extends string ? A extends B ? C : D : never"`);
});
(0, import_vitest.test)("with generic types", () => {
  const conditional = (0, import_ConditionalType.conditionalType)().check((0, import_NamedType.namedType)("T")).extends((0, import_NamedType.namedType)("U")).then((0, import_NamedType.namedType)("T")).else((0, import_NamedType.namedType)("never"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(conditional)).toMatchInlineSnapshot(`"T extends U ? T : never"`);
});
(0, import_vitest.test)("complex real-world example", () => {
  const conditional = (0, import_ConditionalType.conditionalType)().check((0, import_NamedType.namedType)("T")).extends((0, import_ArrayType.array)((0, import_NamedType.namedType)("any"))).then((0, import_NamedType.namedType)("T[0]")).else((0, import_NamedType.namedType)("T"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(conditional)).toMatchInlineSnapshot(`"T extends any[] ? T[0] : T"`);
});
(0, import_vitest.test)("with literal types", () => {
  const conditional = (0, import_ConditionalType.conditionalType)().check((0, import_NamedType.namedType)("T")).extends((0, import_NamedType.namedType)('"foo"')).then((0, import_NamedType.namedType)("true")).else((0, import_NamedType.namedType)("false"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(conditional)).toMatchInlineSnapshot(`"T extends "foo" ? true : false"`);
});
(0, import_vitest.test)("with intersection types", () => {
  const intersection = (0, import_IntersectionType.intersectionType)(A).addType(B);
  const conditional = (0, import_ConditionalType.conditionalType)().check((0, import_NamedType.namedType)("T")).extends(intersection).then((0, import_NamedType.namedType)("HasBoth")).else((0, import_NamedType.namedType)("NotBoth"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(conditional)).toMatchInlineSnapshot(`"T extends A & B ? HasBoth : NotBoth"`);
});
(0, import_vitest.test)("with tuple types", () => {
  const tupleType = (0, import_NamedType.namedType)("[string, number]");
  const conditional = (0, import_ConditionalType.conditionalType)().check((0, import_NamedType.namedType)("T")).extends(tupleType).then((0, import_NamedType.namedType)("IsTuple")).else((0, import_NamedType.namedType)("NotTuple"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(conditional)).toMatchInlineSnapshot(`"T extends [string, number] ? IsTuple : NotTuple"`);
});
(0, import_vitest.test)("with keyof type", () => {
  const conditional = (0, import_ConditionalType.conditionalType)().check((0, import_NamedType.namedType)("K")).extends((0, import_NamedType.namedType)("keyof T")).then((0, import_NamedType.namedType)("K")).else((0, import_NamedType.namedType)("never"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(conditional)).toMatchInlineSnapshot(`"K extends keyof T ? K : never"`);
});
(0, import_vitest.test)("with never type", () => {
  const conditional = (0, import_ConditionalType.conditionalType)().check((0, import_NamedType.namedType)("T")).extends((0, import_NamedType.namedType)("never")).then((0, import_NamedType.namedType)("NeverReached")).else((0, import_NamedType.namedType)("NotNever"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(conditional)).toMatchInlineSnapshot(`"T extends never ? NeverReached : NotNever"`);
});
(0, import_vitest.test)("with unknown type", () => {
  const conditional = (0, import_ConditionalType.conditionalType)().check((0, import_NamedType.namedType)("T")).extends((0, import_NamedType.namedType)("unknown")).then((0, import_NamedType.namedType)("AlwaysTrue")).else((0, import_NamedType.namedType)("NeverReached"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(conditional)).toMatchInlineSnapshot(`"T extends unknown ? AlwaysTrue : NeverReached"`);
});
(0, import_vitest.test)("with any type", () => {
  const conditional = (0, import_ConditionalType.conditionalType)().check((0, import_NamedType.namedType)("any")).extends((0, import_NamedType.namedType)("T")).then((0, import_NamedType.namedType)("AnyExtendsT")).else((0, import_NamedType.namedType)("NotExtends"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(conditional)).toMatchInlineSnapshot(`"any extends T ? AnyExtendsT : NotExtends"`);
});
(0, import_vitest.test)("deeply nested conditional types", () => {
  const deeplyNested = (0, import_ConditionalType.conditionalType)().check((0, import_NamedType.namedType)("T")).extends((0, import_NamedType.namedType)("string")).then(
    (0, import_ConditionalType.conditionalType)().check((0, import_NamedType.namedType)("U")).extends((0, import_NamedType.namedType)("number")).then(
      (0, import_ConditionalType.conditionalType)().check((0, import_NamedType.namedType)("V")).extends((0, import_NamedType.namedType)("boolean")).then((0, import_NamedType.namedType)("AllMatch")).else((0, import_NamedType.namedType)("VNotBoolean"))
    ).else((0, import_NamedType.namedType)("UNotNumber"))
  ).else((0, import_NamedType.namedType)("TNotString"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(deeplyNested)).toMatchInlineSnapshot(
    `"T extends string ? U extends number ? V extends boolean ? AllMatch : VNotBoolean : UNotNumber : TNotString"`
  );
});
(0, import_vitest.test)("with template literal types", () => {
  const conditional = (0, import_ConditionalType.conditionalType)().check((0, import_NamedType.namedType)("T")).extends((0, import_NamedType.namedType)("`prefix_${string}`")).then((0, import_NamedType.namedType)("HasPrefix")).else((0, import_NamedType.namedType)("NoPrefix"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(conditional)).toMatchInlineSnapshot(`"T extends \`prefix_\${string}\` ? HasPrefix : NoPrefix"`);
});
(0, import_vitest.test)("with infer keyword", () => {
  const conditional = (0, import_ConditionalType.conditionalType)().check((0, import_NamedType.namedType)("T")).extends((0, import_NamedType.namedType)("Promise<infer U>")).then((0, import_NamedType.namedType)("U")).else((0, import_NamedType.namedType)("never"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(conditional)).toMatchInlineSnapshot(`"T extends Promise<infer U> ? U : never"`);
});
(0, import_vitest.test)("conditional type in union", () => {
  const conditional = (0, import_ConditionalType.conditionalType)().check((0, import_NamedType.namedType)("T")).extends((0, import_NamedType.namedType)("string")).then((0, import_NamedType.namedType)("A")).else((0, import_NamedType.namedType)("B"));
  const union = (0, import_UnionType.unionType)(conditional).addVariant((0, import_NamedType.namedType)("C"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(union)).toMatchInlineSnapshot(`"(T extends string ? A : B) | C"`);
});
(0, import_vitest.test)("with mapped type notation", () => {
  const conditional = (0, import_ConditionalType.conditionalType)().check((0, import_NamedType.namedType)("T[K]")).extends((0, import_NamedType.namedType)("Function")).then((0, import_NamedType.namedType)("K")).else((0, import_NamedType.namedType)("never"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(conditional)).toMatchInlineSnapshot(`"T[K] extends Function ? K : never"`);
});
