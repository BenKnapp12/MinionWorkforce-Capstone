"use strict";
var import_vitest = require("vitest");
var import_ArrayType = require("./ArrayType");
var import_ConditionalType = require("./ConditionalType");
var import_FunctionType = require("./FunctionType");
var import_IntersectionType = require("./IntersectionType");
var import_NamedType = require("./NamedType");
var import_ObjectType = require("./ObjectType");
var import_Parameter = require("./Parameter");
var import_Property = require("./Property");
var import_stringify = require("./stringify");
var import_UnionType = require("./UnionType");
const A = (0, import_NamedType.namedType)("A");
const B = (0, import_NamedType.namedType)("B");
const C = (0, import_NamedType.namedType)("C");
(0, import_vitest.test)("one type", () => {
  (0, import_vitest.expect)((0, import_stringify.stringify)((0, import_IntersectionType.intersectionType)(A))).toMatchInlineSnapshot(`"A"`);
});
(0, import_vitest.test)("multiple types", () => {
  (0, import_vitest.expect)((0, import_stringify.stringify)((0, import_IntersectionType.intersectionType)(A).addType(B))).toMatchInlineSnapshot(`"A & B"`);
});
(0, import_vitest.test)("three types", () => {
  (0, import_vitest.expect)((0, import_stringify.stringify)((0, import_IntersectionType.intersectionType)(A).addType(B).addType(C))).toMatchInlineSnapshot(`"A & B & C"`);
});
(0, import_vitest.test)("from array", () => {
  (0, import_vitest.expect)((0, import_stringify.stringify)((0, import_IntersectionType.intersectionType)([A, B, C]))).toMatchInlineSnapshot(`"A & B & C"`);
});
(0, import_vitest.test)("with function type", () => {
  const funcType = (0, import_FunctionType.functionType)().addParameter((0, import_Parameter.parameter)("x", (0, import_NamedType.namedType)("string"))).setReturnType((0, import_NamedType.namedType)("void"));
  (0, import_vitest.expect)((0, import_stringify.stringify)((0, import_IntersectionType.intersectionType)([A, B, funcType]))).toMatchInlineSnapshot(`"A & B & ((x: string) => void)"`);
});
(0, import_vitest.test)("with object types", () => {
  const obj1 = (0, import_ObjectType.objectType)().add((0, import_Property.property)("name", (0, import_NamedType.namedType)("string")));
  const obj2 = (0, import_ObjectType.objectType)().add((0, import_Property.property)("age", (0, import_NamedType.namedType)("number")));
  const intersection = (0, import_IntersectionType.intersectionType)(obj1).addType(obj2);
  (0, import_vitest.expect)((0, import_stringify.stringify)(intersection)).toMatchInlineSnapshot(`
    "{
      name: string
    } & {
      age: number
    }"
  `);
});
(0, import_vitest.test)("with array types", () => {
  const intersection = (0, import_IntersectionType.intersectionType)((0, import_ArrayType.array)(A)).addType((0, import_ArrayType.array)(B));
  (0, import_vitest.expect)((0, import_stringify.stringify)(intersection)).toMatchInlineSnapshot(`"A[] & B[]"`);
});
(0, import_vitest.test)("with union types", () => {
  const union1 = (0, import_UnionType.unionType)(A).addVariant(B);
  const union2 = (0, import_UnionType.unionType)(C).addVariant((0, import_NamedType.namedType)("D"));
  const intersection = (0, import_IntersectionType.intersectionType)(union1).addType(union2);
  (0, import_vitest.expect)((0, import_stringify.stringify)(intersection)).toMatchInlineSnapshot(`"(A | B) & (C | D)"`);
});
(0, import_vitest.test)("fails with empty array", () => {
  (0, import_vitest.expect)(() => (0, import_IntersectionType.intersectionType)([])).toThrowErrorMatchingInlineSnapshot(
    `[TypeError: Intersection types array can not be empty]`
  );
});
(0, import_vitest.test)("mapTypes", () => {
  const intersection = (0, import_IntersectionType.intersectionType)([A, B, C]).mapTypes(import_ArrayType.array);
  (0, import_vitest.expect)((0, import_stringify.stringify)(intersection)).toMatchInlineSnapshot(`"A[] & B[] & C[]"`);
});
(0, import_vitest.test)("with generic types", () => {
  const intersection = (0, import_IntersectionType.intersectionType)((0, import_NamedType.namedType)("T")).addType((0, import_NamedType.namedType)("U"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(intersection)).toMatchInlineSnapshot(`"T & U"`);
});
(0, import_vitest.test)("with literal types", () => {
  const intersection = (0, import_IntersectionType.intersectionType)((0, import_NamedType.namedType)('"foo"')).addType((0, import_NamedType.namedType)('"bar"'));
  (0, import_vitest.expect)((0, import_stringify.stringify)(intersection)).toMatchInlineSnapshot(`""foo" & "bar""`);
});
(0, import_vitest.test)("nested intersection types", () => {
  const inner = (0, import_IntersectionType.intersectionType)(A).addType(B);
  const outer = (0, import_IntersectionType.intersectionType)(inner).addType(C);
  (0, import_vitest.expect)((0, import_stringify.stringify)(outer)).toMatchInlineSnapshot(`"A & B & C"`);
});
(0, import_vitest.test)("with conditional type", () => {
  const conditional = (0, import_ConditionalType.conditionalType)().check((0, import_NamedType.namedType)("T")).extends((0, import_NamedType.namedType)("string")).then(A).else(B);
  const intersection = (0, import_IntersectionType.intersectionType)(conditional).addType(C);
  (0, import_vitest.expect)((0, import_stringify.stringify)(intersection)).toMatchInlineSnapshot(`"(T extends string ? A : B) & C"`);
});
(0, import_vitest.test)("with keyof type", () => {
  const intersection = (0, import_IntersectionType.intersectionType)((0, import_NamedType.namedType)("keyof T")).addType((0, import_NamedType.namedType)("string"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(intersection)).toMatchInlineSnapshot(`"keyof T & string"`);
});
(0, import_vitest.test)("complex real-world example", () => {
  const baseType = (0, import_ObjectType.objectType)().add((0, import_Property.property)("id", (0, import_NamedType.namedType)("string"))).add((0, import_Property.property)("createdAt", (0, import_NamedType.namedType)("Date")));
  const userFields = (0, import_ObjectType.objectType)().add((0, import_Property.property)("name", (0, import_NamedType.namedType)("string"))).add((0, import_Property.property)("email", (0, import_NamedType.namedType)("string")));
  const permissions = (0, import_ObjectType.objectType)().add(
    (0, import_Property.property)("role", (0, import_UnionType.unionType)((0, import_NamedType.namedType)('"admin"')).addVariant((0, import_NamedType.namedType)('"user"')))
  );
  const userType = (0, import_IntersectionType.intersectionType)(baseType).addType(userFields).addType(permissions);
  (0, import_vitest.expect)((0, import_stringify.stringify)(userType)).toMatchInlineSnapshot(`
    "{
      id: string
      createdAt: Date
    } & {
      name: string
      email: string
    } & {
      role: "admin" | "user"
    }"
  `);
});
(0, import_vitest.test)("addTypes with multiple types", () => {
  const intersection = (0, import_IntersectionType.intersectionType)(A).addTypes([B, C]);
  (0, import_vitest.expect)((0, import_stringify.stringify)(intersection)).toMatchInlineSnapshot(`"A & B & C"`);
});
(0, import_vitest.test)("with never type", () => {
  const intersection = (0, import_IntersectionType.intersectionType)(A).addType((0, import_NamedType.namedType)("never"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(intersection)).toMatchInlineSnapshot(`"A & never"`);
});
(0, import_vitest.test)("with unknown type", () => {
  const intersection = (0, import_IntersectionType.intersectionType)(A).addType((0, import_NamedType.namedType)("unknown"));
  (0, import_vitest.expect)((0, import_stringify.stringify)(intersection)).toMatchInlineSnapshot(`"A & unknown"`);
});
(0, import_vitest.test)("with any type", () => {
  const intersection = (0, import_IntersectionType.intersectionType)((0, import_NamedType.namedType)("any")).addType(B);
  (0, import_vitest.expect)((0, import_stringify.stringify)(intersection)).toMatchInlineSnapshot(`"any & B"`);
});
