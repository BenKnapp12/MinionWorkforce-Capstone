import { TypeBuilder } from "./TypeBuilder";
class IntersectionType extends TypeBuilder {
  needsParenthesisWhenIndexed = true;
  needsParenthesisInKeyof = true;
  members;
  constructor(firstType) {
    super();
    this.members = [firstType];
  }
  addType(type) {
    this.members.push(type);
    return this;
  }
  addTypes(types) {
    for (const type of types) {
      this.addType(type);
    }
    return this;
  }
  write(writer) {
    writer.writeJoined(" & ", this.members, (member, writer2) => {
      if (member.needsParenthesisInIntersection) {
        writer2.write("(").write(member).write(")");
      } else {
        writer2.write(member);
      }
    });
  }
  mapTypes(callback) {
    return intersectionType(this.members.map((m) => callback(m)));
  }
}
function intersectionType(types) {
  if (Array.isArray(types)) {
    if (types.length === 0) {
      throw new TypeError("Intersection types array can not be empty");
    }
    const intersection = new IntersectionType(types[0]);
    for (let i = 1; i < types.length; i++) {
      intersection.addType(types[i]);
    }
    return intersection;
  }
  return new IntersectionType(types);
}
export {
  IntersectionType,
  intersectionType
};
