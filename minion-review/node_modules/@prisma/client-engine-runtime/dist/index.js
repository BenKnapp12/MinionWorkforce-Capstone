"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  DataMapperError: () => DataMapperError,
  QueryInterpreter: () => QueryInterpreter,
  TransactionManager: () => TransactionManager,
  TransactionManagerError: () => TransactionManagerError,
  UserFacingError: () => UserFacingError,
  convertCompactedRows: () => convertCompactedRows,
  deserializeJsonResponse: () => deserializeJsonResponse,
  doKeysMatch: () => doKeysMatch,
  isDeepStrictEqual: () => isDeepStrictEqual,
  isPrismaValueGenerator: () => isPrismaValueGenerator,
  isPrismaValuePlaceholder: () => isPrismaValuePlaceholder,
  noopTracingHelper: () => noopTracingHelper,
  normalizeJsonProtocolValues: () => normalizeJsonProtocolValues,
  normalizeRawJsonProtocolResponse: () => normalizeRawJsonProtocolResponse,
  safeJsonStringify: () => safeJsonStringify
});
module.exports = __toCommonJS(index_exports);

// src/json-protocol.ts
var import_decimal2 = require("decimal.js");

// src/utils.ts
var import_decimal = __toESM(require("decimal.js"));
function assertNever(_, message) {
  throw new Error(message);
}
function isDeepStrictEqual(a, b) {
  return a === b || a !== null && b !== null && typeof a === "object" && typeof b === "object" && Object.keys(a).length === Object.keys(b).length && Object.keys(a).every((key) => isDeepStrictEqual(a[key], b[key]));
}
function doKeysMatch(lhs, rhs) {
  const lhsKeys = Object.keys(lhs);
  const rhsKeys = Object.keys(rhs);
  const smallerKeyList = lhsKeys.length < rhsKeys.length ? lhsKeys : rhsKeys;
  return smallerKeyList.every((key) => {
    if (typeof lhs[key] === typeof rhs[key] && typeof lhs[key] !== "object") {
      return lhs[key] === rhs[key];
    }
    if (import_decimal.default.isDecimal(lhs[key]) || import_decimal.default.isDecimal(rhs[key])) {
      const lhsDecimal = asDecimal(lhs[key]);
      const rhsDecimal = asDecimal(rhs[key]);
      return lhsDecimal && rhsDecimal && lhsDecimal.equals(rhsDecimal);
    } else if (lhs[key] instanceof Uint8Array || rhs[key] instanceof Uint8Array) {
      const lhsBuffer = asBuffer(lhs[key]);
      const rhsBuffer = asBuffer(rhs[key]);
      return lhsBuffer && rhsBuffer && lhsBuffer.equals(rhsBuffer);
    } else if (lhs[key] instanceof Date || rhs[key] instanceof Date) {
      return asDate(lhs[key])?.getTime() === asDate(rhs[key])?.getTime();
    } else if (typeof lhs[key] === "bigint" || typeof rhs[key] === "bigint") {
      return asBigInt(lhs[key]) === asBigInt(rhs[key]);
    } else if (typeof lhs[key] === "number" || typeof rhs[key] === "number") {
      return asNumber(lhs[key]) === asNumber(rhs[key]);
    }
    return isDeepStrictEqual(lhs[key], rhs[key]);
  });
}
function asDecimal(value) {
  if (import_decimal.default.isDecimal(value)) {
    return value;
  } else if (typeof value === "number" || typeof value === "string") {
    return new import_decimal.default(value);
  } else {
    return;
  }
}
function asBuffer(value) {
  if (Buffer.isBuffer(value)) {
    return value;
  } else if (value instanceof Uint8Array) {
    return Buffer.from(value.buffer, value.byteOffset, value.byteLength);
  } else if (typeof value === "string") {
    return Buffer.from(value, "base64");
  } else {
    return;
  }
}
function asDate(value) {
  if (value instanceof Date) {
    return value;
  } else if (typeof value === "string" || typeof value === "number") {
    return new Date(value);
  } else {
    return;
  }
}
function asBigInt(value) {
  if (typeof value === "bigint") {
    return value;
  } else if (typeof value === "number" || typeof value === "string") {
    return BigInt(value);
  } else {
    return;
  }
}
function asNumber(value) {
  if (typeof value === "number") {
    return value;
  } else if (typeof value === "string") {
    return Number(value);
  } else {
    return;
  }
}
function safeJsonStringify(obj) {
  return JSON.stringify(obj, (_key, val) => {
    if (typeof val === "bigint") {
      return val.toString();
    } else if (ArrayBuffer.isView(val)) {
      return Buffer.from(val.buffer, val.byteOffset, val.byteLength).toString("base64");
    }
    return val;
  });
}

// src/json-protocol.ts
function normalizeJsonProtocolValues(result) {
  if (result === null) {
    return result;
  }
  if (Array.isArray(result)) {
    return result.map(normalizeJsonProtocolValues);
  }
  if (typeof result === "object") {
    if (isTaggedValue(result)) {
      return normalizeTaggedValue(result);
    }
    if (ArrayBuffer.isView(result)) {
      const buffer = Buffer.from(result.buffer, result.byteOffset, result.byteLength);
      return buffer.toString("base64");
    }
    if (result.constructor !== null && result.constructor.name !== "Object") {
      return result;
    }
    return mapObjectValues(result, normalizeJsonProtocolValues);
  }
  return result;
}
function isTaggedValue(value) {
  return value !== null && typeof value == "object" && typeof value["$type"] === "string";
}
function normalizeTaggedValue({ $type, value }) {
  switch ($type) {
    case "BigInt":
      return { $type, value: String(value) };
    case "Bytes":
      return { $type, value: Buffer.from(value, "base64").toString("base64") };
    case "DateTime":
      return { $type, value: new Date(value).toISOString() };
    case "Decimal":
      return { $type, value: String(new import_decimal2.Decimal(value)) };
    case "Json":
      return { $type, value: JSON.stringify(JSON.parse(value)) };
    default:
      assertNever(value, "Unknown tagged value");
  }
}
function mapObjectValues(object, mapper) {
  const result = {};
  for (const key of Object.keys(object)) {
    result[key] = mapper(object[key], key);
  }
  return result;
}
function deserializeJsonResponse(result) {
  if (result === null) {
    return result;
  }
  if (Array.isArray(result)) {
    return result.map(deserializeJsonResponse);
  }
  if (typeof result === "object") {
    if (isTaggedValue(result)) {
      return deserializeTaggedValue(result);
    }
    if (result.constructor !== null && result.constructor.name !== "Object") {
      return result;
    }
    return mapObjectValues(result, deserializeJsonResponse);
  }
  return result;
}
function deserializeTaggedValue({ $type, value }) {
  switch ($type) {
    case "BigInt":
      return BigInt(value);
    case "Bytes": {
      const { buffer, byteOffset, byteLength } = Buffer.from(value, "base64");
      return new Uint8Array(buffer, byteOffset, byteLength);
    }
    case "DateTime":
      return new Date(value);
    case "Decimal":
      return new import_decimal2.Decimal(value);
    case "Json":
      return JSON.parse(value);
    default:
      assertNever(value, "Unknown tagged value");
  }
}

// src/user-facing-error.ts
var import_driver_adapter_utils = require("@prisma/driver-adapter-utils");
var UserFacingError = class extends Error {
  name = "UserFacingError";
  code;
  meta;
  constructor(message, code, meta) {
    super(message);
    this.code = code;
    this.meta = meta ?? {};
  }
  toQueryResponseErrorObject() {
    return {
      error: this.message,
      user_facing_error: {
        is_panic: false,
        message: this.message,
        meta: this.meta,
        error_code: this.code
      }
    };
  }
};
function rethrowAsUserFacing(error) {
  if (!(0, import_driver_adapter_utils.isDriverAdapterError)(error)) {
    throw error;
  }
  const code = getErrorCode(error);
  const message = renderErrorMessage(error);
  if (!code || !message) {
    throw error;
  }
  throw new UserFacingError(message, code, { driverAdapterError: error });
}
function rethrowAsUserFacingRawError(error) {
  if (!(0, import_driver_adapter_utils.isDriverAdapterError)(error)) {
    throw error;
  }
  throw new UserFacingError(
    `Raw query failed. Code: \`${error.cause.originalCode ?? "N/A"}\`. Message: \`${error.cause.originalMessage ?? renderErrorMessage(error)}\``,
    "P2010",
    { driverAdapterError: error }
  );
}
function getErrorCode(err) {
  switch (err.cause.kind) {
    case "AuthenticationFailed":
      return "P1000";
    case "DatabaseNotReachable":
      return "P1001";
    case "DatabaseDoesNotExist":
      return "P1003";
    case "SocketTimeout":
      return "P1008";
    case "DatabaseAlreadyExists":
      return "P1009";
    case "DatabaseAccessDenied":
      return "P1010";
    case "TlsConnectionError":
      return "P1011";
    case "ConnectionClosed":
      return "P1017";
    case "TransactionAlreadyClosed":
      return "P1018";
    case "LengthMismatch":
      return "P2000";
    case "UniqueConstraintViolation":
      return "P2002";
    case "ForeignKeyConstraintViolation":
      return "P2003";
    case "UnsupportedNativeDataType":
      return "P2010";
    case "NullConstraintViolation":
      return "P2011";
    case "ValueOutOfRange":
      return "P2020";
    case "TableDoesNotExist":
      return "P2021";
    case "ColumnNotFound":
      return "P2022";
    case "InvalidIsolationLevel":
    case "InconsistentColumnData":
      return "P2023";
    case "MissingFullTextSearchIndex":
      return "P2030";
    case "TransactionWriteConflict":
      return "P2034";
    case "GenericJs":
      return "P2036";
    case "TooManyConnections":
      return "P2037";
    case "postgres":
    case "sqlite":
    case "mysql":
    case "mssql":
      return;
    default:
      assertNever(err.cause, `Unknown error: ${err.cause}`);
  }
}
function renderErrorMessage(err) {
  switch (err.cause.kind) {
    case "AuthenticationFailed": {
      const user = err.cause.user ?? "(not available)";
      return `Authentication failed against the database server, the provided database credentials for \`${user}\` are not valid`;
    }
    case "DatabaseNotReachable": {
      const address = err.cause.host && err.cause.port ? `${err.cause.host}:${err.cause.port}` : err.cause.host;
      return `Can't reach database server${address ? ` at ${address}` : ""}`;
    }
    case "DatabaseDoesNotExist": {
      const db = err.cause.db ?? "(not available)";
      return `Database \`${db}\` does not exist on the database server`;
    }
    case "SocketTimeout":
      return `Operation has timed out`;
    case "DatabaseAlreadyExists": {
      const db = err.cause.db ?? "(not available)";
      return `Database \`${db}\` already exists on the database server`;
    }
    case "DatabaseAccessDenied": {
      const db = err.cause.db ?? "(not available)";
      return `User was denied access on the database \`${db}\``;
    }
    case "TlsConnectionError": {
      return `Error opening a TLS connection: ${err.cause.reason}`;
    }
    case "ConnectionClosed": {
      return "Server has closed the connection.";
    }
    case "TransactionAlreadyClosed":
      return err.cause.cause;
    case "LengthMismatch": {
      const column = err.cause.column ?? "(not available)";
      return `The provided value for the column is too long for the column's type. Column: ${column}`;
    }
    case "UniqueConstraintViolation":
      return `Unique constraint failed on the ${renderConstraint(err.cause.constraint)}`;
    case "ForeignKeyConstraintViolation":
      return `Foreign key constraint violated on the ${renderConstraint(err.cause.constraint)}`;
    case "UnsupportedNativeDataType":
      return `Failed to deserialize column of type '${err.cause.type}'. If you're using $queryRaw and this column is explicitly marked as \`Unsupported\` in your Prisma schema, try casting this column to any supported Prisma type such as \`String\`.`;
    case "NullConstraintViolation":
      return `Null constraint violation on the ${renderConstraint(err.cause.constraint)}`;
    case "ValueOutOfRange":
      return `Value out of range for the type: ${err.cause.cause}`;
    case "TableDoesNotExist": {
      const table = err.cause.table ?? "(not available)";
      return `The table \`${table}\` does not exist in the current database.`;
    }
    case "ColumnNotFound": {
      const column = err.cause.column ?? "(not available)";
      return `The column \`${column}\` does not exist in the current database.`;
    }
    case "InvalidIsolationLevel":
      return `Error in connector: Conversion error: ${err.cause.level}`;
    case "InconsistentColumnData":
      return `Inconsistent column data: ${err.cause.cause}`;
    case "MissingFullTextSearchIndex":
      return "Cannot find a fulltext index to use for the native search, try adding a @@fulltext([Fields...]) to your schema";
    case "TransactionWriteConflict":
      return `Transaction failed due to a write conflict or a deadlock. Please retry your transaction`;
    case "GenericJs":
      return `Error in external connector (id ${err.cause.id})`;
    case "TooManyConnections":
      return `Too many database connections opened: ${err.cause.cause}`;
    case "sqlite":
    case "postgres":
    case "mysql":
    case "mssql":
      return;
    default:
      assertNever(err.cause, `Unknown error: ${err.cause}`);
  }
}
function renderConstraint(constraint) {
  if (constraint && "fields" in constraint) {
    return `fields: (${constraint.fields.map((field) => `\`${field}\``).join(", ")})`;
  } else if (constraint && "index" in constraint) {
    return `constraint: \`${constraint.index}\``;
  } else if (constraint && "foreignKey" in constraint) {
    return `foreign key`;
  }
  return "(not available)";
}

// src/batch.ts
function convertCompactedRows(rows, compiledBatch) {
  const keysPerRow = rows.map(
    (item) => compiledBatch.keys.reduce((acc, key) => {
      acc[key] = deserializeJsonResponse(item[key]);
      return acc;
    }, {})
  );
  const selection = new Set(compiledBatch.nestedSelection);
  return compiledBatch.arguments.map((args) => {
    const rowIndex = keysPerRow.findIndex((rowKeys) => doKeysMatch(rowKeys, args));
    if (rowIndex === -1) {
      if (compiledBatch.expectNonEmpty) {
        return new UserFacingError(
          "An operation failed because it depends on one or more records that were required but not found",
          "P2025"
        );
      } else {
        return null;
      }
    } else {
      const selected = Object.entries(rows[rowIndex]).filter(([k]) => selection.has(k));
      return Object.fromEntries(selected);
    }
  });
}

// src/interpreter/data-mapper.ts
var import_decimal3 = __toESM(require("decimal.js"));
var DataMapperError = class extends Error {
  name = "DataMapperError";
};
function applyDataMap(data, structure, enums) {
  switch (structure.type) {
    case "affectedRows":
      if (typeof data !== "number") {
        throw new DataMapperError(`Expected an affected rows count, got: ${typeof data} (${data})`);
      }
      return { count: data };
    case "object":
      return mapArrayOrObject(data, structure.fields, enums, structure.skipNulls);
    case "field":
      return mapValue(data, "<result>", structure.fieldType, enums);
    default:
      assertNever(structure, `Invalid data mapping type: '${structure.type}'`);
  }
}
function mapArrayOrObject(data, fields, enums, skipNulls) {
  if (data === null) return null;
  if (Array.isArray(data)) {
    let rows = data;
    if (skipNulls) {
      rows = rows.filter((row) => row !== null);
    }
    return rows.map((row) => mapObject(row, fields, enums));
  }
  if (typeof data === "object") {
    const row = data;
    return mapObject(row, fields, enums);
  }
  if (typeof data === "string") {
    let decodedData;
    try {
      decodedData = JSON.parse(data);
    } catch (error) {
      throw new DataMapperError(`Expected an array or object, got a string that is not valid JSON`, {
        cause: error
      });
    }
    return mapArrayOrObject(decodedData, fields, enums, skipNulls);
  }
  throw new DataMapperError(`Expected an array or an object, got: ${typeof data}`);
}
function mapObject(data, fields, enums) {
  if (typeof data !== "object") {
    throw new DataMapperError(`Expected an object, but got '${typeof data}'`);
  }
  const result = {};
  for (const [name, node] of Object.entries(fields)) {
    switch (node.type) {
      case "affectedRows": {
        throw new DataMapperError(`Unexpected 'AffectedRows' node in data mapping for field '${name}'`);
      }
      case "object": {
        if (node.serializedName !== null && !Object.hasOwn(data, node.serializedName)) {
          throw new DataMapperError(
            `Missing data field (Object): '${name}'; node: ${JSON.stringify(node)}; data: ${JSON.stringify(data)}`
          );
        }
        const target = node.serializedName !== null ? data[node.serializedName] : data;
        result[name] = mapArrayOrObject(target, node.fields, enums, node.skipNulls);
        break;
      }
      case "field":
        {
          const dbName = node.dbName;
          if (Object.hasOwn(data, dbName)) {
            result[name] = mapField(data[dbName], dbName, node.fieldType, enums);
          } else {
            throw new DataMapperError(
              `Missing data field (Value): '${dbName}'; node: ${JSON.stringify(node)}; data: ${JSON.stringify(data)}`
            );
          }
        }
        break;
      default:
        assertNever(node, `DataMapper: Invalid data mapping node type: '${node.type}'`);
    }
  }
  return result;
}
function mapField(value, columnName, fieldType, enums) {
  if (value === null) {
    return fieldType.arity === "list" ? [] : null;
  }
  if (fieldType.arity === "list") {
    const values = value;
    return values.map((v, i) => mapValue(v, `${columnName}[${i}]`, fieldType, enums));
  }
  return mapValue(value, columnName, fieldType, enums);
}
function mapValue(value, columnName, scalarType, enums) {
  switch (scalarType.type) {
    case "unsupported":
      return value;
    case "string": {
      if (typeof value !== "string") {
        throw new DataMapperError(`Expected a string in column '${columnName}', got ${typeof value}: ${value}`);
      }
      return value;
    }
    case "int": {
      switch (typeof value) {
        case "number": {
          return Math.trunc(value);
        }
        case "string": {
          const numberValue = Math.trunc(Number(value));
          if (Number.isNaN(numberValue) || !Number.isFinite(numberValue)) {
            throw new DataMapperError(`Expected an integer in column '${columnName}', got string: ${value}`);
          }
          if (!Number.isSafeInteger(numberValue)) {
            throw new DataMapperError(
              `Integer value in column '${columnName}' is too large to represent as a JavaScript number without loss of precision, got: ${value}. Consider using BigInt type.`
            );
          }
          return numberValue;
        }
        default:
          throw new DataMapperError(`Expected an integer in column '${columnName}', got ${typeof value}: ${value}`);
      }
    }
    case "bigint": {
      if (typeof value !== "number" && typeof value !== "string") {
        throw new DataMapperError(`Expected a bigint in column '${columnName}', got ${typeof value}: ${value}`);
      }
      return { $type: "BigInt", value };
    }
    case "float": {
      if (typeof value === "number") return value;
      if (typeof value === "string") {
        const parsedValue = Number(value);
        if (Number.isNaN(parsedValue) && !/^[-+]?nan$/.test(value.toLowerCase())) {
          throw new DataMapperError(`Expected a float in column '${columnName}', got string: ${value}`);
        }
        return parsedValue;
      }
      throw new DataMapperError(`Expected a float in column '${columnName}', got ${typeof value}: ${value}`);
    }
    case "boolean": {
      if (typeof value === "boolean") return value;
      if (typeof value === "number") return value === 1;
      if (typeof value === "string") {
        if (value === "true" || value === "TRUE" || value === "1") {
          return true;
        } else if (value === "false" || value === "FALSE" || value === "0") {
          return false;
        } else {
          throw new DataMapperError(`Expected a boolean in column '${columnName}', got ${typeof value}: ${value}`);
        }
      }
      if (Array.isArray(value)) {
        for (const byte of value) {
          if (byte !== 0) return true;
        }
        return false;
      }
      throw new DataMapperError(`Expected a boolean in column '${columnName}', got ${typeof value}: ${value}`);
    }
    case "decimal":
      if (typeof value !== "number" && typeof value !== "string" && !import_decimal3.default.isDecimal(value)) {
        throw new DataMapperError(`Expected a decimal in column '${columnName}', got ${typeof value}: ${value}`);
      }
      return { $type: "Decimal", value };
    case "datetime": {
      if (typeof value === "string") {
        return { $type: "DateTime", value: normalizeDateTime(value) };
      }
      if (typeof value === "number" || value instanceof Date) {
        return { $type: "DateTime", value };
      }
      throw new DataMapperError(`Expected a date in column '${columnName}', got ${typeof value}: ${value}`);
    }
    case "object": {
      return { $type: "Json", value: safeJsonStringify(value) };
    }
    case "json": {
      return { $type: "Json", value: `${value}` };
    }
    case "bytes": {
      switch (scalarType.encoding) {
        case "base64":
          if (typeof value !== "string") {
            throw new DataMapperError(
              `Expected a base64-encoded byte array in column '${columnName}', got ${typeof value}: ${value}`
            );
          }
          return { $type: "Bytes", value };
        case "hex":
          if (typeof value !== "string" || !value.startsWith("\\x")) {
            throw new DataMapperError(
              `Expected a hex-encoded byte array in column '${columnName}', got ${typeof value}: ${value}`
            );
          }
          return { $type: "Bytes", value: Buffer.from(value.slice(2), "hex").toString("base64") };
        case "array":
          if (Array.isArray(value)) {
            return { $type: "Bytes", value: Buffer.from(value).toString("base64") };
          }
          if (value instanceof Uint8Array) {
            return { $type: "Bytes", value: Buffer.from(value).toString("base64") };
          }
          throw new DataMapperError(`Expected a byte array in column '${columnName}', got ${typeof value}: ${value}`);
        default:
          assertNever(scalarType.encoding, `DataMapper: Unknown bytes encoding: ${scalarType.encoding}`);
      }
      break;
    }
    case "enum": {
      const enumDef = enums[scalarType.name];
      if (enumDef === void 0) {
        throw new DataMapperError(`Unknown enum '${scalarType.name}'`);
      }
      const enumValue = enumDef[`${value}`];
      if (enumValue === void 0) {
        throw new DataMapperError(`Value '${value}' not found in enum '${scalarType.name}'`);
      }
      return enumValue;
    }
    default:
      assertNever(scalarType, `DataMapper: Unknown result type: ${scalarType["type"]}`);
  }
}
var TIME_TZ_PATTERN = /\d{2}:\d{2}:\d{2}(?:\.\d+)?(Z|[+-]\d{2}(:?\d{2})?)?$/;
function normalizeDateTime(dt) {
  const matches = TIME_TZ_PATTERN.exec(dt);
  if (matches === null) {
    return `${dt}Z`;
  }
  let dtWithTz = dt;
  const [timeTz, tz, tzMinuteOffset] = matches;
  if (tz !== void 0 && tz !== "Z" && tzMinuteOffset === void 0) {
    dtWithTz = `${dt}:00`;
  } else if (tz === void 0) {
    dtWithTz = `${dt}Z`;
  }
  if (timeTz.length === dt.length) {
    return `1970-01-01T${dtWithTz}`;
  }
  return dtWithTz;
}

// src/tracing.ts
var import_api = require("@opentelemetry/api");
var noopTracingHelper = {
  runInChildSpan(_, callback) {
    return callback();
  }
};
function providerToOtelSystem(provider) {
  switch (provider) {
    case "postgresql":
    case "postgres":
    case "prisma+postgres":
      return "postgresql";
    case "sqlserver":
      return "mssql";
    case "mysql":
    case "sqlite":
    case "cockroachdb":
    case "mongodb":
      return provider;
    default:
      assertNever(provider, `Unknown provider: ${provider}`);
  }
}
async function withQuerySpanAndEvent({
  query,
  tracingHelper,
  provider,
  onQuery,
  execute
}) {
  return await tracingHelper.runInChildSpan(
    {
      name: "db_query",
      kind: import_api.SpanKind.CLIENT,
      attributes: {
        "db.query.text": query.sql,
        "db.system.name": providerToOtelSystem(provider)
      }
    },
    async () => {
      const timestamp = /* @__PURE__ */ new Date();
      const startInstant = performance.now();
      const result = await execute();
      const endInstant = performance.now();
      onQuery?.({
        timestamp,
        duration: endInstant - startInstant,
        query: query.sql,
        params: query.args
      });
      return result;
    }
  );
}

// src/interpreter/generators.ts
var import_cuid = __toESM(require("@bugsnag/cuid"));
var import_cuid2 = require("@paralleldrive/cuid2");
var import_nanoid = require("nanoid");
var import_ulid = require("ulid");
var import_uuid = require("uuid");
var GeneratorRegistry = class {
  #generators = {};
  constructor() {
    this.register("uuid", new UuidGenerator());
    this.register("cuid", new CuidGenerator());
    this.register("ulid", new UlidGenerator());
    this.register("nanoid", new NanoIdGenerator());
    this.register("product", new ProductGenerator());
  }
  /**
   * Returns a snapshot of the generator registry. It's 'frozen' in time at the moment of this
   * method being called, meaning that the built-in time-based generators will always return
   * the same value on repeated calls as long as the same snapshot is used.
   */
  snapshot() {
    return Object.create(this.#generators, {
      now: {
        value: new NowGenerator()
      }
    });
  }
  /**
   * Registers a new generator with the given name.
   */
  register(name, generator) {
    this.#generators[name] = generator;
  }
};
var NowGenerator = class {
  #now = /* @__PURE__ */ new Date();
  generate() {
    return this.#now.toISOString();
  }
};
var UuidGenerator = class {
  generate(arg) {
    if (arg === 4) {
      return (0, import_uuid.v4)();
    } else if (arg === 7) {
      return (0, import_uuid.v7)();
    } else {
      throw new Error("Invalid UUID generator arguments");
    }
  }
};
var CuidGenerator = class {
  generate(arg) {
    if (arg === 1) {
      return (0, import_cuid.default)();
    } else if (arg === 2) {
      return (0, import_cuid2.createId)();
    } else {
      throw new Error("Invalid CUID generator arguments");
    }
  }
};
var UlidGenerator = class {
  generate() {
    return (0, import_ulid.ulid)();
  }
};
var NanoIdGenerator = class {
  generate(arg) {
    if (typeof arg === "number") {
      return (0, import_nanoid.nanoid)(arg);
    } else if (arg === void 0) {
      return (0, import_nanoid.nanoid)();
    } else {
      throw new Error("Invalid Nanoid generator arguments");
    }
  }
};
var ProductGenerator = class {
  generate(lhs, rhs) {
    if (lhs === void 0 || rhs === void 0) {
      throw new Error("Invalid Product generator arguments");
    }
    if (Array.isArray(lhs) && Array.isArray(rhs)) {
      return lhs.flatMap((l) => rhs.map((r) => [l, r]));
    } else if (Array.isArray(lhs)) {
      return lhs.map((l) => [l, rhs]);
    } else if (Array.isArray(rhs)) {
      return rhs.map((r) => [lhs, r]);
    } else {
      return [[lhs, rhs]];
    }
  }
};

// src/interpreter/in-memory-processing.ts
function processRecords(value, ops) {
  if (value == null) {
    return value;
  }
  if (typeof value === "string") {
    return processRecords(JSON.parse(value), ops);
  }
  if (Array.isArray(value)) {
    return processManyRecords(value, ops);
  }
  return processOneRecord(value, ops);
}
function processOneRecord(record, ops) {
  if (ops.pagination) {
    const { skip, take, cursor } = ops.pagination;
    if (skip !== null && skip > 0) {
      return null;
    }
    if (take === 0) {
      return null;
    }
    if (cursor !== null && !doKeysMatch(record, cursor)) {
      return null;
    }
  }
  return processNestedRecords(record, ops.nested);
}
function processNestedRecords(record, opsMap) {
  for (const [key, ops] of Object.entries(opsMap)) {
    record[key] = processRecords(record[key], ops);
  }
  return record;
}
function processManyRecords(records, ops) {
  if (ops.distinct !== null) {
    const fields = ops.linkingFields !== null ? [...ops.distinct, ...ops.linkingFields] : ops.distinct;
    records = distinctBy(records, fields);
  }
  if (ops.pagination) {
    records = paginate(records, ops.pagination, ops.linkingFields);
  }
  if (ops.reverse) {
    records.reverse();
  }
  if (Object.keys(ops.nested).length === 0) {
    return records;
  }
  return records.map((record) => processNestedRecords(record, ops.nested));
}
function distinctBy(records, fields) {
  const seen = /* @__PURE__ */ new Set();
  const result = [];
  for (const record of records) {
    const key = getRecordKey(record, fields);
    if (!seen.has(key)) {
      seen.add(key);
      result.push(record);
    }
  }
  return result;
}
function paginate(records, pagination, linkingFields) {
  if (linkingFields === null) {
    return paginateSingleList(records, pagination);
  }
  const groupedByParent = /* @__PURE__ */ new Map();
  for (const record of records) {
    const parentKey = getRecordKey(record, linkingFields);
    if (!groupedByParent.has(parentKey)) {
      groupedByParent.set(parentKey, []);
    }
    groupedByParent.get(parentKey).push(record);
  }
  const groupList = Array.from(groupedByParent.entries());
  groupList.sort(([aId], [bId]) => aId < bId ? -1 : aId > bId ? 1 : 0);
  return groupList.flatMap(([, elems]) => paginateSingleList(elems, pagination));
}
function paginateSingleList(list, { cursor, skip, take }) {
  const cursorIndex = cursor !== null ? list.findIndex((item) => doKeysMatch(item, cursor)) : 0;
  if (cursorIndex === -1) {
    return [];
  }
  const start = cursorIndex + (skip ?? 0);
  const end = take !== null ? start + take : list.length;
  return list.slice(start, end);
}
function getRecordKey(record, fields) {
  return JSON.stringify(fields.map((field) => record[field]));
}

// src/query-plan.ts
function isPrismaValuePlaceholder(value) {
  return typeof value === "object" && value !== null && value["prisma__type"] === "param";
}
function isPrismaValueGenerator(value) {
  return typeof value === "object" && value !== null && value["prisma__type"] === "generatorCall";
}

// src/interpreter/render-query.ts
function renderQuery(dbQuery, scope, generators, maxChunkSize) {
  const args = dbQuery.args.map((arg) => evaluateArg(arg, scope, generators));
  switch (dbQuery.type) {
    case "rawSql":
      return [renderRawSql(dbQuery.sql, args, dbQuery.argTypes)];
    case "templateSql": {
      const chunks = dbQuery.chunkable ? chunkParams(dbQuery.fragments, args, maxChunkSize) : [args];
      return chunks.map((params) => {
        if (maxChunkSize !== void 0 && params.length > maxChunkSize) {
          throw new UserFacingError("The query parameter limit supported by your database is exceeded.", "P2029");
        }
        return renderTemplateSql(dbQuery.fragments, dbQuery.placeholderFormat, params, dbQuery.argTypes);
      });
    }
    default:
      assertNever(dbQuery["type"], `Invalid query type`);
  }
}
function evaluateArg(arg, scope, generators) {
  while (doesRequireEvaluation(arg)) {
    if (isPrismaValuePlaceholder(arg)) {
      const found = scope[arg.prisma__value.name];
      if (found === void 0) {
        throw new Error(`Missing value for query variable ${arg.prisma__value.name}`);
      }
      arg = found;
    } else if (isPrismaValueGenerator(arg)) {
      const { name, args } = arg.prisma__value;
      const generator = generators[name];
      if (!generator) {
        throw new Error(`Encountered an unknown generator '${name}'`);
      }
      arg = generator.generate(...args.map((arg2) => evaluateArg(arg2, scope, generators)));
    } else {
      assertNever(arg, `Unexpected unevaluated value type: ${arg}`);
    }
  }
  if (Array.isArray(arg)) {
    arg = arg.map((el) => evaluateArg(el, scope, generators));
  }
  return arg;
}
function renderTemplateSql(fragments, placeholderFormat, params, argTypes) {
  let sql = "";
  const ctx = { placeholderNumber: 1 };
  const flattenedParams = [];
  const flattenedArgTypes = [];
  for (const fragment of pairFragmentsWithParams(fragments, params, argTypes)) {
    sql += renderFragment(fragment, placeholderFormat, ctx);
    if (fragment.type === "stringChunk") {
      continue;
    }
    const length = flattenedParams.length;
    const added = flattenedParams.push(...flattenedFragmentParams(fragment)) - length;
    if (fragment.argType.arity === "tuple") {
      if (added % fragment.argType.elements.length !== 0) {
        throw new Error(
          `Malformed query template. Expected the number of parameters to match the tuple arity, but got ${added} parameters for a tuple of arity ${fragment.argType.elements.length}.`
        );
      }
      for (let i = 0; i < added / fragment.argType.elements.length; i++) {
        flattenedArgTypes.push(...fragment.argType.elements);
      }
    } else {
      for (let i = 0; i < added; i++) {
        flattenedArgTypes.push(fragment.argType);
      }
    }
  }
  return {
    sql,
    args: flattenedParams,
    argTypes: flattenedArgTypes
  };
}
function renderFragment(fragment, placeholderFormat, ctx) {
  const fragmentType = fragment.type;
  switch (fragmentType) {
    case "parameter":
      return formatPlaceholder(placeholderFormat, ctx.placeholderNumber++);
    case "stringChunk":
      return fragment.chunk;
    case "parameterTuple": {
      const placeholders = fragment.value.length == 0 ? "NULL" : fragment.value.map(() => formatPlaceholder(placeholderFormat, ctx.placeholderNumber++)).join(",");
      return `(${placeholders})`;
    }
    case "parameterTupleList": {
      return fragment.value.map((tuple) => {
        const elements = tuple.map(() => formatPlaceholder(placeholderFormat, ctx.placeholderNumber++)).join(fragment.itemSeparator);
        return `${fragment.itemPrefix}${elements}${fragment.itemSuffix}`;
      }).join(fragment.groupSeparator);
    }
    default:
      assertNever(fragmentType, "Invalid fragment type");
  }
}
function formatPlaceholder(placeholderFormat, placeholderNumber) {
  return placeholderFormat.hasNumbering ? `${placeholderFormat.prefix}${placeholderNumber}` : placeholderFormat.prefix;
}
function renderRawSql(sql, args, argTypes) {
  return {
    sql,
    args,
    argTypes
  };
}
function doesRequireEvaluation(param) {
  return isPrismaValuePlaceholder(param) || isPrismaValueGenerator(param);
}
function* pairFragmentsWithParams(fragments, params, argTypes) {
  let index = 0;
  for (const fragment of fragments) {
    switch (fragment.type) {
      case "parameter": {
        if (index >= params.length) {
          throw new Error(`Malformed query template. Fragments attempt to read over ${params.length} parameters.`);
        }
        yield { ...fragment, value: params[index], argType: argTypes?.[index] };
        index++;
        break;
      }
      case "stringChunk": {
        yield fragment;
        break;
      }
      case "parameterTuple": {
        if (index >= params.length) {
          throw new Error(`Malformed query template. Fragments attempt to read over ${params.length} parameters.`);
        }
        const value = params[index];
        yield { ...fragment, value: Array.isArray(value) ? value : [value], argType: argTypes?.[index] };
        index++;
        break;
      }
      case "parameterTupleList": {
        if (index >= params.length) {
          throw new Error(`Malformed query template. Fragments attempt to read over ${params.length} parameters.`);
        }
        const value = params[index];
        if (!Array.isArray(value)) {
          throw new Error(`Malformed query template. Tuple list expected.`);
        }
        if (value.length === 0) {
          throw new Error(`Malformed query template. Tuple list cannot be empty.`);
        }
        for (const tuple of value) {
          if (!Array.isArray(tuple)) {
            throw new Error(`Malformed query template. Tuple expected.`);
          }
        }
        yield { ...fragment, value, argType: argTypes?.[index] };
        index++;
        break;
      }
    }
  }
}
function* flattenedFragmentParams(fragment) {
  switch (fragment.type) {
    case "parameter":
      yield fragment.value;
      break;
    case "stringChunk":
      break;
    case "parameterTuple":
      yield* fragment.value;
      break;
    case "parameterTupleList":
      for (const tuple of fragment.value) {
        yield* tuple;
      }
      break;
  }
}
function chunkParams(fragments, params, maxChunkSize) {
  let totalParamCount = 0;
  let maxParamsPerFragment = 0;
  for (const fragment of pairFragmentsWithParams(fragments, params, void 0)) {
    let paramSize = 0;
    for (const _ of flattenedFragmentParams(fragment)) {
      void _;
      paramSize++;
    }
    maxParamsPerFragment = Math.max(maxParamsPerFragment, paramSize);
    totalParamCount += paramSize;
  }
  let chunkedParams = [[]];
  for (const fragment of pairFragmentsWithParams(fragments, params, void 0)) {
    switch (fragment.type) {
      case "parameter": {
        for (const params2 of chunkedParams) {
          params2.push(fragment.value);
        }
        break;
      }
      case "stringChunk": {
        break;
      }
      case "parameterTuple": {
        const thisParamCount = fragment.value.length;
        let chunks = [];
        if (maxChunkSize && // Have we split the parameters into chunks already?
        chunkedParams.length === 1 && // Is this the fragment that has the most parameters?
        thisParamCount === maxParamsPerFragment && // Do we need chunking to fit the parameters?
        totalParamCount > maxChunkSize && // Would chunking enable us to fit the parameters?
        totalParamCount - thisParamCount < maxChunkSize) {
          const availableSize = maxChunkSize - (totalParamCount - thisParamCount);
          chunks = chunkArray(fragment.value, availableSize);
        } else {
          chunks = [fragment.value];
        }
        chunkedParams = chunkedParams.flatMap((params2) => chunks.map((chunk) => [...params2, chunk]));
        break;
      }
      case "parameterTupleList": {
        const thisParamCount = fragment.value.reduce((acc, tuple) => acc + tuple.length, 0);
        const completeChunks = [];
        let currentChunk = [];
        let currentChunkParamCount = 0;
        for (const tuple of fragment.value) {
          if (maxChunkSize && // Have we split the parameters into chunks already?
          chunkedParams.length === 1 && // Is this the fragment that has the most parameters?
          thisParamCount === maxParamsPerFragment && // Is there anything in the current chunk?
          currentChunk.length > 0 && // Will adding this tuple exceed the max chunk size?
          totalParamCount - thisParamCount + currentChunkParamCount + tuple.length > maxChunkSize) {
            completeChunks.push(currentChunk);
            currentChunk = [];
            currentChunkParamCount = 0;
          }
          currentChunk.push(tuple);
          currentChunkParamCount += tuple.length;
        }
        if (currentChunk.length > 0) {
          completeChunks.push(currentChunk);
        }
        chunkedParams = chunkedParams.flatMap((params2) => completeChunks.map((chunk) => [...params2, chunk]));
        break;
      }
    }
  }
  return chunkedParams;
}
function chunkArray(array, chunkSize) {
  const result = [];
  for (let i = 0; i < array.length; i += chunkSize) {
    result.push(array.slice(i, i + chunkSize));
  }
  return result;
}

// src/interpreter/serialize-sql.ts
var import_driver_adapter_utils2 = require("@prisma/driver-adapter-utils");
function serializeSql(resultSet) {
  return resultSet.rows.map(
    (row) => row.reduce((acc, value, index) => {
      acc[resultSet.columnNames[index]] = value;
      return acc;
    }, {})
  );
}
function serializeRawSql(resultSet) {
  return {
    columns: resultSet.columnNames,
    types: resultSet.columnTypes.map((type) => serializeColumnType(type)),
    rows: resultSet.rows.map(
      (row) => row.map((value, index) => serializeRawValue(value, resultSet.columnTypes[index]))
    )
  };
}
function serializeRawValue(value, type) {
  if (value === null) {
    return null;
  }
  switch (type) {
    case import_driver_adapter_utils2.ColumnTypeEnum.Int32:
      switch (typeof value) {
        case "number":
          return Math.trunc(value);
        case "string":
          return Math.trunc(Number(value));
        default:
          throw new Error(`Cannot serialize value of type ${typeof value} as Int32`);
      }
    case import_driver_adapter_utils2.ColumnTypeEnum.Int32Array:
      if (!Array.isArray(value)) {
        throw new Error(`Cannot serialize value of type ${typeof value} as Int32Array`);
      }
      return value.map((v) => serializeRawValue(v, import_driver_adapter_utils2.ColumnTypeEnum.Int32));
    case import_driver_adapter_utils2.ColumnTypeEnum.Int64:
      switch (typeof value) {
        case "number":
          return BigInt(Math.trunc(value));
        case "string":
          return value;
        default:
          throw new Error(`Cannot serialize value of type ${typeof value} as Int64`);
      }
    case import_driver_adapter_utils2.ColumnTypeEnum.Int64Array:
      if (!Array.isArray(value)) {
        throw new Error(`Cannot serialize value of type ${typeof value} as Int64Array`);
      }
      return value.map((v) => serializeRawValue(v, import_driver_adapter_utils2.ColumnTypeEnum.Int64));
    case import_driver_adapter_utils2.ColumnTypeEnum.Json:
      switch (typeof value) {
        case "string":
          return JSON.parse(value);
        default:
          throw new Error(`Cannot serialize value of type ${typeof value} as Json`);
      }
    case import_driver_adapter_utils2.ColumnTypeEnum.JsonArray:
      if (!Array.isArray(value)) {
        throw new Error(`Cannot serialize value of type ${typeof value} as JsonArray`);
      }
      return value.map((v) => serializeRawValue(v, import_driver_adapter_utils2.ColumnTypeEnum.Json));
    case import_driver_adapter_utils2.ColumnTypeEnum.Bytes:
      if (Array.isArray(value)) {
        return new Uint8Array(value);
      } else {
        throw new Error(`Cannot serialize value of type ${typeof value} as Bytes`);
      }
    case import_driver_adapter_utils2.ColumnTypeEnum.BytesArray:
      if (!Array.isArray(value)) {
        throw new Error(`Cannot serialize value of type ${typeof value} as BytesArray`);
      }
      return value.map((v) => serializeRawValue(v, import_driver_adapter_utils2.ColumnTypeEnum.Bytes));
    case import_driver_adapter_utils2.ColumnTypeEnum.Boolean:
      switch (typeof value) {
        case "boolean":
          return value;
        case "string":
          return value === "true" || value === "1";
        case "number":
          return value === 1;
        default:
          throw new Error(`Cannot serialize value of type ${typeof value} as Boolean`);
      }
    case import_driver_adapter_utils2.ColumnTypeEnum.BooleanArray:
      if (!Array.isArray(value)) {
        throw new Error(`Cannot serialize value of type ${typeof value} as BooleanArray`);
      }
      return value.map((v) => serializeRawValue(v, import_driver_adapter_utils2.ColumnTypeEnum.Boolean));
    default:
      return value;
  }
}
function serializeColumnType(columnType) {
  switch (columnType) {
    case import_driver_adapter_utils2.ColumnTypeEnum.Int32:
      return "int";
    case import_driver_adapter_utils2.ColumnTypeEnum.Int64:
      return "bigint";
    case import_driver_adapter_utils2.ColumnTypeEnum.Float:
      return "float";
    case import_driver_adapter_utils2.ColumnTypeEnum.Double:
      return "double";
    case import_driver_adapter_utils2.ColumnTypeEnum.Text:
      return "string";
    case import_driver_adapter_utils2.ColumnTypeEnum.Enum:
      return "enum";
    case import_driver_adapter_utils2.ColumnTypeEnum.Bytes:
      return "bytes";
    case import_driver_adapter_utils2.ColumnTypeEnum.Boolean:
      return "bool";
    case import_driver_adapter_utils2.ColumnTypeEnum.Character:
      return "char";
    case import_driver_adapter_utils2.ColumnTypeEnum.Numeric:
      return "decimal";
    case import_driver_adapter_utils2.ColumnTypeEnum.Json:
      return "json";
    case import_driver_adapter_utils2.ColumnTypeEnum.Uuid:
      return "uuid";
    case import_driver_adapter_utils2.ColumnTypeEnum.DateTime:
      return "datetime";
    case import_driver_adapter_utils2.ColumnTypeEnum.Date:
      return "date";
    case import_driver_adapter_utils2.ColumnTypeEnum.Time:
      return "time";
    case import_driver_adapter_utils2.ColumnTypeEnum.Int32Array:
      return "int-array";
    case import_driver_adapter_utils2.ColumnTypeEnum.Int64Array:
      return "bigint-array";
    case import_driver_adapter_utils2.ColumnTypeEnum.FloatArray:
      return "float-array";
    case import_driver_adapter_utils2.ColumnTypeEnum.DoubleArray:
      return "double-array";
    case import_driver_adapter_utils2.ColumnTypeEnum.TextArray:
      return "string-array";
    case import_driver_adapter_utils2.ColumnTypeEnum.EnumArray:
      return "string-array";
    case import_driver_adapter_utils2.ColumnTypeEnum.BytesArray:
      return "bytes-array";
    case import_driver_adapter_utils2.ColumnTypeEnum.BooleanArray:
      return "bool-array";
    case import_driver_adapter_utils2.ColumnTypeEnum.CharacterArray:
      return "char-array";
    case import_driver_adapter_utils2.ColumnTypeEnum.NumericArray:
      return "decimal-array";
    case import_driver_adapter_utils2.ColumnTypeEnum.JsonArray:
      return "json-array";
    case import_driver_adapter_utils2.ColumnTypeEnum.UuidArray:
      return "uuid-array";
    case import_driver_adapter_utils2.ColumnTypeEnum.DateTimeArray:
      return "datetime-array";
    case import_driver_adapter_utils2.ColumnTypeEnum.DateArray:
      return "date-array";
    case import_driver_adapter_utils2.ColumnTypeEnum.TimeArray:
      return "time-array";
    case import_driver_adapter_utils2.ColumnTypeEnum.UnknownNumber:
      return "unknown";
    /// The following PlanetScale type IDs are mapped into Set:
    /// - SET (SET) -> e.g. `"foo,bar"` (String-encoded, comma-separated)
    case import_driver_adapter_utils2.ColumnTypeEnum.Set:
      return "string";
    default:
      assertNever(columnType, `Unexpected column type: ${columnType}`);
  }
}

// src/interpreter/validation.ts
function performValidation(data, rules, error) {
  if (!rules.every((rule) => doesSatisfyRule(data, rule))) {
    const message = renderMessage(data, error);
    const code = getErrorCode2(error);
    throw new UserFacingError(message, code, error.context);
  }
}
function doesSatisfyRule(data, rule) {
  switch (rule.type) {
    case "rowCountEq":
      if (Array.isArray(data)) {
        return data.length === rule.args;
      }
      if (data === null) {
        return rule.args === 0;
      }
      return rule.args === 1;
    case "rowCountNeq":
      if (Array.isArray(data)) {
        return data.length !== rule.args;
      }
      if (data === null) {
        return rule.args !== 0;
      }
      return rule.args !== 1;
    case "affectedRowCountEq":
      return data === rule.args;
    case "never":
      return false;
    default:
      assertNever(rule, `Unknown rule type: ${rule.type}`);
  }
}
function renderMessage(data, error) {
  switch (error.error_identifier) {
    case "RELATION_VIOLATION":
      return `The change you are trying to make would violate the required relation '${error.context.relation}' between the \`${error.context.modelA}\` and \`${error.context.modelB}\` models.`;
    case "MISSING_RECORD":
      return `An operation failed because it depends on one or more records that were required but not found. No record was found for ${error.context.operation}.`;
    case "MISSING_RELATED_RECORD": {
      const hint = error.context.neededFor ? ` (needed to ${error.context.neededFor})` : "";
      return `An operation failed because it depends on one or more records that were required but not found. No '${error.context.model}' record${hint} was found for ${error.context.operation} on ${error.context.relationType} relation '${error.context.relation}'.`;
    }
    case "INCOMPLETE_CONNECT_INPUT":
      return `An operation failed because it depends on one or more records that were required but not found. Expected ${error.context.expectedRows} records to be connected, found only ${Array.isArray(data) ? data.length : data}.`;
    case "INCOMPLETE_CONNECT_OUTPUT":
      return `The required connected records were not found. Expected ${error.context.expectedRows} records to be connected after connect operation on ${error.context.relationType} relation '${error.context.relation}', found ${Array.isArray(data) ? data.length : data}.`;
    case "RECORDS_NOT_CONNECTED":
      return `The records for relation \`${error.context.relation}\` between the \`${error.context.parent}\` and \`${error.context.child}\` models are not connected.`;
    default:
      assertNever(error, `Unknown error identifier: ${error}`);
  }
}
function getErrorCode2(error) {
  switch (error.error_identifier) {
    case "RELATION_VIOLATION":
      return "P2014";
    case "RECORDS_NOT_CONNECTED":
      return "P2017";
    case "INCOMPLETE_CONNECT_OUTPUT":
      return "P2018";
    case "MISSING_RECORD":
    case "MISSING_RELATED_RECORD":
    case "INCOMPLETE_CONNECT_INPUT":
      return "P2025";
    default:
      assertNever(error, `Unknown error identifier: ${error}`);
  }
}

// src/interpreter/query-interpreter.ts
var QueryInterpreter = class _QueryInterpreter {
  #transactionManager;
  #placeholderValues;
  #onQuery;
  #generators = new GeneratorRegistry();
  #tracingHelper;
  #serializer;
  #rawSerializer;
  #provider;
  #connectioInfo;
  constructor({
    transactionManager,
    placeholderValues,
    onQuery,
    tracingHelper,
    serializer,
    rawSerializer,
    provider,
    connectionInfo
  }) {
    this.#transactionManager = transactionManager;
    this.#placeholderValues = placeholderValues;
    this.#onQuery = onQuery;
    this.#tracingHelper = tracingHelper;
    this.#serializer = serializer;
    this.#rawSerializer = rawSerializer ?? serializer;
    this.#provider = provider;
    this.#connectioInfo = connectionInfo;
  }
  static forSql(options) {
    return new _QueryInterpreter({
      transactionManager: options.transactionManager,
      placeholderValues: options.placeholderValues,
      onQuery: options.onQuery,
      tracingHelper: options.tracingHelper,
      serializer: serializeSql,
      rawSerializer: serializeRawSql,
      provider: options.provider,
      connectionInfo: options.connectionInfo
    });
  }
  async run(queryPlan, queryable) {
    const { value } = await this.interpretNode(
      queryPlan,
      queryable,
      this.#placeholderValues,
      this.#generators.snapshot()
    ).catch((e) => rethrowAsUserFacing(e));
    return value;
  }
  async interpretNode(node, queryable, scope, generators) {
    switch (node.type) {
      case "value": {
        return { value: evaluateArg(node.args, scope, generators) };
      }
      case "seq": {
        let result;
        for (const arg of node.args) {
          result = await this.interpretNode(arg, queryable, scope, generators);
        }
        return result ?? { value: void 0 };
      }
      case "get": {
        return { value: scope[node.args.name] };
      }
      case "let": {
        const nestedScope = Object.create(scope);
        for (const binding of node.args.bindings) {
          const { value } = await this.interpretNode(binding.expr, queryable, nestedScope, generators);
          nestedScope[binding.name] = value;
        }
        return this.interpretNode(node.args.expr, queryable, nestedScope, generators);
      }
      case "getFirstNonEmpty": {
        for (const name of node.args.names) {
          const value = scope[name];
          if (!isEmpty(value)) {
            return { value };
          }
        }
        return { value: [] };
      }
      case "concat": {
        const parts = await Promise.all(
          node.args.map((arg) => this.interpretNode(arg, queryable, scope, generators).then((res) => res.value))
        );
        return {
          value: parts.length > 0 ? parts.reduce((acc, part) => acc.concat(asList(part)), []) : []
        };
      }
      case "sum": {
        const parts = await Promise.all(
          node.args.map((arg) => this.interpretNode(arg, queryable, scope, generators).then((res) => res.value))
        );
        return {
          value: parts.length > 0 ? parts.reduce((acc, part) => asNumber2(acc) + asNumber2(part)) : 0
        };
      }
      case "execute": {
        const queries = renderQuery(node.args, scope, generators, this.#maxChunkSize());
        let sum = 0;
        for (const query of queries) {
          sum += await this.#withQuerySpanAndEvent(
            query,
            queryable,
            () => queryable.executeRaw(query).catch(
              (err) => node.args.type === "rawSql" ? rethrowAsUserFacingRawError(err) : rethrowAsUserFacing(err)
            )
          );
        }
        return { value: sum };
      }
      case "query": {
        const queries = renderQuery(node.args, scope, generators, this.#maxChunkSize());
        let results;
        for (const query of queries) {
          const result = await this.#withQuerySpanAndEvent(
            query,
            queryable,
            () => queryable.queryRaw(query).catch(
              (err) => node.args.type === "rawSql" ? rethrowAsUserFacingRawError(err) : rethrowAsUserFacing(err)
            )
          );
          if (results === void 0) {
            results = result;
          } else {
            results.rows.push(...result.rows);
            results.lastInsertId = result.lastInsertId;
          }
        }
        return {
          value: node.args.type === "rawSql" ? this.#rawSerializer(results) : this.#serializer(results),
          lastInsertId: results?.lastInsertId
        };
      }
      case "reverse": {
        const { value, lastInsertId } = await this.interpretNode(node.args, queryable, scope, generators);
        return { value: Array.isArray(value) ? value.reverse() : value, lastInsertId };
      }
      case "unique": {
        const { value, lastInsertId } = await this.interpretNode(node.args, queryable, scope, generators);
        if (!Array.isArray(value)) {
          return { value, lastInsertId };
        }
        if (value.length > 1) {
          throw new Error(`Expected zero or one element, got ${value.length}`);
        }
        return { value: value[0] ?? null, lastInsertId };
      }
      case "required": {
        const { value, lastInsertId } = await this.interpretNode(node.args, queryable, scope, generators);
        if (isEmpty(value)) {
          throw new Error("Required value is empty");
        }
        return { value, lastInsertId };
      }
      case "mapField": {
        const { value, lastInsertId } = await this.interpretNode(node.args.records, queryable, scope, generators);
        return { value: mapField2(value, node.args.field), lastInsertId };
      }
      case "join": {
        const { value: parent, lastInsertId } = await this.interpretNode(node.args.parent, queryable, scope, generators);
        if (parent === null) {
          return { value: null, lastInsertId };
        }
        const children = await Promise.all(
          node.args.children.map(async (joinExpr) => ({
            joinExpr,
            childRecords: (await this.interpretNode(joinExpr.child, queryable, scope, generators)).value
          }))
        );
        return { value: attachChildrenToParents(parent, children), lastInsertId };
      }
      case "transaction": {
        if (!this.#transactionManager.enabled) {
          return this.interpretNode(node.args, queryable, scope, generators);
        }
        const transactionManager = this.#transactionManager.manager;
        const transactionInfo = await transactionManager.startTransaction();
        const transaction = await transactionManager.getTransaction(transactionInfo, "query");
        try {
          const value = await this.interpretNode(node.args, transaction, scope, generators);
          await transactionManager.commitTransaction(transactionInfo.id);
          return value;
        } catch (e) {
          await transactionManager.rollbackTransaction(transactionInfo.id);
          throw e;
        }
      }
      case "dataMap": {
        const { value, lastInsertId } = await this.interpretNode(node.args.expr, queryable, scope, generators);
        return { value: applyDataMap(value, node.args.structure, node.args.enums), lastInsertId };
      }
      case "validate": {
        const { value, lastInsertId } = await this.interpretNode(node.args.expr, queryable, scope, generators);
        performValidation(value, node.args.rules, node.args);
        return { value, lastInsertId };
      }
      case "if": {
        const { value } = await this.interpretNode(node.args.value, queryable, scope, generators);
        if (doesSatisfyRule(value, node.args.rule)) {
          return await this.interpretNode(node.args.then, queryable, scope, generators);
        } else {
          return await this.interpretNode(node.args.else, queryable, scope, generators);
        }
      }
      case "unit": {
        return { value: void 0 };
      }
      case "diff": {
        const { value: from } = await this.interpretNode(node.args.from, queryable, scope, generators);
        const { value: to } = await this.interpretNode(node.args.to, queryable, scope, generators);
        const toSet = new Set(asList(to).map((item) => JSON.stringify(item)));
        return { value: asList(from).filter((item) => !toSet.has(JSON.stringify(item))) };
      }
      case "process": {
        const { value, lastInsertId } = await this.interpretNode(node.args.expr, queryable, scope, generators);
        return { value: processRecords(value, node.args.operations), lastInsertId };
      }
      case "initializeRecord": {
        const { lastInsertId } = await this.interpretNode(node.args.expr, queryable, scope, generators);
        const record = {};
        for (const [key, initializer] of Object.entries(node.args.fields)) {
          record[key] = evalFieldInitializer(initializer, lastInsertId, scope, generators);
        }
        return { value: record, lastInsertId };
      }
      case "mapRecord": {
        const { value, lastInsertId } = await this.interpretNode(node.args.expr, queryable, scope, generators);
        const record = value === null ? {} : asRecord(value);
        for (const [key, entry] of Object.entries(node.args.fields)) {
          record[key] = evalFieldOperation(entry, record[key], scope, generators);
        }
        return { value: record, lastInsertId };
      }
      default:
        assertNever(node, `Unexpected node type: ${node.type}`);
    }
  }
  #maxChunkSize() {
    if (this.#connectioInfo?.maxBindValues !== void 0) {
      return this.#connectioInfo.maxBindValues;
    }
    return this.#providerMaxChunkSize();
  }
  #providerMaxChunkSize() {
    if (this.#provider === void 0) {
      return void 0;
    }
    switch (this.#provider) {
      case "cockroachdb":
      case "postgres":
      case "postgresql":
      case "prisma+postgres":
        return 32766;
      case "mysql":
        return 65535;
      case "sqlite":
        return 999;
      case "sqlserver":
        return 2098;
      case "mongodb":
        return void 0;
      default:
        assertNever(this.#provider, `Unexpected provider: ${this.#provider}`);
    }
  }
  #withQuerySpanAndEvent(query, queryable, execute) {
    return withQuerySpanAndEvent({
      query,
      execute,
      provider: this.#provider ?? queryable.provider,
      tracingHelper: this.#tracingHelper,
      onQuery: this.#onQuery
    });
  }
};
function isEmpty(value) {
  if (Array.isArray(value)) {
    return value.length === 0;
  }
  return value == null;
}
function asList(value) {
  return Array.isArray(value) ? value : [value];
}
function asNumber2(value) {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "string") {
    return Number(value);
  }
  throw new Error(`Expected number, got ${typeof value}`);
}
function asRecord(value) {
  if (typeof value === "object" && value !== null) {
    return value;
  }
  throw new Error(`Expected object, got ${typeof value}`);
}
function mapField2(value, field) {
  if (Array.isArray(value)) {
    return value.map((element) => mapField2(element, field));
  }
  if (typeof value === "object" && value !== null) {
    return value[field] ?? null;
  }
  return value;
}
function attachChildrenToParents(parentRecords, children) {
  for (const { joinExpr, childRecords } of children) {
    const parentKeys = joinExpr.on.map(([k]) => k);
    const childKeys = joinExpr.on.map(([, k]) => k);
    const parentMap = {};
    for (const parent of Array.isArray(parentRecords) ? parentRecords : [parentRecords]) {
      const parentRecord = asRecord(parent);
      const key = getRecordKey(parentRecord, parentKeys);
      if (!parentMap[key]) {
        parentMap[key] = [];
      }
      parentMap[key].push(parentRecord);
      if (joinExpr.isRelationUnique) {
        parentRecord[joinExpr.parentField] = null;
      } else {
        parentRecord[joinExpr.parentField] = [];
      }
    }
    for (const childRecord of Array.isArray(childRecords) ? childRecords : [childRecords]) {
      if (childRecord === null) {
        continue;
      }
      const key = getRecordKey(asRecord(childRecord), childKeys);
      for (const parentRecord of parentMap[key] ?? []) {
        if (joinExpr.isRelationUnique) {
          parentRecord[joinExpr.parentField] = childRecord;
        } else {
          parentRecord[joinExpr.parentField].push(childRecord);
        }
      }
    }
  }
  return parentRecords;
}
function evalFieldInitializer(initializer, lastInsertId, scope, generators) {
  switch (initializer.type) {
    case "value":
      return evaluateArg(initializer.value, scope, generators);
    case "lastInsertId":
      return lastInsertId;
    default:
      assertNever(initializer, `Unexpected field initializer type: ${initializer["type"]}`);
  }
}
function evalFieldOperation(op, value, scope, generators) {
  switch (op.type) {
    case "set":
      return evaluateArg(op.value, scope, generators);
    case "add":
      return asNumber2(value) + asNumber2(evaluateArg(op.value, scope, generators));
    case "subtract":
      return asNumber2(value) - asNumber2(evaluateArg(op.value, scope, generators));
    case "multiply":
      return asNumber2(value) * asNumber2(evaluateArg(op.value, scope, generators));
    case "divide": {
      const lhs = asNumber2(value);
      const rhs = asNumber2(evaluateArg(op.value, scope, generators));
      if (rhs === 0) {
        return null;
      }
      return lhs / rhs;
    }
    default:
      assertNever(op, `Unexpected field operation type: ${op["type"]}`);
  }
}

// src/raw-json-protocol.ts
var import_decimal4 = __toESM(require("decimal.js"));
function normalizeRawJsonProtocolResponse(response) {
  for (let i = 0; i < response.rows.length; i++) {
    const row = response.rows[i];
    for (let j = 0; j < row.length; j++) {
      row[j] = normalizeValue(response.types[j], row[j]);
    }
  }
  return response;
}
function normalizeValue(type, value) {
  if (value === null) {
    return value;
  }
  switch (type) {
    case "bigint":
      return String(BigInt(value));
    case "decimal":
      return String(new import_decimal4.default(value));
    case "bigint-array":
      return value.map((v) => normalizeValue("bigint", v));
    case "decimal-array":
      return value.map((v) => normalizeValue("decimal", v));
    default:
      return value;
  }
}

// src/transaction-manager/transaction-manager.ts
var import_debug = require("@prisma/debug");

// src/crypto.ts
async function getCrypto() {
  return globalThis.crypto ?? await import("node:crypto");
}
async function randomUUID() {
  const crypto = await getCrypto();
  return crypto.randomUUID();
}

// src/transaction-manager/transaction-manager-error.ts
var TransactionManagerError = class extends UserFacingError {
  name = "TransactionManagerError";
  constructor(message, meta) {
    super("Transaction API error: " + message, "P2028", meta);
  }
};
var TransactionNotFoundError = class extends TransactionManagerError {
  constructor() {
    super(
      "Transaction not found. Transaction ID is invalid, refers to an old closed transaction Prisma doesn't have information about anymore, or was obtained before disconnecting."
    );
  }
};
var TransactionClosedError = class extends TransactionManagerError {
  constructor(operation) {
    super(`Transaction already closed: A ${operation} cannot be executed on a committed transaction.`);
  }
};
var TransactionRolledBackError = class extends TransactionManagerError {
  constructor(operation) {
    super(`Transaction already closed: A ${operation} cannot be executed on a transaction that was rolled back.`);
  }
};
var TransactionStartTimeoutError = class extends TransactionManagerError {
  constructor() {
    super("Unable to start a transaction in the given time.");
  }
};
var TransactionExecutionTimeoutError = class extends TransactionManagerError {
  constructor(operation, { timeout, timeTaken }) {
    super(
      `A ${operation} cannot be executed on an expired transaction. The timeout for this transaction was ${timeout} ms, however ${timeTaken} ms passed since the start of the transaction. Consider increasing the interactive transaction timeout or doing less work in the transaction.`,
      { operation, timeout, timeTaken }
    );
  }
};
var TransactionInternalConsistencyError = class extends TransactionManagerError {
  constructor(message) {
    super(`Internal Consistency Error: ${message}`);
  }
};
var InvalidTransactionIsolationLevelError = class extends TransactionManagerError {
  constructor(isolationLevel) {
    super(`Invalid isolation level: ${isolationLevel}`, { isolationLevel });
  }
};

// src/transaction-manager/transaction-manager.ts
var MAX_CLOSED_TRANSACTIONS = 100;
var debug = (0, import_debug.Debug)("prisma:client:transactionManager");
var COMMIT_QUERY = () => ({ sql: "COMMIT", args: [], argTypes: [] });
var ROLLBACK_QUERY = () => ({ sql: "ROLLBACK", args: [], argTypes: [] });
var PHANTOM_COMMIT_QUERY = () => ({
  sql: '-- Implicit "COMMIT" query via underlying driver',
  args: [],
  argTypes: []
});
var PHANTOM_ROLLBACK_QUERY = () => ({
  sql: '-- Implicit "ROLLBACK" query via underlying driver',
  args: [],
  argTypes: []
});
var TransactionManager = class {
  // The map of active transactions.
  transactions = /* @__PURE__ */ new Map();
  // List of last closed transactions. Max MAX_CLOSED_TRANSACTIONS entries.
  // Used to provide better error messages than a generic "transaction not found".
  closedTransactions = [];
  driverAdapter;
  transactionOptions;
  tracingHelper;
  #onQuery;
  #provider;
  constructor({
    driverAdapter,
    transactionOptions,
    tracingHelper,
    onQuery,
    provider
  }) {
    this.driverAdapter = driverAdapter;
    this.transactionOptions = transactionOptions;
    this.tracingHelper = tracingHelper;
    this.#onQuery = onQuery;
    this.#provider = provider;
  }
  async startTransaction(options) {
    return await this.tracingHelper.runInChildSpan("start_transaction", () => this.#startTransactionImpl(options));
  }
  async #startTransactionImpl(options) {
    const validatedOptions = options !== void 0 ? this.#validateOptions(options) : this.transactionOptions;
    const transaction = {
      id: await randomUUID(),
      status: "waiting",
      timer: void 0,
      timeout: validatedOptions.timeout,
      startedAt: Date.now(),
      transaction: void 0
    };
    this.transactions.set(transaction.id, transaction);
    let hasTimedOut = false;
    const startTimer = setTimeout(() => hasTimedOut = true, validatedOptions.maxWait);
    startTimer.unref?.();
    transaction.transaction = await this.driverAdapter.startTransaction(validatedOptions.isolationLevel).catch(rethrowAsUserFacing);
    clearTimeout(startTimer);
    switch (transaction.status) {
      case "waiting":
        if (hasTimedOut) {
          await this.#closeTransaction(transaction, "timed_out");
          throw new TransactionStartTimeoutError();
        }
        transaction.status = "running";
        transaction.timer = this.#startTransactionTimeout(transaction.id, validatedOptions.timeout);
        return { id: transaction.id };
      case "timed_out":
      case "running":
      case "committed":
      case "rolled_back":
        throw new TransactionInternalConsistencyError(
          `Transaction in invalid state ${transaction.status} although it just finished startup.`
        );
      default:
        assertNever(transaction["status"], "Unknown transaction status.");
    }
  }
  async commitTransaction(transactionId) {
    return await this.tracingHelper.runInChildSpan("commit_transaction", async () => {
      const txw = this.#getActiveOrClosingTransaction(transactionId, "commit");
      await this.#closeTransaction(txw, "committed");
    });
  }
  async rollbackTransaction(transactionId) {
    return await this.tracingHelper.runInChildSpan("rollback_transaction", async () => {
      const txw = this.#getActiveOrClosingTransaction(transactionId, "rollback");
      await this.#closeTransaction(txw, "rolled_back");
    });
  }
  async getTransaction(txInfo, operation) {
    let tx = this.#getActiveOrClosingTransaction(txInfo.id, operation);
    if (tx.status === "closing") {
      await tx.closing;
      tx = this.#getActiveOrClosingTransaction(txInfo.id, operation);
    }
    if (!tx.transaction) throw new TransactionNotFoundError();
    return tx.transaction;
  }
  #getActiveOrClosingTransaction(transactionId, operation) {
    const transaction = this.transactions.get(transactionId);
    if (!transaction) {
      const closedTransaction = this.closedTransactions.find((tx) => tx.id === transactionId);
      if (closedTransaction) {
        debug("Transaction already closed.", { transactionId, status: closedTransaction.status });
        switch (closedTransaction.status) {
          case "closing":
          case "waiting":
          case "running":
            throw new TransactionInternalConsistencyError("Active transaction found in closed transactions list.");
          case "committed":
            throw new TransactionClosedError(operation);
          case "rolled_back":
            throw new TransactionRolledBackError(operation);
          case "timed_out":
            throw new TransactionExecutionTimeoutError(operation, {
              timeout: closedTransaction.timeout,
              timeTaken: Date.now() - closedTransaction.startedAt
            });
        }
      } else {
        debug(`Transaction not found.`, transactionId);
        throw new TransactionNotFoundError();
      }
    }
    if (["committed", "rolled_back", "timed_out"].includes(transaction.status)) {
      throw new TransactionInternalConsistencyError("Closed transaction found in active transactions map.");
    }
    return transaction;
  }
  async cancelAllTransactions() {
    await Promise.allSettled([...this.transactions.values()].map((tx) => this.#closeTransaction(tx, "rolled_back")));
  }
  #startTransactionTimeout(transactionId, timeout) {
    const timeoutStartedAt = Date.now();
    const timer = setTimeout(async () => {
      debug("Transaction timed out.", { transactionId, timeoutStartedAt, timeout });
      const tx = this.transactions.get(transactionId);
      if (tx && ["running", "waiting"].includes(tx.status)) {
        await this.#closeTransaction(tx, "timed_out");
      } else {
        debug("Transaction already committed or rolled back when timeout happened.", transactionId);
      }
    }, timeout);
    timer.unref?.();
    return timer;
  }
  async #closeTransaction(tx, status) {
    const createClosingPromise = async () => {
      debug("Closing transaction.", { transactionId: tx.id, status });
      try {
        if (tx.transaction && status === "committed") {
          if (tx.transaction.options.usePhantomQuery) {
            await this.#withQuerySpanAndEvent(PHANTOM_COMMIT_QUERY(), tx.transaction, () => tx.transaction.commit());
          } else {
            const query = COMMIT_QUERY();
            await this.#withQuerySpanAndEvent(query, tx.transaction, () => tx.transaction.executeRaw(query));
            await tx.transaction.commit();
          }
        } else if (tx.transaction) {
          if (tx.transaction.options.usePhantomQuery) {
            await this.#withQuerySpanAndEvent(
              PHANTOM_ROLLBACK_QUERY(),
              tx.transaction,
              () => tx.transaction.rollback()
            );
          } else {
            const query = ROLLBACK_QUERY();
            await this.#withQuerySpanAndEvent(query, tx.transaction, () => tx.transaction.executeRaw(query));
            await tx.transaction.rollback();
          }
        }
      } finally {
        tx.status = status;
        clearTimeout(tx.timer);
        tx.timer = void 0;
        this.transactions.delete(tx.id);
        this.closedTransactions.push(tx);
        if (this.closedTransactions.length > MAX_CLOSED_TRANSACTIONS) {
          this.closedTransactions.shift();
        }
      }
    };
    if (tx.status === "closing") {
      await tx.closing;
      this.#getActiveOrClosingTransaction(tx.id, status === "committed" ? "commit" : "rollback");
    } else {
      await Object.assign(tx, {
        status: "closing",
        reason: status,
        closing: createClosingPromise()
      }).closing;
    }
  }
  #validateOptions(options) {
    if (!options.timeout) throw new TransactionManagerError("timeout is required");
    if (!options.maxWait) throw new TransactionManagerError("maxWait is required");
    if (options.isolationLevel === "SNAPSHOT") throw new InvalidTransactionIsolationLevelError(options.isolationLevel);
    return {
      ...options,
      timeout: options.timeout,
      maxWait: options.maxWait
    };
  }
  #withQuerySpanAndEvent(query, queryable, execute) {
    return withQuerySpanAndEvent({
      query,
      execute,
      provider: this.#provider ?? queryable.provider,
      tracingHelper: this.tracingHelper,
      onQuery: this.#onQuery
    });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DataMapperError,
  QueryInterpreter,
  TransactionManager,
  TransactionManagerError,
  UserFacingError,
  convertCompactedRows,
  deserializeJsonResponse,
  doKeysMatch,
  isDeepStrictEqual,
  isPrismaValueGenerator,
  isPrismaValuePlaceholder,
  noopTracingHelper,
  normalizeJsonProtocolValues,
  normalizeRawJsonProtocolResponse,
  safeJsonStringify
});
