import { ArgType } from '@prisma/driver-adapter-utils';
import { Arity } from '@prisma/driver-adapter-utils';
import { ConnectionInfo } from '@prisma/driver-adapter-utils';
import { Context } from '@opentelemetry/api';
import { Decimal } from 'decimal.js';
import type { IsolationLevel } from '@prisma/driver-adapter-utils';
import { Span } from '@opentelemetry/api';
import { SpanOptions } from '@opentelemetry/api';
import { SqlDriverAdapter } from '@prisma/driver-adapter-utils';
import { SqlQueryable } from '@prisma/driver-adapter-utils';
import { SqlResultSet } from '@prisma/driver-adapter-utils';
import { Transaction } from '@prisma/driver-adapter-utils';

export declare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;

export declare type BigIntTaggedValue = {
    $type: 'BigInt';
    value: string;
};

export declare type BytesTaggedValue = {
    $type: 'Bytes';
    value: string;
};

export declare type CompactedBatchResponse = {
    type: 'compacted';
    plan: QueryPlanNode;
    arguments: Record<string, {}>[];
    nestedSelection: string[];
    keys: string[];
    expectNonEmpty: boolean;
};

/**
 * Converts the result of a compacted query back to result objects analogous to what queries
 * would return when executed individually.
 */
export declare function convertCompactedRows(rows: {}[], compiledBatch: CompactedBatchResponse): unknown[];

export declare class DataMapperError extends Error {
    name: string;
}

export declare type DataRule = {
    type: 'rowCountEq';
    args: number;
} | {
    type: 'rowCountNeq';
    args: number;
} | {
    type: 'affectedRowCountEq';
    args: number;
} | {
    type: 'never';
};

export declare type DateTaggedValue = {
    $type: 'DateTime';
    value: string;
};

export declare type DecimalTaggedValue = {
    $type: 'Decimal';
    value: string;
};

export declare function deserializeJsonResponse(result: unknown): unknown;

/**
 * Checks if two objects representing the names and values of key columns match. A match is
 * defined by one of the sets of keys being a subset of the other. This function also
 * converts arguments to the types used by driver adapters if necessary.
 */
export declare function doKeysMatch(lhs: {}, rhs: {}): boolean;

export declare type DynamicArgType = ArgType | {
    arity: 'tuple';
    elements: ArgType[];
};

export declare type EnumTaggedValue = {
    $type: 'Enum';
    value: string;
};

declare type ExtendedSpanOptions = SpanOptions & {
    name: string;
};

export declare type FieldInitializer = {
    type: 'value';
    value: PrismaValue;
} | {
    type: 'lastInsertId';
};

export declare type FieldOperation = {
    type: 'set';
    value: PrismaValue;
} | {
    type: 'add';
    value: PrismaValue;
} | {
    type: 'subtract';
    value: PrismaValue;
} | {
    type: 'multiply';
    value: PrismaValue;
} | {
    type: 'divide';
    value: PrismaValue;
};

export declare type FieldRefTaggedValue = {
    $type: 'FieldRef';
    value: {
        _ref: string;
    };
};

export declare type FieldScalarType = {
    type: 'string' | 'int' | 'bigint' | 'float' | 'boolean' | 'json' | 'object' | 'datetime' | 'decimal' | 'unsupported';
} | {
    type: 'enum';
    name: string;
} | {
    type: 'bytes';
    encoding: 'array' | 'base64' | 'hex';
};

export declare type FieldType = {
    arity: Arity;
} & FieldScalarType;

export declare type Fragment = {
    type: 'stringChunk';
    chunk: string;
} | {
    type: 'parameter';
} | {
    type: 'parameterTuple';
} | {
    type: 'parameterTupleList';
    itemPrefix: string;
    itemSeparator: string;
    itemSuffix: string;
    groupSeparator: string;
};

export declare type InMemoryOps = {
    pagination: Pagination | null;
    distinct: string[] | null;
    reverse: boolean;
    linkingFields: string[] | null;
    nested: Record<string, InMemoryOps>;
};

/**
 * Checks if two objects are deeply equal, recursively checking all properties for strict equality.
 */
export declare function isDeepStrictEqual(a: unknown, b: unknown): boolean;

export declare function isPrismaValueGenerator(value: unknown): value is PrismaValueGenerator;

export declare function isPrismaValuePlaceholder(value: unknown): value is PrismaValuePlaceholder;

export declare type JoinExpression = {
    child: QueryPlanNode;
    on: [left: string, right: string][];
    parentField: string;
    isRelationUnique: boolean;
};

export declare type JsonInputTaggedValue = DateTaggedValue | DecimalTaggedValue | BytesTaggedValue | BigIntTaggedValue | FieldRefTaggedValue | JsonTaggedValue | EnumTaggedValue;

export declare type JsonOutputTaggedValue = DateTaggedValue | DecimalTaggedValue | BytesTaggedValue | BigIntTaggedValue | JsonTaggedValue;

export declare type JsonTaggedValue = {
    $type: 'Json';
    value: string;
};

export declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {
    [key: string]: JsOutputValue;
};

export declare type MultiBatchResponse = {
    type: 'multi';
    plans: QueryPlanNode[];
};

export declare const noopTracingHelper: TracingHelper;

export declare function normalizeJsonProtocolValues(result: unknown): unknown;

export declare function normalizeRawJsonProtocolResponse(response: RawResponse): RawResponse;

export declare type Pagination = {
    cursor: Record<string, PrismaValue> | null;
    take: number | null;
    skip: number | null;
};

export declare interface PlaceholderFormat {
    prefix: string;
    hasNumbering: boolean;
}

export declare type PrismaValue = string | boolean | number | PrismaValue[] | null | Record<string, unknown> | PrismaValuePlaceholder | PrismaValueGenerator;

export declare type PrismaValueGenerator = {
    prisma__type: 'generatorCall';
    prisma__value: {
        name: string;
        args: PrismaValue[];
    };
};

export declare type PrismaValuePlaceholder = {
    prisma__type: 'param';
    prisma__value: {
        name: string;
        type: string;
    };
};

export declare type QueryEvent = {
    timestamp: Date;
    query: string;
    params: unknown[];
    duration: number;
};

export declare class QueryInterpreter {
    #private;
    constructor({ transactionManager, placeholderValues, onQuery, tracingHelper, serializer, rawSerializer, provider, connectionInfo, }: QueryInterpreterOptions);
    static forSql(options: {
        transactionManager: QueryInterpreterTransactionManager;
        placeholderValues: Record<string, unknown>;
        onQuery?: (event: QueryEvent) => void;
        tracingHelper: TracingHelper;
        provider?: SchemaProvider;
        connectionInfo?: ConnectionInfo;
    }): QueryInterpreter;
    run(queryPlan: QueryPlanNode, queryable: SqlQueryable): Promise<unknown>;
    private interpretNode;
}

export declare type QueryInterpreterOptions = {
    transactionManager: QueryInterpreterTransactionManager;
    placeholderValues: Record<string, unknown>;
    onQuery?: (event: QueryEvent) => void;
    tracingHelper: TracingHelper;
    serializer: (results: SqlResultSet) => Value;
    rawSerializer?: (results: SqlResultSet) => Value;
    provider?: SchemaProvider;
    connectionInfo?: ConnectionInfo;
};

export declare type QueryInterpreterTransactionManager = {
    enabled: true;
    manager: TransactionManager;
} | {
    enabled: false;
};

export declare type QueryPlanBinding = {
    name: string;
    expr: QueryPlanNode;
};

export declare type QueryPlanDbQuery = {
    type: 'rawSql';
    sql: string;
    args: PrismaValue[];
    argTypes: ArgType[];
} | {
    type: 'templateSql';
    fragments: Fragment[];
    placeholderFormat: PlaceholderFormat;
    args: PrismaValue[];
    argTypes: DynamicArgType[];
    chunkable: boolean;
};

export declare type QueryPlanNode = {
    type: 'value';
    args: PrismaValue;
} | {
    type: 'seq';
    args: QueryPlanNode[];
} | {
    type: 'get';
    args: {
        name: string;
    };
} | {
    type: 'let';
    args: {
        bindings: QueryPlanBinding[];
        expr: QueryPlanNode;
    };
} | {
    type: 'getFirstNonEmpty';
    args: {
        names: string[];
    };
} | {
    type: 'query';
    args: QueryPlanDbQuery;
} | {
    type: 'execute';
    args: QueryPlanDbQuery;
} | {
    type: 'reverse';
    args: QueryPlanNode;
} | {
    type: 'sum';
    args: QueryPlanNode[];
} | {
    type: 'concat';
    args: QueryPlanNode[];
} | {
    type: 'unique';
    args: QueryPlanNode;
} | {
    type: 'required';
    args: QueryPlanNode;
} | {
    type: 'join';
    args: {
        parent: QueryPlanNode;
        children: JoinExpression[];
    };
} | {
    type: 'mapField';
    args: {
        field: string;
        records: QueryPlanNode;
    };
} | {
    type: 'transaction';
    args: QueryPlanNode;
} | {
    type: 'dataMap';
    args: {
        expr: QueryPlanNode;
        structure: ResultNode;
        enums: Record<string, Record<string, string>>;
    };
} | {
    type: 'validate';
    args: {
        expr: QueryPlanNode;
        rules: DataRule[];
    } & ValidationError;
} | {
    type: 'if';
    args: {
        value: QueryPlanNode;
        rule: DataRule;
        then: QueryPlanNode;
        else: QueryPlanNode;
    };
} | {
    type: 'unit';
} | {
    type: 'diff';
    args: {
        from: QueryPlanNode;
        to: QueryPlanNode;
    };
} | {
    type: 'initializeRecord';
    args: {
        expr: QueryPlanNode;
        fields: Record<string, FieldInitializer>;
    };
} | {
    type: 'mapRecord';
    args: {
        expr: QueryPlanNode;
        fields: Record<string, FieldOperation>;
    };
} | {
    type: 'process';
    args: {
        expr: QueryPlanNode;
        operations: InMemoryOps;
    };
};

export declare type RawResponse = {
    columns: string[];
    types: string[];
    rows: unknown[][];
};

export declare type ResultNode = {
    type: 'affectedRows';
} | {
    type: 'object';
    fields: Record<string, ResultNode>;
    serializedName: string | null;
    skipNulls: boolean;
} | {
    type: 'field';
    dbName: string;
    fieldType: FieldType;
};

/**
 * `JSON.stringify` wrapper with custom replacer function that handles nested
 * BigInt and Uint8Array values.
 */
export declare function safeJsonStringify(obj: unknown): string;

/**
 * `provider` property as defined in Prisma Schema (may differ from {@link @prisma/driver-adapter-utils#Provider}).
 */
export declare type SchemaProvider = 'cockroachdb' | 'mongodb' | 'mysql' | 'postgres' | 'postgresql' | 'prisma+postgres' | 'sqlite' | 'sqlserver';

declare type SpanCallback<R> = (span?: Span, context?: Context) => R;

export declare interface TracingHelper {
    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;
}

export declare type TransactionInfo = {
    id: string;
};

export declare class TransactionManager {
    #private;
    private transactions;
    private closedTransactions;
    private readonly driverAdapter;
    private readonly transactionOptions;
    private readonly tracingHelper;
    constructor({ driverAdapter, transactionOptions, tracingHelper, onQuery, provider, }: {
        driverAdapter: SqlDriverAdapter;
        transactionOptions: TransactionOptions;
        tracingHelper: TracingHelper;
        onQuery?: (event: QueryEvent) => void;
        provider?: SchemaProvider;
    });
    startTransaction(options?: TransactionOptions): Promise<TransactionInfo>;
    commitTransaction(transactionId: string): Promise<void>;
    rollbackTransaction(transactionId: string): Promise<void>;
    getTransaction(txInfo: TransactionInfo, operation: string): Promise<Transaction>;
    cancelAllTransactions(): Promise<void>;
}

export declare class TransactionManagerError extends UserFacingError {
    name: string;
    constructor(message: string, meta?: Record<string, unknown>);
}

export declare type TransactionOptions = {
    maxWait?: number;
    timeout?: number;
    isolationLevel?: IsolationLevel;
};

export declare class UserFacingError extends Error {
    name: string;
    code: string;
    meta: Record<string, unknown>;
    constructor(message: string, code: string, meta?: Record<string, unknown>);
    toQueryResponseErrorObject(): {
        error: string;
        user_facing_error: {
            is_panic: boolean;
            message: string;
            meta: Record<string, unknown>;
            error_code: string;
        };
    };
}

export declare type ValidationError = {
    error_identifier: 'RELATION_VIOLATION';
    context: {
        relation: string;
        modelA: string;
        modelB: string;
    };
} | {
    error_identifier: 'MISSING_RELATED_RECORD';
    context: {
        model: string;
        relation: string;
        relationType: string;
        operation: string;
        neededFor?: string;
    };
} | {
    error_identifier: 'MISSING_RECORD';
    context: {
        operation: string;
    };
} | {
    error_identifier: 'INCOMPLETE_CONNECT_INPUT';
    context: {
        expectedRows: number;
    };
} | {
    error_identifier: 'INCOMPLETE_CONNECT_OUTPUT';
    context: {
        expectedRows: number;
        relation: string;
        relationType: string;
    };
} | {
    error_identifier: 'RECORDS_NOT_CONNECTED';
    context: {
        relation: string;
        parent: string;
        child: string;
    };
};

/**
 * The general type of values each node can evaluate to.
 */
declare type Value = unknown;

export { }
