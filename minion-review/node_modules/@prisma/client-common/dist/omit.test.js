"use strict";
var import_vitest = require("vitest");
var import_omit = require("./omit");
(0, import_vitest.describe)("omit", () => {
  (0, import_vitest.it)("should remove specified keys from an object", () => {
    const obj = { a: 1, b: 2, c: 3 };
    const result = (0, import_omit.omit)(obj, ["a", "c"]);
    (0, import_vitest.expect)(result).toEqual({ b: 2 });
    (0, import_vitest.expect)(result).not.toHaveProperty("a");
    (0, import_vitest.expect)(result).not.toHaveProperty("c");
  });
  (0, import_vitest.it)("should return the original object when no keys are provided", () => {
    const obj = { a: 1, b: 2, c: 3 };
    const result = (0, import_omit.omit)(obj, []);
    (0, import_vitest.expect)(result).toEqual(obj);
  });
  (0, import_vitest.it)("should handle when keys to omit do not exist in the object", () => {
    const obj = { a: 1, b: 2 };
    const result = (0, import_omit.omit)(obj, ["c"]);
    (0, import_vitest.expect)(result).toEqual(obj);
  });
  (0, import_vitest.it)("should work with complex object values", () => {
    const obj = {
      a: { nested: true },
      b: [1, 2, 3],
      c: "string",
      d: null
    };
    const result = (0, import_omit.omit)(obj, ["b", "d"]);
    (0, import_vitest.expect)(result).toEqual({
      a: { nested: true },
      c: "string"
    });
  });
  (0, import_vitest.it)("should preserve the reference of non-primitive values", () => {
    const nestedObj = { nested: true };
    const obj = { a: nestedObj, b: 2 };
    const result = (0, import_omit.omit)(obj, ["b"]);
    (0, import_vitest.expect)(result.a).toBe(nestedObj);
  });
  (0, import_vitest.it)("should handle empty objects", () => {
    const obj = {};
    const result = (0, import_omit.omit)(obj, ["a"]);
    (0, import_vitest.expect)(result).toEqual({});
  });
});
