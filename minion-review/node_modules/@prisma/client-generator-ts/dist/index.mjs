var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/.pnpm/universalify@2.0.1/node_modules/universalify/index.js
var require_universalify = __commonJS({
  "../../node_modules/.pnpm/universalify@2.0.1/node_modules/universalify/index.js"(exports) {
    "use strict";
    exports.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function") fn.apply(this, args);
        else {
          return new Promise((resolve, reject) => {
            args.push((err, res) => err != null ? reject(err) : resolve(res));
            fn.apply(this, args);
          });
        }
      }, "name", { value: fn.name });
    };
    exports.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function") return fn.apply(this, args);
        else {
          args.pop();
          fn.apply(this, args).then((r) => cb(null, r), cb);
        }
      }, "name", { value: fn.name });
    };
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js"(exports, module) {
    "use strict";
    var constants = __require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module.exports = patch;
    function patch(fs3) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs3);
      }
      if (!fs3.lutimes) {
        patchLutimes(fs3);
      }
      fs3.chown = chownFix(fs3.chown);
      fs3.fchown = chownFix(fs3.fchown);
      fs3.lchown = chownFix(fs3.lchown);
      fs3.chmod = chmodFix(fs3.chmod);
      fs3.fchmod = chmodFix(fs3.fchmod);
      fs3.lchmod = chmodFix(fs3.lchmod);
      fs3.chownSync = chownFixSync(fs3.chownSync);
      fs3.fchownSync = chownFixSync(fs3.fchownSync);
      fs3.lchownSync = chownFixSync(fs3.lchownSync);
      fs3.chmodSync = chmodFixSync(fs3.chmodSync);
      fs3.fchmodSync = chmodFixSync(fs3.fchmodSync);
      fs3.lchmodSync = chmodFixSync(fs3.lchmodSync);
      fs3.stat = statFix(fs3.stat);
      fs3.fstat = statFix(fs3.fstat);
      fs3.lstat = statFix(fs3.lstat);
      fs3.statSync = statFixSync(fs3.statSync);
      fs3.fstatSync = statFixSync(fs3.fstatSync);
      fs3.lstatSync = statFixSync(fs3.lstatSync);
      if (fs3.chmod && !fs3.lchmod) {
        fs3.lchmod = function(path6, mode, cb) {
          if (cb) process.nextTick(cb);
        };
        fs3.lchmodSync = function() {
        };
      }
      if (fs3.chown && !fs3.lchown) {
        fs3.lchown = function(path6, uid, gid, cb) {
          if (cb) process.nextTick(cb);
        };
        fs3.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs3.rename = typeof fs3.rename !== "function" ? fs3.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs3.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb) cb(er);
            });
          }
          if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs3.rename);
      }
      fs3.read = typeof fs3.read !== "function" ? fs3.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs3, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs3, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs3.read);
      fs3.readSync = typeof fs3.readSync !== "function" ? fs3.readSync : /* @__PURE__ */ function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs3, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs3.readSync);
      function patchLchmod(fs4) {
        fs4.lchmod = function(path6, mode, callback) {
          fs4.open(
            path6,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback) callback(err);
                return;
              }
              fs4.fchmod(fd, mode, function(err2) {
                fs4.close(fd, function(err22) {
                  if (callback) callback(err2 || err22);
                });
              });
            }
          );
        };
        fs4.lchmodSync = function(path6, mode) {
          var fd = fs4.openSync(path6, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs4.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs4.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs4.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs4) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs4.futimes) {
          fs4.lutimes = function(path6, at, mt, cb) {
            fs4.open(path6, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb) cb(er);
                return;
              }
              fs4.futimes(fd, at, mt, function(er2) {
                fs4.close(fd, function(er22) {
                  if (cb) cb(er2 || er22);
                });
              });
            });
          };
          fs4.lutimesSync = function(path6, at, mt) {
            var fd = fs4.openSync(path6, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs4.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs4.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs4.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs4.futimes) {
          fs4.lutimes = function(_a, _b, _c, cb) {
            if (cb) process.nextTick(cb);
          };
          fs4.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig) return orig;
        return function(target, mode, cb) {
          return orig.call(fs3, target, mode, function(er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig) return orig;
        return function(target, mode) {
          try {
            return orig.call(fs3, target, mode);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig) return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs3, target, uid, gid, function(er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig) return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs3, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig) return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0) stats.uid += 4294967296;
              if (stats.gid < 0) stats.gid += 4294967296;
            }
            if (cb) cb.apply(this, arguments);
          }
          return options ? orig.call(fs3, target, options, callback) : orig.call(fs3, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig) return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs3, target, options) : orig.call(fs3, target);
          if (stats) {
            if (stats.uid < 0) stats.uid += 4294967296;
            if (stats.gid < 0) stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js"(exports, module) {
    "use strict";
    var Stream = __require("stream").Stream;
    module.exports = legacy;
    function legacy(fs3) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path6, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path6, options);
        Stream.call(this);
        var self = this;
        this.path = path6;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding) this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }
        fs3.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self.emit("error", err);
            self.readable = false;
            return;
          }
          self.fd = fd;
          self.emit("open", fd);
          self._read();
        });
      }
      function WriteStream(path6, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path6, options);
        Stream.call(this);
        this.path = path6;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs3.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js"(exports, module) {
    "use strict";
    module.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js"(exports, module) {
    "use strict";
    var fs3 = __require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = __require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug3 = noop;
    if (util.debuglog)
      debug3 = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug3 = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs3[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs3, queue);
      fs3.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs3, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs3.close);
      fs3.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs3, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs3.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug3(fs3[gracefulQueue]);
          __require("assert").equal(fs3[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs3[gracefulQueue]);
    }
    module.exports = patch(clone(fs3));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs3.__patched) {
      module.exports = patch(fs3);
      fs3.__patched = true;
    }
    function patch(fs4) {
      polyfills(fs4);
      fs4.gracefulify = patch;
      fs4.createReadStream = createReadStream;
      fs4.createWriteStream = createWriteStream;
      var fs$readFile = fs4.readFile;
      fs4.readFile = readFile;
      function readFile(path6, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path6, options, cb);
        function go$readFile(path7, options2, cb2, startTime) {
          return fs$readFile(path7, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path7, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs4.writeFile;
      fs4.writeFile = writeFile;
      function writeFile(path6, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path6, data, options, cb);
        function go$writeFile(path7, data2, options2, cb2, startTime) {
          return fs$writeFile(path7, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path7, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs4.appendFile;
      if (fs$appendFile)
        fs4.appendFile = appendFile;
      function appendFile(path6, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path6, data, options, cb);
        function go$appendFile(path7, data2, options2, cb2, startTime) {
          return fs$appendFile(path7, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path7, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs4.copyFile;
      if (fs$copyFile)
        fs4.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs4.readdir;
      fs4.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path6, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path7, options2, cb2, startTime) {
          return fs$readdir(path7, fs$readdirCallback(
            path7,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path7, options2, cb2, startTime) {
          return fs$readdir(path7, options2, fs$readdirCallback(
            path7,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path6, options, cb);
        function fs$readdirCallback(path7, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path7, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs4);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs4.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs4.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs4, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs4, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs4, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs4, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path6, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path6, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path6, options) {
        return new fs4.ReadStream(path6, options);
      }
      function createWriteStream(path6, options) {
        return new fs4.WriteStream(path6, options);
      }
      var fs$open = fs4.open;
      fs4.open = open;
      function open(path6, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path6, flags, mode, cb);
        function go$open(path7, flags2, mode2, cb2, startTime) {
          return fs$open(path7, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path7, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs4;
    }
    function enqueue(elem) {
      debug3("ENQUEUE", elem[0].name, elem[1]);
      fs3[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs3[gracefulQueue].length; ++i) {
        if (fs3[gracefulQueue][i].length > 2) {
          fs3[gracefulQueue][i][3] = now;
          fs3[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs3[gracefulQueue].length === 0)
        return;
      var elem = fs3[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug3("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug3("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug3("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs3[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/fs/index.js"(exports) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs3 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "cp",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "glob",
      "lchmod",
      "lchown",
      "lutimes",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "statfs",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs3[key] === "function";
    });
    Object.assign(exports, fs3);
    api.forEach((method3) => {
      exports[method3] = u(fs3[method3]);
    });
    exports.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs3.exists(filename, callback);
      }
      return new Promise((resolve) => {
        return fs3.exists(filename, resolve);
      });
    };
    exports.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs3.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve, reject) => {
        fs3.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err) return reject(err);
          resolve({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs3.write(fd, buffer, ...args);
      }
      return new Promise((resolve, reject) => {
        fs3.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err) return reject(err);
          resolve({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    exports.readv = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs3.readv(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs3.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
          if (err) return reject(err);
          resolve({ bytesRead, buffers: buffers2 });
        });
      });
    };
    exports.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs3.writev(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs3.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err) return reject(err);
          resolve({ bytesWritten, buffers: buffers2 });
        });
      });
    };
    if (typeof fs3.realpath.native === "function") {
      exports.realpath.native = u(fs3.realpath.native);
    } else {
      process.emitWarning(
        "fs.realpath.native is not a function. Is fs being monkey-patched?",
        "Warning",
        "fs-extra-WARN0003"
      );
    }
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/mkdirs/utils.js"(exports, module) {
    "use strict";
    var path6 = __require("path");
    module.exports.checkPath = function checkPath(pth) {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path6.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports, module) {
    "use strict";
    var fs3 = require_fs();
    var { checkPath } = require_utils();
    var getMode = (options) => {
      const defaults = { mode: 511 };
      if (typeof options === "number") return options;
      return { ...defaults, ...options }.mode;
    };
    module.exports.makeDir = async (dir, options) => {
      checkPath(dir);
      return fs3.mkdir(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
    module.exports.makeDirSync = (dir, options) => {
      checkPath(dir);
      return fs3.mkdirSync(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/mkdirs/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir();
    var makeDir = u(_makeDir);
    module.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/path-exists/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs3 = require_fs();
    function pathExists(path6) {
      return fs3.access(path6).then(() => true).catch(() => false);
    }
    module.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs3.existsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/util/utimes.js"(exports, module) {
    "use strict";
    var fs3 = require_fs();
    var u = require_universalify().fromPromise;
    async function utimesMillis(path6, atime, mtime) {
      const fd = await fs3.open(path6, "r+");
      let closeErr = null;
      try {
        await fs3.futimes(fd, atime, mtime);
      } finally {
        try {
          await fs3.close(fd);
        } catch (e) {
          closeErr = e;
        }
      }
      if (closeErr) {
        throw closeErr;
      }
    }
    function utimesMillisSync(path6, atime, mtime) {
      const fd = fs3.openSync(path6, "r+");
      fs3.futimesSync(fd, atime, mtime);
      return fs3.closeSync(fd);
    }
    module.exports = {
      utimesMillis: u(utimesMillis),
      utimesMillisSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/util/stat.js"(exports, module) {
    "use strict";
    var fs3 = require_fs();
    var path6 = __require("path");
    var u = require_universalify().fromPromise;
    function getStats(src, dest, opts) {
      const statFunc = opts.dereference ? (file4) => fs3.stat(file4, { bigint: true }) : (file4) => fs3.lstat(file4, { bigint: true });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT") return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest, opts) {
      let destStat;
      const statFunc = opts.dereference ? (file4) => fs3.statSync(file4, { bigint: true }) : (file4) => fs3.lstatSync(file4, { bigint: true });
      const srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT") return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    async function checkPaths(src, dest, funcName, opts) {
      const { srcStat, destStat } = await getStats(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path6.basename(src);
          const destBaseName = path6.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkPathsSync(src, dest, funcName, opts) {
      const { srcStat, destStat } = getStatsSync(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path6.basename(src);
          const destBaseName = path6.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    async function checkParentPaths(src, srcStat, dest, funcName) {
      const srcParent = path6.resolve(path6.dirname(src));
      const destParent = path6.resolve(path6.dirname(dest));
      if (destParent === srcParent || destParent === path6.parse(destParent).root) return;
      let destStat;
      try {
        destStat = await fs3.stat(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT") return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPaths(src, srcStat, destParent, funcName);
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path6.resolve(path6.dirname(src));
      const destParent = path6.resolve(path6.dirname(dest));
      if (destParent === srcParent || destParent === path6.parse(destParent).root) return;
      let destStat;
      try {
        destStat = fs3.statSync(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT") return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path6.resolve(src).split(path6.sep).filter((i) => i);
      const destArr = path6.resolve(dest).split(path6.sep).filter((i) => i);
      return srcArr.every((cur, i) => destArr[i] === cur);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module.exports = {
      // checkPaths
      checkPaths: u(checkPaths),
      checkPathsSync,
      // checkParent
      checkParentPaths: u(checkParentPaths),
      checkParentPathsSync,
      // Misc
      isSrcSubdir,
      areIdentical
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/copy/copy.js"(exports, module) {
    "use strict";
    var fs3 = require_fs();
    var path6 = __require("path");
    var { mkdirs } = require_mkdirs();
    var { pathExists } = require_path_exists();
    var { utimesMillis } = require_utimes();
    var stat = require_stat();
    async function copy(src, dest, opts = {}) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0001"
        );
      }
      const { srcStat, destStat } = await stat.checkPaths(src, dest, "copy", opts);
      await stat.checkParentPaths(src, srcStat, dest, "copy");
      const include = await runFilter(src, dest, opts);
      if (!include) return;
      const destParent = path6.dirname(dest);
      const dirExists = await pathExists(destParent);
      if (!dirExists) {
        await mkdirs(destParent);
      }
      await getStatsAndPerformCopy(destStat, src, dest, opts);
    }
    async function runFilter(src, dest, opts) {
      if (!opts.filter) return true;
      return opts.filter(src, dest);
    }
    async function getStatsAndPerformCopy(destStat, src, dest, opts) {
      const statFn = opts.dereference ? fs3.stat : fs3.lstat;
      const srcStat = await statFn(src);
      if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);
      if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);
      if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
      if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);
      if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    async function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat) return copyFile(srcStat, src, dest, opts);
      if (opts.overwrite) {
        await fs3.unlink(dest);
        return copyFile(srcStat, src, dest, opts);
      }
      if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    async function copyFile(srcStat, src, dest, opts) {
      await fs3.copyFile(src, dest);
      if (opts.preserveTimestamps) {
        if (fileIsNotWritable(srcStat.mode)) {
          await makeFileWritable(dest, srcStat.mode);
        }
        const updatedSrcStat = await fs3.stat(src);
        await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
      }
      return fs3.chmod(dest, srcStat.mode);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return fs3.chmod(dest, srcMode | 128);
    }
    async function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat) {
        await fs3.mkdir(dest);
      }
      const promises = [];
      for await (const item of await fs3.opendir(src)) {
        const srcItem = path6.join(src, item.name);
        const destItem = path6.join(dest, item.name);
        promises.push(
          runFilter(srcItem, destItem, opts).then((include) => {
            if (include) {
              return stat.checkPaths(srcItem, destItem, "copy", opts).then(({ destStat: destStat2 }) => {
                return getStatsAndPerformCopy(destStat2, srcItem, destItem, opts);
              });
            }
          })
        );
      }
      await Promise.all(promises);
      if (!destStat) {
        await fs3.chmod(dest, srcStat.mode);
      }
    }
    async function onLink(destStat, src, dest, opts) {
      let resolvedSrc = await fs3.readlink(src);
      if (opts.dereference) {
        resolvedSrc = path6.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs3.symlink(resolvedSrc, dest);
      }
      let resolvedDest = null;
      try {
        resolvedDest = await fs3.readlink(dest);
      } catch (e) {
        if (e.code === "EINVAL" || e.code === "UNKNOWN") return fs3.symlink(resolvedSrc, dest);
        throw e;
      }
      if (opts.dereference) {
        resolvedDest = path6.resolve(process.cwd(), resolvedDest);
      }
      if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      await fs3.unlink(dest);
      return fs3.symlink(resolvedSrc, dest);
    }
    module.exports = copy;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/copy/copy-sync.js"(exports, module) {
    "use strict";
    var fs3 = require_graceful_fs();
    var path6 = __require("path");
    var mkdirsSync = require_mkdirs().mkdirsSync;
    var utimesMillisSync = require_utimes().utimesMillisSync;
    var stat = require_stat();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0002"
        );
      }
      const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy", opts);
      stat.checkParentPathsSync(src, srcStat, dest, "copy");
      if (opts.filter && !opts.filter(src, dest)) return;
      const destParent = path6.dirname(dest);
      if (!fs3.existsSync(destParent)) mkdirsSync(destParent);
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs3.statSync : fs3.lstatSync;
      const srcStat = statSync(src);
      if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
      else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);
      else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat) return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs3.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      fs3.copyFileSync(src, dest);
      if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs3.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs3.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs3.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      const dir = fs3.opendirSync(src);
      try {
        let dirent;
        while ((dirent = dir.readSync()) !== null) {
          copyDirItem(dirent.name, src, dest, opts);
        }
      } finally {
        dir.closeSync();
      }
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path6.join(src, item);
      const destItem = path6.join(dest, item);
      if (opts.filter && !opts.filter(srcItem, destItem)) return;
      const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy", opts);
      return getStats(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs3.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path6.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs3.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs3.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN") return fs3.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path6.resolve(process.cwd(), resolvedDest);
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs3.unlinkSync(dest);
      return fs3.symlinkSync(resolvedSrc, dest);
    }
    module.exports = copySync;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/copy/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    module.exports = {
      copy: u(require_copy()),
      copySync: require_copy_sync()
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/remove/index.js"(exports, module) {
    "use strict";
    var fs3 = require_graceful_fs();
    var u = require_universalify().fromCallback;
    function remove(path6, callback) {
      fs3.rm(path6, { recursive: true, force: true }, callback);
    }
    function removeSync(path6) {
      fs3.rmSync(path6, { recursive: true, force: true });
    }
    module.exports = {
      remove: u(remove),
      removeSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/empty/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs3 = require_fs();
    var path6 = __require("path");
    var mkdir = require_mkdirs();
    var remove = require_remove();
    var emptyDir = u(async function emptyDir2(dir) {
      let items;
      try {
        items = await fs3.readdir(dir);
      } catch {
        return mkdir.mkdirs(dir);
      }
      return Promise.all(items.map((item) => remove.remove(path6.join(dir, item))));
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs3.readdirSync(dir);
      } catch {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path6.join(dir, item);
        remove.removeSync(item);
      });
    }
    module.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/file.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path6 = __require("path");
    var fs3 = require_fs();
    var mkdir = require_mkdirs();
    async function createFile(file4) {
      let stats;
      try {
        stats = await fs3.stat(file4);
      } catch {
      }
      if (stats && stats.isFile()) return;
      const dir = path6.dirname(file4);
      let dirStats = null;
      try {
        dirStats = await fs3.stat(dir);
      } catch (err) {
        if (err.code === "ENOENT") {
          await mkdir.mkdirs(dir);
          await fs3.writeFile(file4, "");
          return;
        } else {
          throw err;
        }
      }
      if (dirStats.isDirectory()) {
        await fs3.writeFile(file4, "");
      } else {
        await fs3.readdir(dir);
      }
    }
    function createFileSync(file4) {
      let stats;
      try {
        stats = fs3.statSync(file4);
      } catch {
      }
      if (stats && stats.isFile()) return;
      const dir = path6.dirname(file4);
      try {
        if (!fs3.statSync(dir).isDirectory()) {
          fs3.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT") mkdir.mkdirsSync(dir);
        else throw err;
      }
      fs3.writeFileSync(file4, "");
    }
    module.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/link.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path6 = __require("path");
    var fs3 = require_fs();
    var mkdir = require_mkdirs();
    var { pathExists } = require_path_exists();
    var { areIdentical } = require_stat();
    async function createLink(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = await fs3.lstat(dstpath);
      } catch {
      }
      let srcStat;
      try {
        srcStat = await fs3.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      if (dstStat && areIdentical(srcStat, dstStat)) return;
      const dir = path6.dirname(dstpath);
      const dirExists = await pathExists(dir);
      if (!dirExists) {
        await mkdir.mkdirs(dir);
      }
      await fs3.link(srcpath, dstpath);
    }
    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs3.lstatSync(dstpath);
      } catch {
      }
      try {
        const srcStat = fs3.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat)) return;
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path6.dirname(dstpath);
      const dirExists = fs3.existsSync(dir);
      if (dirExists) return fs3.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs3.linkSync(srcpath, dstpath);
    }
    module.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports, module) {
    "use strict";
    var path6 = __require("path");
    var fs3 = require_fs();
    var { pathExists } = require_path_exists();
    var u = require_universalify().fromPromise;
    async function symlinkPaths(srcpath, dstpath) {
      if (path6.isAbsolute(srcpath)) {
        try {
          await fs3.lstat(srcpath);
        } catch (err) {
          err.message = err.message.replace("lstat", "ensureSymlink");
          throw err;
        }
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      const dstdir = path6.dirname(dstpath);
      const relativeToDst = path6.join(dstdir, srcpath);
      const exists = await pathExists(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      }
      try {
        await fs3.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        throw err;
      }
      return {
        toCwd: srcpath,
        toDst: path6.relative(dstdir, srcpath)
      };
    }
    function symlinkPathsSync(srcpath, dstpath) {
      if (path6.isAbsolute(srcpath)) {
        const exists2 = fs3.existsSync(srcpath);
        if (!exists2) throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      const dstdir = path6.dirname(dstpath);
      const relativeToDst = path6.join(dstdir, srcpath);
      const exists = fs3.existsSync(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      }
      const srcExists = fs3.existsSync(srcpath);
      if (!srcExists) throw new Error("relative srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: path6.relative(dstdir, srcpath)
      };
    }
    module.exports = {
      symlinkPaths: u(symlinkPaths),
      symlinkPathsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/symlink-type.js"(exports, module) {
    "use strict";
    var fs3 = require_fs();
    var u = require_universalify().fromPromise;
    async function symlinkType(srcpath, type) {
      if (type) return type;
      let stats;
      try {
        stats = await fs3.lstat(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    function symlinkTypeSync(srcpath, type) {
      if (type) return type;
      let stats;
      try {
        stats = fs3.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module.exports = {
      symlinkType: u(symlinkType),
      symlinkTypeSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/symlink.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path6 = __require("path");
    var fs3 = require_fs();
    var { mkdirs, mkdirsSync } = require_mkdirs();
    var { symlinkPaths, symlinkPathsSync } = require_symlink_paths();
    var { symlinkType, symlinkTypeSync } = require_symlink_type();
    var { pathExists } = require_path_exists();
    var { areIdentical } = require_stat();
    async function createSymlink(srcpath, dstpath, type) {
      let stats;
      try {
        stats = await fs3.lstat(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const [srcStat, dstStat] = await Promise.all([
          fs3.stat(srcpath),
          fs3.stat(dstpath)
        ]);
        if (areIdentical(srcStat, dstStat)) return;
      }
      const relative = await symlinkPaths(srcpath, dstpath);
      srcpath = relative.toDst;
      const toType = await symlinkType(relative.toCwd, type);
      const dir = path6.dirname(dstpath);
      if (!await pathExists(dir)) {
        await mkdirs(dir);
      }
      return fs3.symlink(srcpath, dstpath, toType);
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs3.lstatSync(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const srcStat = fs3.statSync(srcpath);
        const dstStat = fs3.statSync(dstpath);
        if (areIdentical(srcStat, dstStat)) return;
      }
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path6.dirname(dstpath);
      const exists = fs3.existsSync(dir);
      if (exists) return fs3.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs3.symlinkSync(srcpath, dstpath, type);
    }
    module.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/index.js"(exports, module) {
    "use strict";
    var { createFile, createFileSync } = require_file();
    var { createLink, createLinkSync } = require_link();
    var { createSymlink, createSymlinkSync } = require_symlink();
    module.exports = {
      // file
      createFile,
      createFileSync,
      ensureFile: createFile,
      ensureFileSync: createFileSync,
      // link
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      // symlink
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync
    };
  }
});

// ../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/utils.js"(exports, module) {
    "use strict";
    function stringify16(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
      const EOF = finalEOL ? EOL : "";
      const str = JSON.stringify(obj, replacer, spaces);
      return str.replace(/\n/g, EOL) + EOF;
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content)) content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module.exports = { stringify: stringify16, stripBom };
  }
});

// ../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/index.js"(exports, module) {
    "use strict";
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_) {
      _fs = __require("fs");
    }
    var universalify = require_universalify();
    var { stringify: stringify16, stripBom } = require_utils2();
    async function _readFile(file4, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs3 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = await universalify.fromCallback(fs3.readFile)(file4, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file4}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile = universalify.fromPromise(_readFile);
    function readFileSync(file4, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs3 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      try {
        let content = fs3.readFileSync(file4, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file4}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file4, obj, options = {}) {
      const fs3 = options.fs || _fs;
      const str = stringify16(obj, options);
      await universalify.fromCallback(fs3.writeFile)(file4, str, options);
    }
    var writeFile = universalify.fromPromise(_writeFile);
    function writeFileSync(file4, obj, options = {}) {
      const fs3 = options.fs || _fs;
      const str = stringify16(obj, options);
      return fs3.writeFileSync(file4, str, options);
    }
    var jsonfile = {
      readFile,
      readFileSync,
      writeFile,
      writeFileSync
    };
    module.exports = jsonfile;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/jsonfile.js"(exports, module) {
    "use strict";
    var jsonFile = require_jsonfile();
    module.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/output-file/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs3 = require_fs();
    var path6 = __require("path");
    var mkdir = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    async function outputFile(file4, data, encoding = "utf-8") {
      const dir = path6.dirname(file4);
      if (!await pathExists(dir)) {
        await mkdir.mkdirs(dir);
      }
      return fs3.writeFile(file4, data, encoding);
    }
    function outputFileSync(file4, ...args) {
      const dir = path6.dirname(file4);
      if (!fs3.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
      }
      fs3.writeFileSync(file4, ...args);
    }
    module.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/output-json.js"(exports, module) {
    "use strict";
    var { stringify: stringify16 } = require_utils2();
    var { outputFile } = require_output_file();
    async function outputJson(file4, data, options = {}) {
      const str = stringify16(data, options);
      await outputFile(file4, str, options);
    }
    module.exports = outputJson;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/output-json-sync.js"(exports, module) {
    "use strict";
    var { stringify: stringify16 } = require_utils2();
    var { outputFileSync } = require_output_file();
    function outputJsonSync(file4, data, options) {
      const str = stringify16(data, options);
      outputFileSync(file4, str, options);
    }
    module.exports = outputJsonSync;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module.exports = jsonFile;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/move/move.js"(exports, module) {
    "use strict";
    var fs3 = require_fs();
    var path6 = __require("path");
    var { copy } = require_copy2();
    var { remove } = require_remove();
    var { mkdirp } = require_mkdirs();
    var { pathExists } = require_path_exists();
    var stat = require_stat();
    async function move(src, dest, opts = {}) {
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = await stat.checkPaths(src, dest, "move", opts);
      await stat.checkParentPaths(src, srcStat, dest, "move");
      const destParent = path6.dirname(dest);
      const parsedParentPath = path6.parse(destParent);
      if (parsedParentPath.root !== destParent) {
        await mkdirp(destParent);
      }
      return doRename(src, dest, overwrite, isChangingCase);
    }
    async function doRename(src, dest, overwrite, isChangingCase) {
      if (!isChangingCase) {
        if (overwrite) {
          await remove(dest);
        } else if (await pathExists(dest)) {
          throw new Error("dest already exists.");
        }
      }
      try {
        await fs3.rename(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV") {
          throw err;
        }
        await moveAcrossDevice(src, dest, overwrite);
      }
    }
    async function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      await copy(src, dest, opts);
      return remove(src);
    }
    module.exports = move;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/move/move-sync.js"(exports, module) {
    "use strict";
    var fs3 = require_graceful_fs();
    var path6 = __require("path");
    var copySync = require_copy2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync = require_mkdirs().mkdirpSync;
    var stat = require_stat();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts);
      stat.checkParentPathsSync(src, srcStat, dest, "move");
      if (!isParentRoot(dest)) mkdirpSync(path6.dirname(dest));
      return doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      const parent = path6.dirname(dest);
      const parsedPath = path6.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase) return rename(src, dest, overwrite);
      if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
      }
      if (fs3.existsSync(dest)) throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
      try {
        fs3.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV") throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module.exports = moveSync;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/move/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    module.exports = {
      move: u(require_move()),
      moveSync: require_move_sync()
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/index.js"(exports, module) {
    "use strict";
    module.exports = {
      // Export promiseified graceful-fs:
      ...require_fs(),
      // Export extra methods:
      ...require_copy2(),
      ...require_empty(),
      ...require_ensure(),
      ...require_json(),
      ...require_mkdirs(),
      ...require_move2(),
      ...require_output_file(),
      ...require_path_exists(),
      ...require_remove()
    };
  }
});

// src/externalToInternalDmmf.ts
import { capitalize, uncapitalize } from "@prisma/client-common";
import pluralize from "pluralize";
function externalToInternalDmmf(document) {
  return {
    ...document,
    mappings: getMappings(document.mappings, document.datamodel)
  };
}
function getMappings(mappings, datamodel) {
  const modelOperations = mappings.modelOperations.filter((mapping) => {
    const model = datamodel.models.find((m) => m.name === mapping.model);
    if (!model) {
      throw new Error(`Mapping without model ${mapping.model}`);
    }
    return model.fields.some((f) => f.kind !== "object");
  }).map((mapping) => ({
    model: mapping.model,
    plural: pluralize(uncapitalize(mapping.model)),
    // TODO not needed anymore
    findUnique: mapping.findUnique || mapping.findSingle,
    findUniqueOrThrow: mapping.findUniqueOrThrow,
    findFirst: mapping.findFirst,
    findFirstOrThrow: mapping.findFirstOrThrow,
    findMany: mapping.findMany,
    create: mapping.createOne || mapping.createSingle || mapping.create,
    createMany: mapping.createMany,
    createManyAndReturn: mapping.createManyAndReturn,
    delete: mapping.deleteOne || mapping.deleteSingle || mapping.delete,
    update: mapping.updateOne || mapping.updateSingle || mapping.update,
    deleteMany: mapping.deleteMany,
    updateMany: mapping.updateMany,
    updateManyAndReturn: mapping.updateManyAndReturn,
    upsert: mapping.upsertOne || mapping.upsertSingle || mapping.upsert,
    aggregate: mapping.aggregate,
    groupBy: mapping.groupBy,
    findRaw: mapping.findRaw,
    aggregateRaw: mapping.aggregateRaw
  }));
  return {
    modelOperations,
    otherOperations: mappings.otherOperations
  };
}

// src/generateClient.ts
var import_fs_extra = __toESM(require_lib());
import fs2 from "node:fs/promises";
import path5 from "node:path";
import { overwriteFile } from "@prisma/fetch-engine";
import {
  assertNever as assertNever3,
  ClientEngineType as ClientEngineType3,
  getClientEngineType as getClientEngineType4,
  pathToPosix as pathToPosix3,
  setClassName
} from "@prisma/internals";
import { glob } from "fast-glob";

// ../../node_modules/.pnpm/kleur@4.1.5/node_modules/kleur/colors.mjs
var FORCE_COLOR;
var NODE_DISABLE_COLORS;
var NO_COLOR;
var TERM;
var isTTY = true;
if (typeof process !== "undefined") {
  ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
  isTTY = process.stdout && process.stdout.isTTY;
}
var $ = {
  enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY)
};
function init(x, y) {
  let rgx = new RegExp(`\\x1b\\[${y}m`, "g");
  let open = `\x1B[${x}m`, close = `\x1B[${y}m`;
  return function(txt) {
    if (!$.enabled || txt == null) return txt;
    return open + (!!~("" + txt).indexOf(close) ? txt.replace(rgx, close + open) : txt) + close;
  };
}
var reset = init(0, 0);
var bold = init(1, 22);
var dim = init(2, 22);
var italic = init(3, 23);
var underline = init(4, 24);
var inverse = init(7, 27);
var hidden = init(8, 28);
var strikethrough = init(9, 29);
var black = init(30, 39);
var red = init(31, 39);
var green = init(32, 39);
var yellow = init(33, 39);
var blue = init(34, 39);
var magenta = init(35, 39);
var cyan = init(36, 39);
var white = init(37, 39);
var gray = init(90, 39);
var grey = init(90, 39);
var bgBlack = init(40, 49);
var bgRed = init(41, 49);
var bgGreen = init(42, 49);
var bgYellow = init(43, 49);
var bgBlue = init(44, 49);
var bgMagenta = init(45, 49);
var bgCyan = init(46, 49);
var bgWhite = init(47, 49);

// src/generateClient.ts
import { packageUp } from "package-up";

// src/file-extensions.ts
import { capitalize as capitalize2 } from "@prisma/client-common";
var expectedGeneratedFileExtensions = ["ts", "mts", "cts"];
var expectedImportFileExtensions = ["", "ts", "mts", "cts", "js", "mjs", "cjs"];
function validateFileExtension(extension, kind, recommended) {
  if (!recommended.includes(extension) && !process.env.PRISMA_DISABLE_WARNINGS) {
    console.warn(
      `${capitalize2(kind)} file extension ${JSON.stringify(
        extension
      )} is unexpected and may be a mistake. Expected one of: ${recommended.map((ext) => JSON.stringify(ext)).join(", ")}`
    );
  }
  return extension;
}
function parseFileExtensionFromUnknown(extension, kind, recommended) {
  if (typeof extension === "string") {
    return validateFileExtension(extension, kind, recommended);
  }
  throw new Error(`Invalid ${kind} file extension: ${JSON.stringify(extension)}, expected a string`);
}
function parseGeneratedFileExtension(extension) {
  return parseFileExtensionFromUnknown(extension, "generated", expectedGeneratedFileExtensions);
}
function parseImportFileExtension(extension) {
  return parseFileExtensionFromUnknown(extension, "import", expectedImportFileExtensions);
}
function extensionToSuffix(extension) {
  return extension === "" ? "" : `.${extension}`;
}
function generatedFileNameMapper(generatedFileExtension) {
  return (baseName) => baseName + extensionToSuffix(generatedFileExtension);
}
function importFileNameMapper(importFileExtension) {
  return (baseName) => baseName + extensionToSuffix(importFileExtension);
}
function inferImportFileExtension({
  tsconfig,
  generatedFileExtension,
  target
}) {
  if (target === "deno") {
    return generatedFileExtension;
  }
  if (tsconfig) {
    return inferImportFileExtensionFromTsConfig(tsconfig, generatedFileExtension);
  }
  return generatedFileExtension;
}
function inferImportFileExtensionFromTsConfig(tsconfig, generatedFileExtension) {
  if (tsconfig.compilerOptions?.allowImportingTsExtensions || // @ts-expect-error `get-tsconfig` types don't yet include the new option introduced in TypeScript 5.7
  tsconfig.compilerOptions?.rewriteRelativeImportExtensions) {
    return generatedFileExtension;
  }
  const moduleResolution = tsconfig.compilerOptions?.moduleResolution?.toLowerCase();
  const module = tsconfig.compilerOptions?.module?.toLowerCase();
  if (module === "commonjs" || moduleResolution === "bundler") {
    return "";
  }
  return matchingJsExtension(generatedFileExtension);
}
function matchingJsExtension(generatedFileExtension) {
  switch (generatedFileExtension) {
    case "ts":
      return "js";
    case "mts":
      return "mjs";
    case "cts":
      return "cjs";
    default:
      return generatedFileExtension;
  }
}

// src/getDMMF.ts
import { getDMMF as getRawDMMF } from "@prisma/internals";
function getPrismaClientDMMF(dmmf) {
  return externalToInternalDmmf(dmmf);
}
async function getDMMF(options) {
  const dmmf = await getRawDMMF(options);
  return getPrismaClientDMMF(dmmf);
}

// src/TSClient/Enum.ts
import { objectEnumNames, strictEnumNames } from "@prisma/client-common";
import indent from "indent-string";

// src/TSClient/constants.ts
var TAB_SIZE = 2;

// src/TSClient/Enum.ts
var Enum = class {
  constructor(type, useNamespace) {
    this.type = type;
    this.useNamespace = useNamespace;
  }
  isObjectEnum() {
    return this.useNamespace && objectEnumNames.includes(this.type.name);
  }
  isStrictEnum() {
    return this.useNamespace && strictEnumNames.includes(this.type.name);
  }
  toTS() {
    const { type } = this;
    const enumVariants = `{
${indent(type.values.map((v) => `${v}: ${this.getValue(v)}`).join(",\n"), TAB_SIZE)}
} as const`;
    const enumBody = this.isStrictEnum() ? `runtime.makeStrictEnum(${enumVariants})` : enumVariants;
    return `export const ${type.name} = ${enumBody}

export type ${type.name} = (typeof ${type.name})[keyof typeof ${type.name}]
`;
  }
  getValue(value) {
    return this.isObjectEnum() ? value : `'${value}'`;
  }
};

// src/TSClient/Input.ts
import { uniqueBy } from "@prisma/client-common";
import * as ts2 from "@prisma/ts-builders";
import indent2 from "indent-string";

// src/utils.ts
import { capitalize as capitalize3 } from "@prisma/client-common";
import * as DMMF from "@prisma/dmmf";
import { assertNever } from "@prisma/internals";
import * as ts from "@prisma/ts-builders";
function getSelectName(modelName) {
  return `${modelName}Select`;
}
function getSelectCreateManyAndReturnName(modelName) {
  return `${modelName}SelectCreateManyAndReturn`;
}
function getSelectUpdateManyAndReturnName(modelName) {
  return `${modelName}SelectUpdateManyAndReturn`;
}
function getIncludeName(modelName) {
  return `${modelName}Include`;
}
function getIncludeCreateManyAndReturnName(modelName) {
  return `${modelName}IncludeCreateManyAndReturn`;
}
function getIncludeUpdateManyAndReturnName(modelName) {
  return `${modelName}IncludeUpdateManyAndReturn`;
}
function getCreateManyAndReturnOutputType(modelName) {
  return `CreateMany${modelName}AndReturnOutputType`;
}
function getUpdateManyAndReturnOutputType(modelName) {
  return `UpdateMany${modelName}AndReturnOutputType`;
}
function getOmitName(modelName) {
  return `${modelName}Omit`;
}
function getAggregateName(modelName) {
  return `Aggregate${capitalize3(modelName)}`;
}
function getCountOutputTypeName(modelName) {
  return `${capitalize3(modelName)}CountOutputType`;
}
function getGroupByName(modelName) {
  return `${capitalize3(modelName)}GroupByOutputType`;
}
function getAvgAggregateName(modelName) {
  return `${capitalize3(modelName)}AvgAggregateOutputType`;
}
function getSumAggregateName(modelName) {
  return `${capitalize3(modelName)}SumAggregateOutputType`;
}
function getMinAggregateName(modelName) {
  return `${capitalize3(modelName)}MinAggregateOutputType`;
}
function getMaxAggregateName(modelName) {
  return `${capitalize3(modelName)}MaxAggregateOutputType`;
}
function getCountAggregateInputName(modelName) {
  return `${capitalize3(modelName)}CountAggregateInputType`;
}
function getCountAggregateOutputName(modelName) {
  return `${capitalize3(modelName)}CountAggregateOutputType`;
}
function getAggregateInputType(aggregateOutputType) {
  return aggregateOutputType.replace(/OutputType$/, "InputType");
}
function getGroupByArgsName(modelName) {
  return `${modelName}GroupByArgs`;
}
function getGroupByPayloadName(modelName) {
  return `Get${capitalize3(modelName)}GroupByPayload`;
}
function getAggregateArgsName(modelName) {
  return `${capitalize3(modelName)}AggregateArgs`;
}
function getAggregateGetName(modelName) {
  return `Get${capitalize3(modelName)}AggregateType`;
}
function getFieldArgName(field, modelName) {
  if (field.args.length) {
    return getModelFieldArgsName(field, modelName);
  }
  return getModelArgName(field.outputType.type);
}
function getModelFieldArgsName(field, modelName) {
  return `${modelName}$${field.name}Args`;
}
function getModelArgName(modelName, action) {
  if (!action) {
    return `${modelName}DefaultArgs`;
  }
  switch (action) {
    case DMMF.ModelAction.findMany:
      return `${modelName}FindManyArgs`;
    case DMMF.ModelAction.findUnique:
      return `${modelName}FindUniqueArgs`;
    case DMMF.ModelAction.findUniqueOrThrow:
      return `${modelName}FindUniqueOrThrowArgs`;
    case DMMF.ModelAction.findFirst:
      return `${modelName}FindFirstArgs`;
    case DMMF.ModelAction.findFirstOrThrow:
      return `${modelName}FindFirstOrThrowArgs`;
    case DMMF.ModelAction.upsert:
      return `${modelName}UpsertArgs`;
    case DMMF.ModelAction.update:
      return `${modelName}UpdateArgs`;
    case DMMF.ModelAction.updateMany:
      return `${modelName}UpdateManyArgs`;
    case DMMF.ModelAction.updateManyAndReturn:
      return `${modelName}UpdateManyAndReturnArgs`;
    case DMMF.ModelAction.delete:
      return `${modelName}DeleteArgs`;
    case DMMF.ModelAction.create:
      return `${modelName}CreateArgs`;
    case DMMF.ModelAction.createMany:
      return `${modelName}CreateManyArgs`;
    case DMMF.ModelAction.createManyAndReturn:
      return `${modelName}CreateManyAndReturnArgs`;
    case DMMF.ModelAction.deleteMany:
      return `${modelName}DeleteManyArgs`;
    case DMMF.ModelAction.groupBy:
      return getGroupByArgsName(modelName);
    case DMMF.ModelAction.aggregate:
      return getAggregateArgsName(modelName);
    case DMMF.ModelAction.count:
      return `${modelName}CountArgs`;
    case DMMF.ModelAction.findRaw:
      return `${modelName}FindRawArgs`;
    case DMMF.ModelAction.aggregateRaw:
      return `${modelName}AggregateRawArgs`;
    default:
      assertNever(action, `Unknown action: ${action}`);
  }
}
function getPayloadName(modelName, namespace2 = true) {
  if (namespace2) {
    return `Prisma.${getPayloadName(modelName, false)}`;
  }
  return `$${modelName}Payload`;
}
function getFieldRefsTypeName(name) {
  return `${name}FieldRefs`;
}
function getRefAllowedTypeName(type) {
  let typeName = type.type;
  if (type.isList) {
    typeName += "[]";
  }
  return `'${typeName}'`;
}
function appendSkipType(context, type) {
  if (context.isPreviewFeatureOn("strictUndefinedChecks")) {
    return ts.unionType([type, ts.namedType("runtime.Types.Skip")]);
  }
  return type;
}
var extArgsParam = ts.genericParameter("ExtArgs").extends(ts.namedType("runtime.Types.Extensions.InternalArgs")).default(ts.namedType("runtime.Types.Extensions.DefaultArgs"));

// src/utils/common.ts
var GraphQLScalarToJSTypeTable = {
  String: "string",
  Int: "number",
  Float: "number",
  Boolean: "boolean",
  Long: "number",
  DateTime: ["Date", "string"],
  ID: "string",
  UUID: "string",
  Json: "runtime.JsonValue",
  Bytes: "Uint8Array",
  Decimal: ["runtime.Decimal", "runtime.DecimalJsLike", "number", "string"],
  BigInt: ["bigint", "number"]
};
var JSOutputTypeToInputType = {
  JsonValue: "InputJsonValue"
};

// src/TSClient/Input.ts
var InputField = class {
  constructor(field, context, source) {
    this.field = field;
    this.context = context;
    this.source = source;
  }
  toTS() {
    const property13 = buildInputField(this.field, this.context, this.source);
    return ts2.stringify(property13);
  }
};
function buildInputField(field, context, source) {
  const tsType = buildAllFieldTypes(field.inputTypes, context, source);
  const tsProperty = ts2.property(field.name, field.isRequired ? tsType : appendSkipType(context, tsType));
  if (!field.isRequired) {
    tsProperty.optional();
  }
  const docComment9 = ts2.docComment();
  if (field.comment) {
    docComment9.addText(field.comment);
  }
  if (field.deprecation) {
    docComment9.addText(`@deprecated since ${field.deprecation.sinceVersion}: ${field.deprecation.reason}`);
  }
  if (docComment9.lines.length > 0) {
    tsProperty.setDocComment(docComment9);
  }
  return tsProperty;
}
function buildSingleFieldType(t, genericsInfo, source) {
  let type;
  const scalarType = GraphQLScalarToJSTypeTable[t.type];
  if (t.location === "enumTypes" && t.namespace === "model") {
    type = ts2.namedType(`$Enums.${t.type}`);
  } else if (t.type === "Null") {
    return ts2.nullType;
  } else if (Array.isArray(scalarType)) {
    const union = ts2.unionType(scalarType.map(namedInputType));
    if (t.isList) {
      return union.mapVariants((variant) => ts2.array(variant));
    }
    return union;
  } else if (t.namespace === "prisma") {
    type = namedInputType(`Prisma.${t.type}`);
  } else {
    type = namedInputType(scalarType ?? t.type);
  }
  if (genericsInfo.typeRefNeedsGenericModelArg(t)) {
    if (source) {
      type.addGenericArgument(ts2.stringLiteral(source));
    } else {
      type.addGenericArgument(ts2.namedType("$PrismaModel"));
    }
  }
  if (t.isList) {
    return ts2.array(type);
  }
  return type;
}
function namedInputType(typeName) {
  const typeNameParts = typeName.split(".");
  const typeNameWithoutNamespace = typeNameParts[typeNameParts.length - 1];
  const mappedInputTypeName = JSOutputTypeToInputType[typeNameWithoutNamespace] ?? typeNameWithoutNamespace;
  return ts2.namedType(typeNameParts.slice(0, -1).concat(mappedInputTypeName).join("."));
}
function buildAllFieldTypes(inputTypes, context, source) {
  const inputObjectTypes = inputTypes.filter((t) => t.location === "inputObjectTypes" && !t.isList);
  const otherTypes = inputTypes.filter((t) => t.location !== "inputObjectTypes" || t.isList);
  const tsInputObjectTypes = inputObjectTypes.map((type) => buildSingleFieldType(type, context.genericArgsInfo, source));
  const tsOtherTypes = otherTypes.map((type) => buildSingleFieldType(type, context.genericArgsInfo, source));
  if (tsOtherTypes.length === 0) {
    return xorTypes(tsInputObjectTypes);
  }
  if (tsInputObjectTypes.length === 0) {
    return ts2.unionType(tsOtherTypes);
  }
  return ts2.unionType(xorTypes(tsInputObjectTypes)).addVariants(tsOtherTypes);
}
function xorTypes(types) {
  return types.reduce((prev, curr) => ts2.namedType("Prisma.XOR").addGenericArgument(prev).addGenericArgument(curr));
}
var InputType = class {
  constructor(type, context) {
    this.type = type;
    this.context = context;
    this.generatedName = type.name;
  }
  generatedName;
  toTS() {
    const { type } = this;
    const source = type.meta?.source;
    const fields = uniqueBy(type.fields, (f) => f.name);
    const body = `{
${indent2(
      fields.map((arg) => {
        return new InputField(arg, this.context, source).toTS();
      }).join("\n"),
      TAB_SIZE
    )}
}`;
    const needsGeneric = this.context.genericArgsInfo.typeNeedsGenericModelArg(this.type);
    const typeName = needsGeneric ? `${this.type.name}<$PrismaModel = never>` : this.type.name;
    if (type.name.includes("Json") && type.name.includes("Filter")) {
      const innerName = needsGeneric ? `${this.type.name}Base<$PrismaModel>` : `${this.type.name}Base`;
      const baseName = `Required<${innerName}>`;
      return `
export type ${typeName} =
| Prisma.PatchUndefined<
    Prisma.Either<${baseName}, Exclude<keyof ${baseName}, 'path'>>,
    ${baseName}
  >
| Prisma.OptionalFlat<Omit<${baseName}, 'path'>>

export type ${this.type.name}Base${needsGeneric ? "<$PrismaModel = never>" : ""} = ${wrapWithAtLeast(body, type)}`;
    } else {
      return `
export type ${typeName} = ${wrapWithAtLeast(body, type)}`;
    }
  }
};
function wrapWithAtLeast(body, input) {
  if (input.constraints?.fields && input.constraints.fields.length > 0) {
    const fields = input.constraints.fields.map((f) => `"${f}"`).join(" | ");
    return `Prisma.AtLeast<${body}, ${fields}>`;
  }
  return body;
}

// src/dmmf.ts
import { keyBy } from "@prisma/client-common";
var DMMFHelper = class {
  constructor(document) {
    this.document = document;
  }
  _compositeNames;
  _inputTypesByName;
  _typeAndModelMap;
  _mappingsMap;
  _outputTypeMap;
  _rootFieldMap;
  get compositeNames() {
    return this._compositeNames ??= new Set(this.datamodel.types.map((t) => t.name));
  }
  get inputTypesByName() {
    return this._inputTypesByName ??= this.buildInputTypesMap();
  }
  get typeAndModelMap() {
    return this._typeAndModelMap ??= this.buildTypeModelMap();
  }
  get mappingsMap() {
    return this._mappingsMap ??= this.buildMappingsMap();
  }
  get outputTypeMap() {
    return this._outputTypeMap ??= this.buildMergedOutputTypeMap();
  }
  get rootFieldMap() {
    return this._rootFieldMap ??= this.buildRootFieldMap();
  }
  get datamodel() {
    return this.document.datamodel;
  }
  get mappings() {
    return this.document.mappings;
  }
  get schema() {
    return this.document.schema;
  }
  get inputObjectTypes() {
    return this.schema.inputObjectTypes;
  }
  get outputObjectTypes() {
    return this.schema.outputObjectTypes;
  }
  isComposite(modelOrTypeName) {
    return this.compositeNames.has(modelOrTypeName);
  }
  getOtherOperationNames() {
    return [
      Object.values(this.mappings.otherOperations.write),
      Object.values(this.mappings.otherOperations.read)
    ].flat();
  }
  hasEnumInNamespace(enumName, namespace2) {
    return this.schema.enumTypes[namespace2]?.find((schemaEnum) => schemaEnum.name === enumName) !== void 0;
  }
  resolveInputObjectType(ref) {
    return this.inputTypesByName.get(fullyQualifiedName(ref.type, ref.namespace));
  }
  resolveOutputObjectType(ref) {
    if (ref.location !== "outputObjectTypes") {
      return void 0;
    }
    return this.outputObjectTypes[ref.namespace ?? "prisma"].find((outputObject) => outputObject.name === ref.type);
  }
  buildModelMap() {
    return keyBy(this.datamodel.models, "name");
  }
  buildTypeMap() {
    return keyBy(this.datamodel.types, "name");
  }
  buildTypeModelMap() {
    return { ...this.buildTypeMap(), ...this.buildModelMap() };
  }
  buildMappingsMap() {
    return keyBy(this.mappings.modelOperations, "model");
  }
  buildMergedOutputTypeMap() {
    if (!this.schema.outputObjectTypes.prisma) {
      return {
        model: keyBy(this.schema.outputObjectTypes.model, "name"),
        prisma: keyBy([], "name")
      };
    }
    return {
      model: keyBy(this.schema.outputObjectTypes.model, "name"),
      prisma: keyBy(this.schema.outputObjectTypes.prisma, "name")
    };
  }
  buildRootFieldMap() {
    return {
      ...keyBy(this.outputTypeMap.prisma.Query.fields, "name"),
      ...keyBy(this.outputTypeMap.prisma.Mutation.fields, "name")
    };
  }
  buildInputTypesMap() {
    const result = /* @__PURE__ */ new Map();
    for (const type of this.inputObjectTypes.prisma ?? []) {
      result.set(fullyQualifiedName(type.name, "prisma"), type);
    }
    if (!this.inputObjectTypes.model) {
      return result;
    }
    for (const type of this.inputObjectTypes.model) {
      result.set(fullyQualifiedName(type.name, "model"), type);
    }
    return result;
  }
};
function fullyQualifiedName(typeName, namespace2) {
  if (namespace2) {
    return `${namespace2}.${typeName}`;
  }
  return typeName;
}

// src/GenericsArgsInfo.ts
import { Cache } from "@prisma/client-common";
var GenericArgsInfo = class {
  constructor(_dmmf) {
    this._dmmf = _dmmf;
  }
  _cache = new Cache();
  /**
   * Determines if arg types need generic <$PrismaModel> argument added.
   * Essentially, performs breadth-first search for any fieldRefTypes that
   * do not have corresponding `meta.source` defined.
   *
   * @param type
   * @returns
   */
  typeNeedsGenericModelArg(topLevelType) {
    return this._cache.getOrCreate(topLevelType, () => {
      const toVisit = [{ type: topLevelType }];
      const visited = /* @__PURE__ */ new Set();
      let item;
      while (item = toVisit.shift()) {
        const { type: currentType } = item;
        const cached = this._cache.get(currentType);
        if (cached === true) {
          this._cacheResultsForTree(item);
          return true;
        }
        if (cached === false) {
          continue;
        }
        if (visited.has(currentType)) {
          continue;
        }
        if (currentType.meta?.source) {
          this._cache.set(currentType, false);
          continue;
        }
        visited.add(currentType);
        for (const field of currentType.fields) {
          for (const fieldType of field.inputTypes) {
            if (fieldType.location === "fieldRefTypes") {
              this._cacheResultsForTree(item);
              return true;
            }
            const inputObject = this._dmmf.resolveInputObjectType(fieldType);
            if (inputObject) {
              toVisit.push({ type: inputObject, parent: item });
            }
          }
        }
      }
      for (const visitedType of visited) {
        this._cache.set(visitedType, false);
      }
      return false;
    });
  }
  typeRefNeedsGenericModelArg(ref) {
    if (ref.location === "fieldRefTypes") {
      return true;
    }
    const inputType = this._dmmf.resolveInputObjectType(ref);
    if (!inputType) {
      return false;
    }
    return this.typeNeedsGenericModelArg(inputType);
  }
  _cacheResultsForTree(item) {
    let currentItem = item;
    while (currentItem) {
      this._cache.set(currentItem.type, true);
      currentItem = currentItem.parent;
    }
  }
};

// src/TSClient/file-generators/BrowserFile.ts
import { getClientEngineType } from "@prisma/internals";

// src/TSClient/ModelExports.ts
import * as ts3 from "@prisma/ts-builders";
function modelExports(context) {
  return Object.values(context.dmmf.typeAndModelMap).filter((model) => context.dmmf.outputTypeMap.model[model.name]).map((model) => {
    const docLines = model.documentation ?? "";
    const modelLine = `Model ${model.name}
`;
    const docs = `${modelLine}${docLines}`;
    const suffix = "Model";
    const modelTypeExport = ts3.moduleExport(ts3.typeDeclaration(model.name, ts3.namedType(`Prisma.${model.name}${suffix}`))).setDocComment(ts3.docComment(docs));
    return ts3.stringify(modelTypeExport);
  });
}

// src/TSClient/file-generators/BrowserFile.ts
var jsDocHeader = `/*
 * This file should be your main import to use Prisma-related types and utilities in a browser. 
 * Use it to get access to models, enums, and input types.
 * 
 * This file does not contain a \`PrismaClient\` class, nor several other helpers that are intended as server-side only.
 * See \`client.ts\` for the standard, server-side entry point.
 *
 * \u{1F7E2} You can import this file directly.
 */
`;
function createBrowserFile(context, options) {
  const clientEngineType = getClientEngineType(options.generator);
  options.generator.config.engineType = clientEngineType;
  return `${jsDocHeader}
import * as Prisma from '${context.importFileName("./internal/prismaNamespaceBrowser")}'
export { Prisma }
export * as $Enums from '${context.importFileName("./enums")}'
export * from '${context.importFileName("./enums")}';
${modelExports(context).join("\n")}
`;
}

// src/TSClient/file-generators/ClassFile.ts
import crypto from "node:crypto";
import path2 from "node:path";
import { getClientEngineType as getClientEngineType2, pathToPosix } from "@prisma/internals";
import * as ts6 from "@prisma/ts-builders";
import ciInfo from "ci-info";

// src/utils/buildInjectableEdgeEnv.ts
function buildInjectableEdgeEnv(edge, datasources) {
  if (edge === true) {
    return declareInjectableEdgeEnv(datasources);
  }
  return ``;
}
function declareInjectableEdgeEnv(datasources) {
  const injectableEdgeEnv = { parsed: {} };
  const envVarNames = getSelectedEnvVarNames(datasources);
  for (const envVarName of envVarNames) {
    injectableEdgeEnv.parsed[envVarName] = getRuntimeEdgeEnvVar(envVarName);
  }
  const injectableEdgeEnvJson = JSON.stringify(injectableEdgeEnv, null, 2);
  const injectableEdgeEnvCode = injectableEdgeEnvJson.replace(/"/g, "");
  return `
config.injectableEdgeEnv = () => (${injectableEdgeEnvCode})`;
}
function getSelectedEnvVarNames(datasources) {
  return datasources.reduce((acc, datasource) => {
    if (datasource.url.fromEnvVar) {
      return [...acc, datasource.url.fromEnvVar];
    }
    return acc;
  }, []);
}
function getRuntimeEdgeEnvVar(envVarName) {
  const cfwEnv = `typeof globalThis !== 'undefined' && globalThis['${envVarName}']`;
  const nodeOrVercelEnv = `typeof process !== 'undefined' && process.env && process.env.${envVarName}`;
  return `${cfwEnv} || ${nodeOrVercelEnv} || undefined`;
}

// src/utils/buildDebugInitialization.ts
function buildDebugInitialization(edge) {
  if (!edge) {
    return "";
  }
  const debugVar = getRuntimeEdgeEnvVar("DEBUG");
  return `if (${debugVar}) {
  runtime.Debug.enable(${debugVar})
}
`;
}

// src/utils/buildDMMF.ts
import {
  dmmfToRuntimeDataModel,
  pruneRuntimeDataModel
} from "@prisma/client-common";

// src/TSClient/helpers.ts
import { capitalize as capitalize5, uncapitalize as uncapitalize3 } from "@prisma/client-common";
import pluralize2 from "pluralize";

// src/TSClient/jsdoc.ts
import { capitalize as capitalize4, uncapitalize as uncapitalize2 } from "@prisma/client-common";
var Docs = {
  cursor: `{@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}`,
  pagination: `{@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}`,
  aggregations: `{@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}`,
  distinct: `{@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}`,
  sorting: `{@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}`
};
function addLinkToDocs(comment, docs) {
  return `${Docs[docs]}

${comment}`;
}
function getDeprecationString(since, replacement) {
  return `@deprecated since ${since} please use \`${replacement}\``;
}
var undefinedNote = `Note, that providing \`undefined\` is treated as the value not being there.
Read more here: https://pris.ly/d/null-undefined`;
var JSDocFields = {
  take: (singular, plural) => addLinkToDocs(`Take \`\xB1n\` ${plural} from the position of the cursor.`, "pagination"),
  skip: (singular, plural) => addLinkToDocs(`Skip the first \`n\` ${plural}.`, "pagination"),
  _count: (singular, plural) => addLinkToDocs(`Count returned ${plural}`, "aggregations"),
  _avg: () => addLinkToDocs(`Select which fields to average`, "aggregations"),
  _sum: () => addLinkToDocs(`Select which fields to sum`, "aggregations"),
  _min: () => addLinkToDocs(`Select which fields to find the minimum value`, "aggregations"),
  _max: () => addLinkToDocs(`Select which fields to find the maximum value`, "aggregations"),
  count: () => getDeprecationString("2.23.0", "_count"),
  avg: () => getDeprecationString("2.23.0", "_avg"),
  sum: () => getDeprecationString("2.23.0", "_sum"),
  min: () => getDeprecationString("2.23.0", "_min"),
  max: () => getDeprecationString("2.23.0", "_max"),
  distinct: (singular, plural) => addLinkToDocs(`Filter by unique combinations of ${plural}.`, "distinct"),
  orderBy: (singular, plural) => addLinkToDocs(`Determine the order of ${plural} to fetch.`, "sorting")
};
var JSDocs = {
  groupBy: {
    body: (ctx) => `Group by ${ctx.singular}.
${undefinedNote}
@param {${getGroupByArgsName(ctx.model.name)}} args - Group by arguments.
@example
// Group by city, order by createdAt, get count
const result = await prisma.user.groupBy({
  by: ['city', 'createdAt'],
  orderBy: {
    createdAt: true
  },
  _count: {
    _all: true
  },
})
`,
    fields: {}
  },
  create: {
    body: (ctx) => `Create a ${ctx.singular}.
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create a ${ctx.singular}.
@example
// Create one ${ctx.singular}
const ${ctx.singular} = await ${ctx.method}({
  data: {
    // ... data to create a ${ctx.singular}
  }
})
`,
    fields: {
      data: (singular) => `The data needed to create a ${singular}.`
    }
  },
  createMany: {
    body: (ctx) => `Create many ${ctx.plural}.
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create many ${ctx.plural}.
@example
// Create many ${ctx.plural}
const ${uncapitalize2(ctx.mapping.model)} = await ${ctx.method}({
  data: [
    // ... provide data here
  ]
})
    `,
    fields: {
      data: (singular, plural) => `The data used to create many ${plural}.`
    }
  },
  createManyAndReturn: {
    body: (ctx) => {
      const onlySelect = ctx.firstScalar ? `
// Create many ${ctx.plural} and only return the \`${ctx.firstScalar.name}\`
const ${uncapitalize2(ctx.mapping.model)}With${capitalize4(ctx.firstScalar.name)}Only = await ${ctx.method}({
  select: { ${ctx.firstScalar.name}: true },
  data: [
    // ... provide data here
  ]
})` : "";
      return `Create many ${ctx.plural} and returns the data saved in the database.
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create many ${ctx.plural}.
@example
// Create many ${ctx.plural}
const ${uncapitalize2(ctx.mapping.model)} = await ${ctx.method}({
  data: [
    // ... provide data here
  ]
})
${onlySelect}
${undefinedNote}
`;
    },
    fields: {
      data: (singular, plural) => `The data used to create many ${plural}.`
    }
  },
  findUnique: {
    body: (ctx) => `Find zero or one ${ctx.singular} that matches the filter.
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to find a ${ctx.singular}
@example
// Get one ${ctx.singular}
const ${uncapitalize2(ctx.mapping.model)} = await ${ctx.method}({
  where: {
    // ... provide filter here
  }
})`,
    fields: {
      where: (singular) => `Filter, which ${singular} to fetch.`
    }
  },
  findUniqueOrThrow: {
    body: (ctx) => `Find one ${ctx.singular} that matches the filter or throw an error with \`error.code='P2025'\`
if no matches were found.
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to find a ${ctx.singular}
@example
// Get one ${ctx.singular}
const ${uncapitalize2(ctx.mapping.model)} = await ${ctx.method}({
  where: {
    // ... provide filter here
  }
})`,
    fields: {
      where: (singular) => `Filter, which ${singular} to fetch.`
    }
  },
  findFirst: {
    body: (ctx) => `Find the first ${ctx.singular} that matches the filter.
${undefinedNote}
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to find a ${ctx.singular}
@example
// Get one ${ctx.singular}
const ${uncapitalize2(ctx.mapping.model)} = await ${ctx.method}({
  where: {
    // ... provide filter here
  }
})`,
    fields: {
      where: (singular) => `Filter, which ${singular} to fetch.`,
      orderBy: JSDocFields.orderBy,
      cursor: (singular, plural) => addLinkToDocs(`Sets the position for searching for ${plural}.`, "cursor"),
      take: JSDocFields.take,
      skip: JSDocFields.skip,
      distinct: JSDocFields.distinct
    }
  },
  findFirstOrThrow: {
    body: (ctx) => `Find the first ${ctx.singular} that matches the filter or
throw \`PrismaKnownClientError\` with \`P2025\` code if no matches were found.
${undefinedNote}
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to find a ${ctx.singular}
@example
// Get one ${ctx.singular}
const ${uncapitalize2(ctx.mapping.model)} = await ${ctx.method}({
  where: {
    // ... provide filter here
  }
})`,
    fields: {
      where: (singular) => `Filter, which ${singular} to fetch.`,
      orderBy: JSDocFields.orderBy,
      cursor: (singular, plural) => addLinkToDocs(`Sets the position for searching for ${plural}.`, "cursor"),
      take: JSDocFields.take,
      skip: JSDocFields.skip,
      distinct: JSDocFields.distinct
    }
  },
  findMany: {
    body: (ctx) => {
      const onlySelect = ctx.firstScalar ? `
// Only select the \`${ctx.firstScalar.name}\`
const ${uncapitalize2(ctx.mapping.model)}With${capitalize4(ctx.firstScalar.name)}Only = await ${ctx.method}({ select: { ${ctx.firstScalar.name}: true } })` : "";
      return `Find zero or more ${ctx.plural} that matches the filter.
${undefinedNote}
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to filter and select certain fields only.
@example
// Get all ${ctx.plural}
const ${ctx.mapping.plural} = await ${ctx.method}()

// Get first 10 ${ctx.plural}
const ${ctx.mapping.plural} = await ${ctx.method}({ take: 10 })
${onlySelect}
`;
    },
    fields: {
      where: (singular, plural) => `Filter, which ${plural} to fetch.`,
      orderBy: JSDocFields.orderBy,
      skip: JSDocFields.skip,
      cursor: (singular, plural) => addLinkToDocs(`Sets the position for listing ${plural}.`, "cursor"),
      take: JSDocFields.take
    }
  },
  update: {
    body: (ctx) => `Update one ${ctx.singular}.
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to update one ${ctx.singular}.
@example
// Update one ${ctx.singular}
const ${uncapitalize2(ctx.mapping.model)} = await ${ctx.method}({
  where: {
    // ... provide filter here
  },
  data: {
    // ... provide data here
  }
})
`,
    fields: {
      data: (singular) => `The data needed to update a ${singular}.`,
      where: (singular) => `Choose, which ${singular} to update.`
    }
  },
  upsert: {
    body: (ctx) => `Create or update one ${ctx.singular}.
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to update or create a ${ctx.singular}.
@example
// Update or create a ${ctx.singular}
const ${uncapitalize2(ctx.mapping.model)} = await ${ctx.method}({
  create: {
    // ... data to create a ${ctx.singular}
  },
  update: {
    // ... in case it already exists, update
  },
  where: {
    // ... the filter for the ${ctx.singular} we want to update
  }
})`,
    fields: {
      where: (singular) => `The filter to search for the ${singular} to update in case it exists.`,
      create: (singular) => `In case the ${singular} found by the \`where\` argument doesn't exist, create a new ${singular} with this data.`,
      update: (singular) => `In case the ${singular} was found with the provided \`where\` argument, update it with this data.`
    }
  },
  delete: {
    body: (ctx) => `Delete a ${ctx.singular}.
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to delete one ${ctx.singular}.
@example
// Delete one ${ctx.singular}
const ${ctx.singular} = await ${ctx.method}({
  where: {
    // ... filter to delete one ${ctx.singular}
  }
})
`,
    fields: {
      where: (singular) => `Filter which ${singular} to delete.`
    }
  },
  aggregate: {
    body: (ctx) => `Allows you to perform aggregations operations on a ${ctx.singular}.
${undefinedNote}
@param {${getModelArgName(
      ctx.model.name,
      ctx.action
    )}} args - Select which aggregations you would like to apply and on what fields.
@example
// Ordered by age ascending
// Where email contains prisma.io
// Limited to the 10 users
const aggregations = await prisma.user.aggregate({
  _avg: {
    age: true,
  },
  where: {
    email: {
      contains: "prisma.io",
    },
  },
  orderBy: {
    age: "asc",
  },
  take: 10,
})`,
    fields: {
      where: (singular) => `Filter which ${singular} to aggregate.`,
      orderBy: JSDocFields.orderBy,
      cursor: () => addLinkToDocs(`Sets the start position`, "cursor"),
      take: JSDocFields.take,
      skip: JSDocFields.skip,
      _count: JSDocFields._count,
      _avg: JSDocFields._avg,
      _sum: JSDocFields._sum,
      _min: JSDocFields._min,
      _max: JSDocFields._max,
      count: JSDocFields.count,
      avg: JSDocFields.avg,
      sum: JSDocFields.sum,
      min: JSDocFields.min,
      max: JSDocFields.max
    }
  },
  count: {
    body: (ctx) => `Count the number of ${ctx.plural}.
${undefinedNote}
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to filter ${ctx.plural} to count.
@example
// Count the number of ${ctx.plural}
const count = await ${ctx.method}({
  where: {
    // ... the filter for the ${ctx.plural} we want to count
  }
})`,
    fields: {}
  },
  updateMany: {
    body: (ctx) => `Update zero or more ${ctx.plural}.
${undefinedNote}
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to update one or more rows.
@example
// Update many ${ctx.plural}
const ${uncapitalize2(ctx.mapping.model)} = await ${ctx.method}({
  where: {
    // ... provide filter here
  },
  data: {
    // ... provide data here
  }
})
`,
    fields: {
      data: (singular, plural) => `The data used to update ${plural}.`,
      where: (singular, plural) => `Filter which ${plural} to update`,
      limit: (singular, plural) => `Limit how many ${plural} to update.`
    }
  },
  updateManyAndReturn: {
    body: (ctx) => {
      const onlySelect = ctx.firstScalar ? `
// Update zero or more ${ctx.plural} and only return the \`${ctx.firstScalar.name}\`
const ${uncapitalize2(ctx.mapping.model)}With${capitalize4(ctx.firstScalar.name)}Only = await ${ctx.method}({
  select: { ${ctx.firstScalar.name}: true },
  where: {
    // ... provide filter here
  },
  data: [
    // ... provide data here
  ]
})` : "";
      return `Update zero or more ${ctx.plural} and returns the data updated in the database.
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to update many ${ctx.plural}.
@example
// Update many ${ctx.plural}
const ${uncapitalize2(ctx.mapping.model)} = await ${ctx.method}({
  where: {
    // ... provide filter here
  },
  data: [
    // ... provide data here
  ]
})
${onlySelect}
${undefinedNote}
`;
    },
    fields: {
      data: (singular, plural) => `The data used to update ${plural}.`,
      where: (singular, plural) => `Filter which ${plural} to update`,
      limit: (singular, plural) => `Limit how many ${plural} to update.`
    }
  },
  deleteMany: {
    body: (ctx) => `Delete zero or more ${ctx.plural}.
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to filter ${ctx.plural} to delete.
@example
// Delete a few ${ctx.plural}
const { count } = await ${ctx.method}({
  where: {
    // ... provide filter here
  }
})
`,
    fields: {
      where: (singular, plural) => `Filter which ${plural} to delete`,
      limit: (singular, plural) => `Limit how many ${plural} to delete.`
    }
  },
  aggregateRaw: {
    body: (ctx) => `Perform aggregation operations on a ${ctx.singular}.
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Select which aggregations you would like to apply.
@example
const ${uncapitalize2(ctx.mapping.model)} = await ${ctx.method}({
  pipeline: [
    { $match: { status: "registered" } },
    { $group: { _id: "$country", total: { $sum: 1 } } }
  ]
})`,
    fields: {
      pipeline: () => "An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.",
      options: () => "Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}."
    }
  },
  findRaw: {
    body: (ctx) => `Find zero or more ${ctx.plural} that matches the filter.
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Select which filters you would like to apply.
@example
const ${uncapitalize2(ctx.mapping.model)} = await ${ctx.method}({
  filter: { age: { $gt: 25 } }
})`,
    fields: {
      filter: () => "The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.",
      options: () => "Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}."
    }
  }
};

// src/TSClient/helpers.ts
function getMethodJSDocBody(action, mapping, model) {
  const ctx = {
    singular: capitalize5(mapping.model),
    plural: capitalize5(mapping.plural),
    firstScalar: model.fields.find((f) => f.kind === "scalar"),
    method: `prisma.${uncapitalize3(mapping.model)}.${action}`,
    action,
    mapping,
    model
  };
  const jsdoc = JSDocs[action]?.body(ctx);
  return jsdoc ? jsdoc : "";
}
function getMethodJSDoc(action, mapping, model) {
  return wrapComment(getMethodJSDocBody(action, mapping, model));
}
function wrapComment(str) {
  return `/**
${str.split("\n").map((l) => " * " + l).join("\n")}
**/`;
}
function getArgFieldJSDoc(type, action, field) {
  if (!field || !action || !type) return;
  const fieldName = typeof field === "string" ? field : field.name;
  if (JSDocs[action] && JSDocs[action]?.fields[fieldName]) {
    const singular = type.name;
    const plural = pluralize2(type.name);
    const comment = JSDocs[action]?.fields[fieldName](singular, plural);
    return comment;
  }
  return void 0;
}
function escapeJson(str) {
  return str.replace(/\\n/g, "\\\\n").replace(/\\r/g, "\\\\r").replace(/\\t/g, "\\\\t");
}

// src/utils/buildDMMF.ts
function buildRuntimeDataModel(datamodel, runtimeName) {
  const runtimeDataModel = dmmfToRuntimeDataModel(datamodel);
  let prunedDataModel;
  if (runtimeName === "wasm-engine-edge" || runtimeName === "wasm-compiler-edge" || runtimeName === "client") {
    prunedDataModel = pruneRuntimeDataModel(runtimeDataModel);
  } else {
    prunedDataModel = runtimeDataModel;
  }
  const datamodelString = escapeJson(JSON.stringify(prunedDataModel));
  return `
config.runtimeDataModel = JSON.parse(${JSON.stringify(datamodelString)})`;
}

// src/utils/buildInlineDatasources.ts
function buildInlineDatasources(datasources) {
  return datasources.reduce((acc, ds) => {
    return acc[ds.name] = buildInlineDatasource(ds), acc;
  }, {});
}
function buildInlineDatasource(ds) {
  if (ds.url.fromEnvVar) {
    return { url: { fromEnvVar: ds.url.fromEnvVar, value: null } };
  } else {
    return { url: { fromEnvVar: null, value: ds.url.value } };
  }
}

// src/utils/wasm.ts
import fs from "node:fs";
import path from "node:path";
import { capitalize as capitalize6 } from "@prisma/client-common";
import { Debug } from "@prisma/debug";
import { match } from "ts-pattern";
var debug = Debug("prisma:client-generator-ts:wasm");
function usesEdgeWasmRuntime(component, runtimeName) {
  return runtimeName === "wasm-engine-edge" && component === "engine" || runtimeName === "wasm-compiler-edge" && component === "compiler";
}
function buildGetWasmModule({
  component,
  runtimeName,
  runtimeBase,
  activeProvider,
  moduleFormat
}) {
  const capitalizedComponent = capitalize6(component);
  const extension = match(moduleFormat).with("esm", () => "mjs").with("cjs", () => "js").exhaustive();
  const buildNonEdgeLoader = match(runtimeName).with("library", () => component === "engine" && !!process.env.PRISMA_CLIENT_FORCE_WASM).with("client", () => component === "compiler").otherwise(() => false);
  const buildEdgeLoader = usesEdgeWasmRuntime(component, runtimeName);
  let wasmPathBase;
  let wasmBindingsPath;
  let wasmModulePath;
  if (buildEdgeLoader) {
    wasmPathBase = `./query_${component}_bg`;
    wasmBindingsPath = `${wasmPathBase}.js`;
    wasmModulePath = `${wasmPathBase}.wasm`;
  } else {
    wasmPathBase = `${runtimeBase}/query_${component}_bg.${activeProvider}`;
    wasmBindingsPath = `${wasmPathBase}.mjs`;
    wasmModulePath = `${wasmPathBase}.wasm`;
  }
  if (buildNonEdgeLoader) {
    wasmBindingsPath = `${wasmPathBase}.${extension}`;
    wasmModulePath = `${wasmPathBase}.wasm-base64.${extension}`;
    return `
async function decodeBase64AsWasm(wasmBase64: string): Promise<WebAssembly.Module> {
  const { Buffer } = await import('node:buffer')
  const wasmArray = Buffer.from(wasmBase64, 'base64')
  return new WebAssembly.Module(wasmArray)
}

config.${component}Wasm = {
  getRuntime: async () => await import(${JSON.stringify(wasmBindingsPath)}),

  getQuery${capitalizedComponent}WasmModule: async () => {
    const { wasm } = await import(${JSON.stringify(wasmModulePath)})
    return await decodeBase64AsWasm(wasm)
  }
}`;
  }
  if (buildEdgeLoader) {
    return `config.${component}Wasm = {
  getRuntime: async () => await import(${JSON.stringify(wasmBindingsPath)}),

  getQuery${capitalizedComponent}WasmModule: async () => {
    const { default: module } = await import(${JSON.stringify(`${wasmModulePath}?module`)})
    return module
  }
}`;
  }
  return `config.${component}Wasm = undefined`;
}
function readSourceFile(sourceFile) {
  const bundledLocation = path.join(__dirname, sourceFile);
  const sourceLocation = path.join(__dirname, "..", "..", "..", "cli", "build", sourceFile);
  if (fs.existsSync(bundledLocation)) {
    debug("We are in the bundled Prisma CLI");
    return fs.readFileSync(bundledLocation);
  } else if (fs.existsSync(sourceLocation)) {
    debug("We are in a dev/test environment");
    return fs.readFileSync(sourceLocation);
  } else {
    throw new Error(`Could not find ${sourceFile} in ${bundledLocation} or ${sourceLocation}`);
  }
}
function buildWasmFileMap({ activeProvider, runtimeName }) {
  const fileMap = {};
  debug("buildWasmFileMap with", { runtimeName });
  for (const component of ["engine", "compiler"]) {
    if (!usesEdgeWasmRuntime(component, runtimeName)) {
      debug("Skipping component", component, "for runtime", runtimeName);
      continue;
    }
    const fileNameBase = `query_${component}_bg.${activeProvider}`;
    const files = {
      [`query_${component}_bg.wasm`]: `${fileNameBase}.wasm`,
      [`query_${component}_bg.js`]: `${fileNameBase}.mjs`
    };
    for (const [targetFile, sourceFile] of Object.entries(files)) {
      fileMap[targetFile] = readSourceFile(sourceFile);
    }
  }
  return fileMap;
}

// src/TSClient/PrismaClient.ts
import { capitalize as capitalize7, uncapitalize as uncapitalize4 } from "@prisma/client-common";
import * as ts5 from "@prisma/ts-builders";
import indent3 from "indent-string";

// src/utils/runtimeImport.ts
import * as ts4 from "@prisma/ts-builders";
function runtimeImport(name) {
  return name;
}
function runtimeImportedType(name) {
  return ts4.namedType(`runtime.${name}`);
}

// src/TSClient/utils/type-builders.ts
import { NamedType, namedType as namedType5 } from "@prisma/ts-builders";
function omit(type, keyType) {
  return namedType5("Omit").addGenericArgument(type).addGenericArgument(keyType);
}
function promise(resultType) {
  return new NamedType("runtime.Types.Utils.JsPromise").addGenericArgument(resultType);
}
function prismaPromise(resultType) {
  return new NamedType("Prisma.PrismaPromise").addGenericArgument(resultType);
}
function optional(innerType) {
  return new NamedType("runtime.Types.Utils.Optional").addGenericArgument(innerType);
}

// src/TSClient/PrismaClient.ts
function extendsPropertyDefinition() {
  const extendsDefinition = ts5.namedType("runtime.Types.Extensions.ExtendsHook").addGenericArgument(ts5.stringLiteral("extends")).addGenericArgument(ts5.namedType("Prisma.TypeMapCb").addGenericArgument(ts5.namedType("OmitOpts"))).addGenericArgument(ts5.namedType("ExtArgs")).addGenericArgument(
    ts5.namedType("runtime.Types.Utils.Call").addGenericArgument(ts5.namedType("Prisma.TypeMapCb").addGenericArgument(ts5.namedType("OmitOpts"))).addGenericArgument(ts5.objectType().add(ts5.property("extArgs", ts5.namedType("ExtArgs"))))
  );
  return ts5.stringify(ts5.property("$extends", extendsDefinition), { indentLevel: 1 });
}
function batchingTransactionDefinition(context) {
  const method3 = ts5.method("$transaction").setDocComment(
    ts5.docComment`
        Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
        @example
        \`\`\`
        const [george, bob, alice] = await prisma.$transaction([
          prisma.user.create({ data: { name: 'George' } }),
          prisma.user.create({ data: { name: 'Bob' } }),
          prisma.user.create({ data: { name: 'Alice' } }),
        ])
        \`\`\`

        Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
      `
  ).addGenericParameter(ts5.genericParameter("P").extends(ts5.array(prismaPromise(ts5.anyType)))).addParameter(ts5.parameter("arg", ts5.arraySpread(ts5.namedType("P")))).setReturnType(promise(ts5.namedType("runtime.Types.Utils.UnwrapTuple").addGenericArgument(ts5.namedType("P"))));
  if (context.dmmf.hasEnumInNamespace("TransactionIsolationLevel", "prisma")) {
    const options = ts5.objectType().formatInline().add(ts5.property("isolationLevel", ts5.namedType("Prisma.TransactionIsolationLevel")).optional());
    method3.addParameter(ts5.parameter("options", options).optional());
  }
  return ts5.stringify(method3, { indentLevel: 1, newLine: "leading" });
}
function interactiveTransactionDefinition(context) {
  const options = ts5.objectType().formatInline().add(ts5.property("maxWait", ts5.numberType).optional()).add(ts5.property("timeout", ts5.numberType).optional());
  if (context.dmmf.hasEnumInNamespace("TransactionIsolationLevel", "prisma")) {
    const isolationLevel = ts5.property("isolationLevel", ts5.namedType("Prisma.TransactionIsolationLevel")).optional();
    options.add(isolationLevel);
  }
  const returnType = promise(ts5.namedType("R"));
  const callbackType = ts5.functionType().addParameter(
    ts5.parameter("prisma", omit(ts5.namedType("PrismaClient"), ts5.namedType("runtime.ITXClientDenyList")))
  ).setReturnType(returnType);
  const method3 = ts5.method("$transaction").addGenericParameter(ts5.genericParameter("R")).addParameter(ts5.parameter("fn", callbackType)).addParameter(ts5.parameter("options", options).optional()).setReturnType(returnType);
  return ts5.stringify(method3, { indentLevel: 1, newLine: "leading" });
}
function queryRawDefinition(context) {
  if (!context.dmmf.mappings.otherOperations.write.includes("queryRaw")) {
    return "";
  }
  return `
  /**
   * Performs a prepared raw query and returns the \`SELECT\` data.
   * @example
   * \`\`\`
   * const result = await prisma.$queryRaw\`SELECT * FROM User WHERE id = \${1} OR email = \${'user@email.com'};\`
   * \`\`\`
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the \`SELECT\` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * \`\`\`
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * \`\`\`
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;`;
}
function executeRawDefinition(context) {
  if (!context.dmmf.mappings.otherOperations.write.includes("executeRaw")) {
    return "";
  }
  return `
  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * \`\`\`
   * const result = await prisma.$executeRaw\`UPDATE User SET cool = \${true} WHERE email = \${'user@email.com'};\`
   * \`\`\`
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * \`\`\`
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * \`\`\`
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;`;
}
function queryRawTypedDefinition(context) {
  if (!context.isPreviewFeatureOn("typedSql")) {
    return "";
  }
  if (!context.dmmf.mappings.otherOperations.write.includes("queryRaw")) {
    return "";
  }
  const param = ts5.genericParameter("T");
  const method3 = ts5.method("$queryRawTyped").setDocComment(
    ts5.docComment`
        Executes a typed SQL query and returns a typed result
        @example
        \`\`\`
        import { myQuery } from '@prisma/client/sql'

        const result = await prisma.$queryRawTyped(myQuery())
        \`\`\`
      `
  ).addGenericParameter(param).addParameter(
    ts5.parameter(
      "typedSql",
      runtimeImportedType("TypedSql").addGenericArgument(ts5.array(ts5.unknownType)).addGenericArgument(param.toArgument())
    )
  ).setReturnType(prismaPromise(ts5.array(param.toArgument())));
  return ts5.stringify(method3, { indentLevel: 1, newLine: "leading" });
}
function metricDefinition(context) {
  if (!context.isPreviewFeatureOn("metrics")) {
    return "";
  }
  const property13 = ts5.property("$metrics", ts5.namedType(`runtime.${runtimeImport("MetricsClient")}`)).setDocComment(
    ts5.docComment`
        Gives access to the client metrics in json or prometheus format.

        @example
        \`\`\`
        const metrics = await prisma.$metrics.json()
        // or
        const metrics = await prisma.$metrics.prometheus()
        \`\`\`
    `
  ).readonly();
  return ts5.stringify(property13, { indentLevel: 1, newLine: "leading" });
}
function runCommandRawDefinition(context) {
  if (!context.dmmf.mappings.otherOperations.write.includes("runCommandRaw")) {
    return "";
  }
  const method3 = ts5.method("$runCommandRaw").addParameter(ts5.parameter("command", ts5.namedType("Prisma.InputJsonObject"))).setReturnType(prismaPromise(ts5.namedType("Prisma.JsonObject"))).setDocComment(ts5.docComment`
      Executes a raw MongoDB command and returns the result of it.
      @example
      \`\`\`
      const user = await prisma.$runCommandRaw({
        aggregate: 'User',
        pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
        explain: false,
      })
      \`\`\`

      Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
    `);
  return ts5.stringify(method3, { indentLevel: 1, newLine: "leading" });
}
function eventRegistrationMethodDeclaration(runtimeName) {
  if (runtimeName === "binary") {
    return `$on<V extends (LogOpts | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => runtime.Types.Utils.JsPromise<void> : Prisma.LogEvent) => void): PrismaClient;`;
  } else {
    return `$on<V extends LogOpts>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;`;
  }
}
function getPrismaClientClassDocComment({ dmmf }) {
  let example;
  if (dmmf.mappings.modelOperations.length) {
    example = dmmf.mappings.modelOperations[0];
  } else {
    example = {
      model: "User",
      plural: "users"
    };
  }
  return ts5.docComment`
    ## Prisma Client

    Type-safe database client for TypeScript
    @example
    \`\`\`
    const prisma = new PrismaClient()
    // Fetch zero or more ${capitalize7(example.plural)}
    const ${uncapitalize4(example.plural)} = await prisma.${uncapitalize4(example.model)}.findMany()
    \`\`\`

    Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
  `;
}
var PrismaClientClass = class {
  constructor(context, runtimeName) {
    this.context = context;
    this.runtimeName = runtimeName;
  }
  get jsDoc() {
    return ts5.stringify(getPrismaClientClassDocComment(this.context));
  }
  toTS() {
    const { dmmf } = this.context;
    return `export type LogOptions<ClientOptions extends Prisma.PrismaClientOptions> =
  'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never

export interface PrismaClientConstructor {
  ${indent3(this.jsDoc, TAB_SIZE)}
  new <
    Options extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
    LogOpts extends LogOptions<Options> = LogOptions<Options>,
    OmitOpts extends Prisma.PrismaClientOptions['omit'] = Options extends { omit: infer U } ? U : Prisma.PrismaClientOptions['omit'],
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
  >(options?: Prisma.Subset<Options, Prisma.PrismaClientOptions> ): PrismaClient<LogOpts, OmitOpts, ExtArgs>
}

${this.jsDoc}
export interface PrismaClient<
  in LogOpts extends Prisma.LogLevel = never,
  in out OmitOpts extends Prisma.PrismaClientOptions['omit'] = Prisma.PrismaClientOptions['omit'],
  in out ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

  ${eventRegistrationMethodDeclaration(this.runtimeName)}

  /**
   * Connect with the database
   */
  $connect(): runtime.Types.Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): runtime.Types.Utils.JsPromise<void>;

${[
      executeRawDefinition(this.context),
      queryRawDefinition(this.context),
      queryRawTypedDefinition(this.context),
      batchingTransactionDefinition(this.context),
      interactiveTransactionDefinition(this.context),
      runCommandRawDefinition(this.context),
      metricDefinition(this.context),
      this.applyPendingMigrationsDefinition(),
      extendsPropertyDefinition()
    ].filter((d) => d !== null).join("\n").trim()}

    ${indent3(
      dmmf.mappings.modelOperations.filter((m) => m.findMany).map((m) => {
        let methodName = uncapitalize4(m.model);
        if (methodName === "constructor") {
          methodName = '["constructor"]';
        }
        const generics = ["ExtArgs", "{ omit: OmitOpts }"];
        return `/**
 * \`prisma.${methodName}\`: Exposes CRUD operations for the **${m.model}** model.
  * Example usage:
  * \`\`\`ts
  * // Fetch zero or more ${capitalize7(m.plural)}
  * const ${uncapitalize4(m.plural)} = await prisma.${methodName}.findMany()
  * \`\`\`
  */
get ${methodName}(): Prisma.${m.model}Delegate<${generics.join(", ")}>;`;
      }).join("\n\n"),
      2
    )}
}`;
  }
  applyPendingMigrationsDefinition() {
    if (this.runtimeName !== "react-native") {
      return null;
    }
    const method3 = ts5.method("$applyPendingMigrations").setReturnType(promise(ts5.voidType)).setDocComment(
      ts5.docComment`Tries to apply pending migrations one by one. If a migration fails to apply, the function will stop and throw an error. You are responsible for informing the user and possibly blocking the app as we cannot guarantee the state of the database.`
    );
    return ts5.stringify(method3, { indentLevel: 1, newLine: "leading" });
  }
};

// src/TSClient/file-generators/ClassFile.ts
var jsDocHeader2 = `/*
 * WARNING: This is an internal file that is subject to change!
 *
 * \u{1F6D1} Under no circumstances should you import this file directly! \u{1F6D1}
 *
 * Please import the \`PrismaClient\` class from the \`client.ts\` file instead.
 */
`;
function createClassFile(context, options) {
  const imports = [
    ts6.moduleImport(context.runtimeImport).asNamespace("runtime"),
    ts6.moduleImport(context.importFileName(`./prismaNamespace`)).asNamespace("Prisma").typeOnly()
  ];
  const stringifiedImports = imports.map((i) => ts6.stringify(i));
  const prismaClientClass = new PrismaClientClass(context, options.runtimeName);
  return `${jsDocHeader2}
${stringifiedImports.join("\n")}

${clientConfig(context, options)}

${prismaClientClass.toTS()}

export function getPrismaClientClass(dirname: string): PrismaClientConstructor {
  config.dirname = dirname
  return runtime.getPrismaClient(config) as unknown as PrismaClientConstructor
}
`;
}
function clientConfig(context, options) {
  const {
    edge,
    generator,
    outputDir,
    datamodel: inlineSchema,
    runtimeBase,
    runtimeName,
    datasources,
    copyEngine = true,
    target,
    activeProvider,
    moduleFormat
  } = options;
  const clientEngineType = getClientEngineType2(generator);
  generator.config.engineType = clientEngineType;
  const inlineSchemaHash = crypto.createHash("sha256").update(Buffer.from(inlineSchema, "utf8").toString("base64")).digest("hex");
  const datasourceFilePath = datasources[0].sourceFilePath;
  const config = {
    generator,
    relativePath: pathToPosix(path2.relative(outputDir, path2.dirname(datasourceFilePath))),
    clientVersion: options.clientVersion,
    engineVersion: options.engineVersion,
    datasourceNames: datasources.map((d) => d.name),
    activeProvider: options.activeProvider,
    postinstall: options.postinstall,
    ciName: ciInfo.name ?? void 0,
    inlineDatasources: buildInlineDatasources(datasources),
    inlineSchema,
    inlineSchemaHash,
    copyEngine,
    runtimeDataModel: { models: {}, enums: {}, types: {} },
    dirname: ""
  };
  return `
const config: runtime.GetPrismaClientConfig = ${JSON.stringify(config, null, 2)}
${buildRuntimeDataModel(context.dmmf.datamodel, runtimeName)}
${buildGetWasmModule({ component: "engine", runtimeBase, runtimeName, target, activeProvider, moduleFormat })}
${buildGetWasmModule({ component: "compiler", runtimeBase, runtimeName, target, activeProvider, moduleFormat })}
${buildInjectableEdgeEnv(edge, datasources)}
${buildDebugInitialization(edge)}
`;
}

// src/TSClient/file-generators/ClientFile.ts
import path4 from "node:path";
import { ClientEngineType as ClientEngineType2, getClientEngineType as getClientEngineType3 } from "@prisma/internals";
import * as ts7 from "@prisma/ts-builders";

// src/utils/buildNFTAnnotations.ts
import { getNodeAPIName } from "@prisma/get-platform";
import { ClientEngineType, parseAWSNodejsRuntimeEnvVarVersion, pathToPosix as pathToPosix2 } from "@prisma/internals";
import path3 from "path";
function buildNFTAnnotations(noEngine, engineType, binaryTargets, relativeOutdir) {
  if (noEngine === true) return "";
  if (binaryTargets === void 0) {
    return "";
  }
  if (process.env.NETLIFY) {
    const isNodeMajor20OrUp = parseInt(process.versions.node.split(".")[0]) >= 20;
    const awsRuntimeVersion = parseAWSNodejsRuntimeEnvVarVersion();
    const isRuntimeEnvVar20OrUp = awsRuntimeVersion && awsRuntimeVersion >= 20;
    const isRuntimeEnvVar18OrDown = awsRuntimeVersion && awsRuntimeVersion <= 18;
    if ((isNodeMajor20OrUp || isRuntimeEnvVar20OrUp) && !isRuntimeEnvVar18OrDown) {
      binaryTargets = ["rhel-openssl-3.0.x"];
    } else {
      binaryTargets = ["rhel-openssl-1.0.x"];
    }
  }
  const engineAnnotations = binaryTargets.map((binaryTarget) => {
    const engineFilename = getQueryEngineFilename(engineType, binaryTarget);
    return engineFilename ? buildNFTAnnotation(engineFilename, relativeOutdir) : "";
  }).join("\n");
  return `${engineAnnotations}`;
}
function getQueryEngineFilename(engineType, binaryTarget) {
  if (engineType === ClientEngineType.Library) {
    return getNodeAPIName(binaryTarget, "fs");
  }
  if (engineType === ClientEngineType.Binary) {
    return `query-engine-${binaryTarget}`;
  }
  return void 0;
}
function buildNFTAnnotation(fileName, relativeOutdir) {
  const relativeFilePath = path3.join(relativeOutdir, fileName);
  return `
// file annotations for bundling tools to include these files
path.join(__dirname, ${JSON.stringify(pathToPosix2(fileName))})
path.join(process.cwd(), ${JSON.stringify(pathToPosix2(relativeFilePath))})`;
}

// src/TSClient/file-generators/ClientFile.ts
var jsDocHeader3 = `/*
 * This file should be your main import to use Prisma. Through it you get access to all the models, enums, and input types.
 * If you're looking for something you can import in the client-side of your application, please refer to the \`browser.ts\` file instead.
 * 
 * \u{1F7E2} You can import this file directly.
 */
`;
function createClientFile(context, options) {
  const clientEngineType = getClientEngineType3(options.generator);
  options.generator.config.engineType = clientEngineType;
  const imports = [
    ts7.moduleImport(context.runtimeImport).asNamespace("runtime"),
    ts7.moduleImport(context.importFileName("./enums")).asNamespace("$Enums"),
    ts7.moduleImport(context.importFileName("./internal/class")).asNamespace("$Class"),
    ts7.moduleImport(context.importFileName("./internal/prismaNamespace")).asNamespace("Prisma")
  ].map((i) => ts7.stringify(i));
  const exports = [
    ts7.moduleExportFrom(context.importFileName("./enums")).asNamespace("$Enums"),
    ts7.moduleExportFrom(context.importFileName("./enums")),
    ts7.moduleExport(
      ts7.constDeclaration("PrismaClient").setValue(ts7.functionCall("$Class.getPrismaClientClass", [ts7.namedValue("__dirname")]))
    ).setDocComment(getPrismaClientClassDocComment(context)),
    ts7.moduleExport(
      ts7.typeDeclaration(
        "PrismaClient",
        ts7.namedType("$Class.PrismaClient").addGenericArgument(ts7.namedType("LogOpts")).addGenericArgument(ts7.namedType("OmitOpts")).addGenericArgument(ts7.namedType("ExtArgs"))
      ).addGenericParameter(
        ts7.genericParameter("LogOpts").extends(ts7.namedType("Prisma.LogLevel")).default(ts7.neverType)
      ).addGenericParameter(
        ts7.genericParameter("OmitOpts").extends(ts7.namedType("Prisma.PrismaClientOptions").subKey("omit")).default(ts7.namedType("Prisma.PrismaClientOptions").subKey("omit"))
      ).addGenericParameter(
        ts7.genericParameter("ExtArgs").extends(ts7.namedType("runtime.Types.Extensions.InternalArgs")).default(ts7.namedType("runtime.Types.Extensions.DefaultArgs"))
      )
    )
  ].map((e) => ts7.stringify(e));
  const binaryTargets = clientEngineType === ClientEngineType2.Library ? Object.keys(options.binaryPaths.libqueryEngine ?? {}) : Object.keys(options.binaryPaths.queryEngine ?? {});
  const relativeOutdir = path4.relative(process.cwd(), options.outputDir);
  return `${jsDocHeader3}
${buildPreamble(options.edge, options.moduleFormat)}
${imports.join("\n")}

${exports.join("\n")}
export { Prisma }

${buildNFTAnnotations(options.edge || !options.copyEngine, clientEngineType, binaryTargets, relativeOutdir)}

${modelExports(context).join("\n")}
`;
}
function buildPreamble(edge, moduleFormat) {
  if (edge) {
    return `globalThis['__dirname'] = '/'
`;
  }
  let preamble = `import * as process from 'node:process'
import * as path from 'node:path'
`;
  if (moduleFormat === "esm") {
    preamble += `import { fileURLToPath } from 'node:url'
globalThis['__dirname'] = path.dirname(fileURLToPath(import.meta.url))
`;
  }
  return preamble;
}

// src/TSClient/file-generators/CommonInputTypesFile.ts
import * as ts8 from "@prisma/ts-builders";
var jsDocHeader4 = `/*
 * This file exports various common sort, input & filter types that are not directly linked to a particular model.
 *
 * \u{1F7E2} You can import this file directly.
 */
`;
function createCommonInputTypeFiles(context) {
  const imports = [
    ts8.moduleImport(context.runtimeImport).asNamespace("runtime").typeOnly(),
    ts8.moduleImport(context.importFileName(`./enums`)).asNamespace("$Enums"),
    ts8.moduleImport(context.importFileName(`./internal/prismaNamespace`)).asNamespace("Prisma").typeOnly()
  ].map((i) => ts8.stringify(i));
  const genericInputTypes = context.dmmf.inputObjectTypes.prisma?.filter((i) => !i.meta?.grouping)?.map((inputType) => new InputType(inputType, context).toTS()) ?? [];
  return `${jsDocHeader4}
${imports.join("\n")}

${genericInputTypes.join("\n")}

${context.dmmf.inputObjectTypes.model?.map((inputType) => new InputType(inputType, context).toTS()).join("\n") ?? ""}
`;
}

// src/TSClient/file-generators/EnumsFile.ts
import { datamodelEnumToSchemaEnum } from "@prisma/dmmf";
var jsDocHeader5 = `/*
* This file exports all enum related types from the schema.
*
* \u{1F7E2} You can import this file directly.
*/

`;
function createEnumsFile(context) {
  const modelEnums = [];
  for (const datamodelEnum of context.dmmf.datamodel.enums) {
    modelEnums.push(new Enum(datamodelEnumToSchemaEnum(datamodelEnum), false).toTS());
  }
  if (modelEnums.length === 0) {
    return `${jsDocHeader5}

// This file is empty because there are no enums in the schema.
export {}
`;
  }
  return jsDocHeader5 + modelEnums.join("\n\n");
}

// src/TSClient/file-generators/ModelFile.ts
import * as ts15 from "@prisma/ts-builders";

// src/TSClient/Model.ts
import { capitalize as capitalize9 } from "@prisma/client-common";
import * as DMMF2 from "@prisma/dmmf";
import * as ts14 from "@prisma/ts-builders";
import indent5 from "indent-string";
import { klona } from "klona";

// src/TSClient/Args.ts
import * as ts9 from "@prisma/ts-builders";
var ArgsTypeBuilder = class {
  constructor(type, context, action) {
    this.type = type;
    this.context = context;
    this.action = action;
    this.moduleExport = ts9.moduleExport(
      ts9.typeDeclaration(getModelArgName(type.name, action), ts9.objectType()).addGenericParameter(extArgsParam)
    ).setDocComment(ts9.docComment(`${type.name} ${action ?? "without action"}`));
  }
  moduleExport;
  addProperty(prop) {
    this.moduleExport.declaration.type.add(prop);
  }
  addSchemaArgs(args) {
    for (const arg of args) {
      const inputField = buildInputField(arg, this.context);
      const docComment9 = getArgFieldJSDoc(this.type, this.action, arg);
      if (docComment9) {
        inputField.setDocComment(ts9.docComment(docComment9));
      }
      this.addProperty(inputField);
    }
    return this;
  }
  addSelectArg(selectTypeName = getSelectName(this.type.name)) {
    this.addProperty(
      ts9.property(
        "select",
        ts9.unionType([
          ts9.namedType(`Prisma.${selectTypeName}`).addGenericArgument(extArgsParam.toArgument()),
          ts9.nullType
        ])
      ).optional().setDocComment(ts9.docComment(`Select specific fields to fetch from the ${this.type.name}`))
    );
    return this;
  }
  addIncludeArgIfHasRelations(includeTypeName = getIncludeName(this.type.name), type = this.type) {
    const hasRelationField = type.fields.some((f) => f.outputType.location === "outputObjectTypes");
    if (!hasRelationField) {
      return this;
    }
    this.addProperty(
      ts9.property(
        "include",
        ts9.unionType([
          ts9.namedType(`Prisma.${includeTypeName}`).addGenericArgument(extArgsParam.toArgument()),
          ts9.nullType
        ])
      ).optional().setDocComment(ts9.docComment("Choose, which related nodes to fetch as well"))
    );
    return this;
  }
  addOmitArg() {
    this.addProperty(
      ts9.property(
        "omit",
        ts9.unionType([
          ts9.namedType(`Prisma.${getOmitName(this.type.name)}`).addGenericArgument(extArgsParam.toArgument()),
          ts9.nullType
        ])
      ).optional().setDocComment(ts9.docComment(`Omit specific fields from the ${this.type.name}`))
    );
    return this;
  }
  setGeneratedName(name) {
    this.moduleExport.declaration.setName(name);
    return this;
  }
  setComment(comment) {
    this.moduleExport.setDocComment(ts9.docComment(comment));
    return this;
  }
  createExport() {
    return this.moduleExport;
  }
};

// src/TSClient/Count.ts
import { capitalize as capitalize8 } from "@prisma/client-common";
import * as ts11 from "@prisma/ts-builders";
import indent4 from "indent-string";

// src/TSClient/Output.ts
import { hasOwnProperty } from "@prisma/internals";
import * as ts10 from "@prisma/ts-builders";
function buildModelOutputProperty(field, dmmf) {
  let fieldTypeName = hasOwnProperty(GraphQLScalarToJSTypeTable, field.type) ? GraphQLScalarToJSTypeTable[field.type] : field.type;
  if (Array.isArray(fieldTypeName)) {
    fieldTypeName = fieldTypeName[0];
  }
  let fieldType;
  if (field.kind === "object") {
    const payloadType = ts10.namedType(getPayloadName(field.type));
    if (!dmmf.isComposite(field.type)) {
      payloadType.addGenericArgument(ts10.namedType("ExtArgs"));
    }
    fieldType = payloadType;
  } else if (field.kind === "enum") {
    fieldType = ts10.namedType(`$Enums.${fieldTypeName}`);
  } else {
    fieldType = ts10.namedType(fieldTypeName);
  }
  if (field.isList) {
    fieldType = ts10.array(fieldType);
  } else if (!field.isRequired) {
    fieldType = ts10.unionType(fieldType).addVariant(ts10.nullType);
  }
  const property13 = ts10.property(field.name, fieldType);
  if (field.documentation) {
    property13.setDocComment(ts10.docComment(field.documentation));
  }
  return property13;
}
function buildOutputType(type) {
  return ts10.moduleExport(ts10.typeDeclaration(type.name, ts10.objectType().addMultiple(type.fields.map(buildOutputField))));
}
function buildOutputField(field) {
  let fieldType;
  if (field.outputType.location === "enumTypes" && field.outputType.namespace === "model") {
    fieldType = ts10.namedType(enumTypeName(field.outputType));
  } else {
    const typeNames = GraphQLScalarToJSTypeTable[field.outputType.type] ?? field.outputType.type;
    fieldType = Array.isArray(typeNames) ? ts10.namedType(typeNames[0]) : ts10.namedType(typeNames);
  }
  if (field.outputType.isList) {
    fieldType = ts10.array(fieldType);
  } else if (field.isNullable) {
    fieldType = ts10.unionType(fieldType).addVariant(ts10.nullType);
  }
  const property13 = ts10.property(field.name, fieldType);
  if (field.deprecation) {
    property13.setDocComment(
      ts10.docComment(`@deprecated since ${field.deprecation.sinceVersion} because ${field.deprecation.reason}`)
    );
  }
  return property13;
}
function enumTypeName(ref) {
  const name = ref.type;
  const namespace2 = ref.namespace === "model" ? "$Enums" : "Prisma";
  return `${namespace2}.${name}`;
}

// src/TSClient/Count.ts
var Count = class {
  constructor(type, context) {
    this.type = type;
    this.context = context;
  }
  get argsTypes() {
    const argsTypes = [];
    argsTypes.push(
      new ArgsTypeBuilder(this.type, this.context).addSelectArg().addIncludeArgIfHasRelations().createExport()
    );
    for (const field of this.type.fields) {
      if (field.args.length > 0) {
        argsTypes.push(
          new ArgsTypeBuilder(this.type, this.context).addSchemaArgs(field.args).setGeneratedName(getCountArgsType(this.type.name, field.name)).createExport()
        );
      }
    }
    return argsTypes;
  }
  toTS() {
    const { type } = this;
    const { name } = type;
    const outputType = buildOutputType(type);
    return `
/**
 * Count Type ${name}
 */

${ts11.stringify(outputType)}

export type ${getSelectName(
      name
    )}<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
${indent4(
      type.fields.map((field) => {
        const types = ["boolean"];
        if (field.outputType.location === "outputObjectTypes") {
          types.push(getFieldArgName(field, this.type.name));
        }
        if (field.args.length > 0) {
          types.push(getCountArgsType(name, field.name));
        }
        return `${field.name}?: ${types.join(" | ")}`;
      }).join("\n"),
      TAB_SIZE
    )}
}

${this.argsTypes.map((typeExport) => ts11.stringify(typeExport)).join("\n\n")}
`;
  }
};
function getCountArgsType(typeName, fieldName) {
  return `${typeName}Count${capitalize8(fieldName)}Args`;
}

// src/TSClient/ModelFieldRefs.ts
var ModelFieldRefs = class {
  constructor(outputType) {
    this.outputType = outputType;
  }
  toTS() {
    const { name } = this.outputType;
    return `

/**
 * Fields of the ${name} model
 */
export interface ${getFieldRefsTypeName(name)} {
${this.stringifyFields()}
}
    `;
  }
  stringifyFields() {
    const { name } = this.outputType;
    return this.outputType.fields.filter((field) => field.outputType.location !== "outputObjectTypes").map((field) => {
      const fieldOutput = field.outputType;
      const refTypeName = getRefAllowedTypeName(fieldOutput);
      return `  readonly ${field.name}: Prisma.FieldRef<"${name}", ${refTypeName}>`;
    }).join("\n");
  }
};

// src/TSClient/Payload.ts
import { uncapitalize as uncapitalize5 } from "@prisma/client-common";
import * as ts12 from "@prisma/ts-builders";
function buildModelPayload(model, context) {
  const isComposite = context.dmmf.isComposite(model.name);
  const objects = ts12.objectType();
  const scalars = ts12.objectType();
  const composites = ts12.objectType();
  for (const field of model.fields) {
    if (field.kind === "object") {
      if (context.dmmf.isComposite(field.type)) {
        composites.add(buildModelOutputProperty(field, context.dmmf));
      } else {
        objects.add(buildModelOutputProperty(field, context.dmmf));
      }
    } else if (field.kind === "enum" || field.kind === "scalar") {
      scalars.add(buildModelOutputProperty(field, context.dmmf));
    }
  }
  const scalarsType = isComposite ? scalars : ts12.namedType("runtime.Types.Extensions.GetPayloadResult").addGenericArgument(scalars).addGenericArgument(ts12.namedType("ExtArgs").subKey("result").subKey(uncapitalize5(model.name)));
  const payloadTypeDeclaration = ts12.typeDeclaration(
    getPayloadName(model.name, false),
    ts12.objectType().add(ts12.property("name", ts12.stringLiteral(model.name))).add(ts12.property("objects", objects)).add(ts12.property("scalars", scalarsType)).add(ts12.property("composites", composites))
  );
  if (!isComposite) {
    payloadTypeDeclaration.addGenericParameter(extArgsParam);
  }
  return ts12.moduleExport(payloadTypeDeclaration);
}

// src/TSClient/SelectIncludeOmit.ts
import { uncapitalize as uncapitalize6 } from "@prisma/client-common";
import * as ts13 from "@prisma/ts-builders";
function buildIncludeType({
  modelName,
  typeName = getIncludeName(modelName),
  context,
  fields
}) {
  const type = buildSelectOrIncludeObject(modelName, getIncludeFields(fields, context.dmmf), context);
  return buildExport(typeName, type);
}
function buildOmitType({ modelName, fields, context }) {
  const keysType = ts13.unionType(
    fields.filter(
      (field) => field.outputType.location === "scalar" || field.outputType.location === "enumTypes" || context.dmmf.isComposite(field.outputType.type)
    ).map((field) => ts13.stringLiteral(field.name))
  );
  const omitType = ts13.namedType("runtime.Types.Extensions.GetOmit").addGenericArgument(keysType).addGenericArgument(modelResultExtensionsType(modelName));
  if (context.isPreviewFeatureOn("strictUndefinedChecks")) {
    omitType.addGenericArgument(ts13.namedType("runtime.Types.Skip"));
  }
  return buildExport(getOmitName(modelName), omitType);
}
function buildSelectType({
  modelName,
  typeName = getSelectName(modelName),
  fields,
  context
}) {
  const objectType11 = buildSelectOrIncludeObject(modelName, fields, context);
  const selectType = ts13.namedType("runtime.Types.Extensions.GetSelect").addGenericArgument(objectType11).addGenericArgument(modelResultExtensionsType(modelName));
  return buildExport(typeName, selectType);
}
function modelResultExtensionsType(modelName) {
  return extArgsParam.toArgument().subKey("result").subKey(uncapitalize6(modelName));
}
function buildScalarSelectType({ modelName, fields, context }) {
  const object = buildSelectOrIncludeObject(
    modelName,
    fields.filter((field) => field.outputType.location === "scalar" || field.outputType.location === "enumTypes"),
    context
  );
  return ts13.moduleExport(ts13.typeDeclaration(`${getSelectName(modelName)}Scalar`, object));
}
function buildSelectOrIncludeObject(modelName, fields, context) {
  const objectType11 = ts13.objectType();
  for (const field of fields) {
    const fieldType = ts13.unionType(ts13.booleanType);
    if (field.outputType.location === "outputObjectTypes") {
      const subSelectType = ts13.namedType(`Prisma.${getFieldArgName(field, modelName)}`);
      subSelectType.addGenericArgument(extArgsParam.toArgument());
      fieldType.addVariant(subSelectType);
    }
    objectType11.add(ts13.property(field.name, appendSkipType(context, fieldType)).optional());
  }
  return objectType11;
}
function buildExport(typeName, type) {
  const declaration = ts13.typeDeclaration(typeName, type);
  return ts13.moduleExport(declaration.addGenericParameter(extArgsParam));
}
function getIncludeFields(fields, dmmf) {
  return fields.filter((field) => {
    if (field.outputType.location !== "outputObjectTypes") {
      return false;
    }
    return !dmmf.isComposite(field.outputType.type);
  });
}

// src/TSClient/utils/getModelActions.ts
function getModelActions(dmmf, name) {
  const mapping = dmmf.mappingsMap[name] ?? { model: name, plural: `${name}s` };
  const mappingKeys = Object.keys(mapping).filter(
    (key) => key !== "model" && key !== "plural" && mapping[key]
  );
  if ("aggregate" in mapping) {
    mappingKeys.push("count");
  }
  return mappingKeys;
}

// src/TSClient/Model.ts
var Model = class {
  constructor(model, context) {
    this.model = model;
    this.context = context;
    this.dmmf = context.dmmf;
    this.type = this.context.dmmf.outputTypeMap.model[model.name];
    this.createManyAndReturnType = this.context.dmmf.outputTypeMap.model[getCreateManyAndReturnOutputType(model.name)];
    this.updateManyAndReturnType = this.context.dmmf.outputTypeMap.model[getUpdateManyAndReturnOutputType(model.name)];
    this.mapping = this.context.dmmf.mappings.modelOperations.find((m) => m.model === model.name);
  }
  type;
  createManyAndReturnType;
  updateManyAndReturnType;
  mapping;
  dmmf;
  get argsTypes() {
    const argsTypes = [];
    for (const action of Object.keys(DMMF2.ModelAction)) {
      const fieldName = this.rootFieldNameForAction(action);
      if (!fieldName) {
        continue;
      }
      const field = this.dmmf.rootFieldMap[fieldName];
      if (!field) {
        throw new Error(`Oops this must not happen. Could not find field ${fieldName} on either Query or Mutation`);
      }
      if (action === "updateMany" || action === "deleteMany" || action === "createMany" || action === "findRaw" || action === "aggregateRaw") {
        argsTypes.push(
          new ArgsTypeBuilder(this.type, this.context, action).addSchemaArgs(field.args).createExport()
        );
      } else if (action === "createManyAndReturn") {
        const args = new ArgsTypeBuilder(this.type, this.context, action).addSelectArg(getSelectCreateManyAndReturnName(this.type.name)).addOmitArg().addSchemaArgs(field.args);
        if (this.createManyAndReturnType) {
          args.addIncludeArgIfHasRelations(
            getIncludeCreateManyAndReturnName(this.model.name),
            this.createManyAndReturnType
          );
        }
        argsTypes.push(args.createExport());
      } else if (action === "updateManyAndReturn") {
        const args = new ArgsTypeBuilder(this.type, this.context, action).addSelectArg(getSelectUpdateManyAndReturnName(this.type.name)).addOmitArg().addSchemaArgs(field.args);
        if (this.updateManyAndReturnType) {
          args.addIncludeArgIfHasRelations(
            getIncludeUpdateManyAndReturnName(this.model.name),
            this.updateManyAndReturnType
          );
        }
        argsTypes.push(args.createExport());
      } else if (action !== "groupBy" && action !== "aggregate") {
        argsTypes.push(
          new ArgsTypeBuilder(this.type, this.context, action).addSelectArg().addOmitArg().addIncludeArgIfHasRelations().addSchemaArgs(field.args).createExport()
        );
      }
    }
    for (const field of this.type.fields) {
      if (!field.args.length) {
        continue;
      }
      const fieldOutput = this.dmmf.resolveOutputObjectType(field.outputType);
      if (!fieldOutput) {
        continue;
      }
      argsTypes.push(
        new ArgsTypeBuilder(fieldOutput, this.context).addSelectArg().addOmitArg().addIncludeArgIfHasRelations().addSchemaArgs(field.args).setGeneratedName(getModelFieldArgsName(field, this.model.name)).setComment(`${this.model.name}.${field.name}`).createExport()
      );
    }
    argsTypes.push(
      new ArgsTypeBuilder(this.type, this.context).addSelectArg().addOmitArg().addIncludeArgIfHasRelations().createExport()
    );
    return argsTypes;
  }
  rootFieldNameForAction(action) {
    return this.mapping?.[action];
  }
  getGroupByTypes() {
    const { model, mapping } = this;
    const groupByType = this.dmmf.outputTypeMap.prisma[getGroupByName(model.name)];
    if (!groupByType) {
      throw new Error(`Could not get group by type for model ${model.name}`);
    }
    const groupByRootField = this.dmmf.rootFieldMap[mapping.groupBy];
    if (!groupByRootField) {
      throw new Error(`Could not find groupBy root field for model ${model.name}. Mapping: ${mapping?.groupBy}`);
    }
    const groupByArgsName = getGroupByArgsName(model.name);
    return `


export type ${groupByArgsName}<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
${indent5(
      groupByRootField.args.map((arg) => {
        const updatedArg = { ...arg, comment: getArgFieldJSDoc(this.type, DMMF2.ModelAction.groupBy, arg) };
        return new InputField(updatedArg, this.context).toTS();
      }).concat(
        groupByType.fields.filter((f) => f.outputType.location === "outputObjectTypes").map((f) => {
          if (f.outputType.location === "outputObjectTypes") {
            return `${f.name}?: ${getAggregateInputType(f.outputType.type)}${f.name === "_count" ? " | true" : ""}`;
          }
          return "";
        })
      ).join("\n"),
      TAB_SIZE
    )}
}

${ts14.stringify(buildOutputType(groupByType))}

type ${getGroupByPayloadName(model.name)}<T extends ${groupByArgsName}> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<${groupByType.name}, T['by']> &
      {
        [P in ((keyof T) & (keyof ${groupByType.name}))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], ${groupByType.name}[P]>
          : Prisma.GetScalarType<T[P], ${groupByType.name}[P]>
      }
    >
  >
`;
  }
  getAggregationTypes() {
    const { model, mapping } = this;
    let aggregateType = this.dmmf.outputTypeMap.prisma[getAggregateName(model.name)];
    if (!aggregateType) {
      throw new Error(`Could not get aggregate type "${getAggregateName(model.name)}" for "${model.name}"`);
    }
    aggregateType = klona(aggregateType);
    const aggregateRootField = this.dmmf.rootFieldMap[mapping.aggregate];
    if (!aggregateRootField) {
      throw new Error(`Could not find aggregate root field for model ${model.name}. Mapping: ${mapping?.aggregate}`);
    }
    const aggregateTypes = [aggregateType];
    const avgType = this.dmmf.outputTypeMap.prisma[getAvgAggregateName(model.name)];
    const sumType = this.dmmf.outputTypeMap.prisma[getSumAggregateName(model.name)];
    const minType = this.dmmf.outputTypeMap.prisma[getMinAggregateName(model.name)];
    const maxType = this.dmmf.outputTypeMap.prisma[getMaxAggregateName(model.name)];
    const countType = this.dmmf.outputTypeMap.prisma[getCountAggregateOutputName(model.name)];
    if (avgType) {
      aggregateTypes.push(avgType);
    }
    if (sumType) {
      aggregateTypes.push(sumType);
    }
    if (minType) {
      aggregateTypes.push(minType);
    }
    if (maxType) {
      aggregateTypes.push(maxType);
    }
    if (countType) {
      aggregateTypes.push(countType);
    }
    const aggregateArgsName = getAggregateArgsName(model.name);
    const aggregateName = getAggregateName(model.name);
    return `${aggregateTypes.map(buildOutputType).map((type) => ts14.stringify(type)).join("\n\n")}

${aggregateTypes.length > 1 ? aggregateTypes.slice(1).map((type) => {
      const newType = {
        name: getAggregateInputType(type.name),
        constraints: {
          maxNumFields: null,
          minNumFields: null
        },
        fields: type.fields.map((field) => ({
          ...field,
          name: field.name,
          isNullable: false,
          isRequired: false,
          inputTypes: [
            {
              isList: false,
              location: "scalar",
              type: "true"
            }
          ]
        }))
      };
      return new InputType(newType, this.context).toTS();
    }).join("\n") : ""}

export type ${aggregateArgsName}<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
${indent5(
      aggregateRootField.args.map((arg) => {
        const updatedArg = { ...arg, comment: getArgFieldJSDoc(this.type, DMMF2.ModelAction.aggregate, arg) };
        return new InputField(updatedArg, this.context).toTS();
      }).concat(
        aggregateType.fields.map((f) => {
          let data = "";
          const comment = getArgFieldJSDoc(this.type, DMMF2.ModelAction.aggregate, f.name);
          data += comment ? wrapComment(comment) + "\n" : "";
          if (f.name === "_count" || f.name === "count") {
            data += `${f.name}?: true | ${getCountAggregateInputName(model.name)}`;
          } else {
            data += `${f.name}?: ${getAggregateInputType(f.outputType.type)}`;
          }
          return data;
        })
      ).join("\n"),
      TAB_SIZE
    )}
}

export type ${getAggregateGetName(model.name)}<T extends ${getAggregateArgsName(model.name)}> = {
      [P in keyof T & keyof ${aggregateName}]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], ${aggregateName}[P]>
    : Prisma.GetScalarType<T[P], ${aggregateName}[P]>
}`;
  }
  getDeepInputTypes() {
    return this.dmmf.inputObjectTypes.prisma?.filter((i) => i.meta?.grouping === this.model.name).map((inputType) => new InputType(inputType, this.context).toTS()).join("\n");
  }
  getCountTypes() {
    const countTypes = this.dmmf.schema.outputObjectTypes.prisma?.filter((t) => t.name === getCountOutputTypeName(this.model.name)).map((t) => new Count(t, this.context));
    return countTypes.map((t) => t.toTS()).join("\n");
  }
  getModelExport() {
    const docLines = this.model.documentation ?? "";
    const modelLine = `Model ${this.model.name}
`;
    const docs = `${modelLine}${docLines}`;
    const modelTypeExport = ts14.moduleExport(
      ts14.typeDeclaration(
        `${this.model.name}Model`,
        ts14.namedType(`runtime.Types.Result.DefaultSelection`).addGenericArgument(ts14.namedType(getPayloadName(this.model.name)))
      )
    ).setDocComment(ts14.docComment(docs));
    return ts14.stringify(modelTypeExport);
  }
  toTS() {
    const { model } = this;
    const isComposite = this.dmmf.isComposite(model.name);
    const omitType = ts14.stringify(
      buildOmitType({ modelName: this.model.name, context: this.context, fields: this.type.fields }),
      {
        newLine: "leading"
      }
    );
    const hasRelationField = model.fields.some((f) => f.kind === "object");
    const includeType = hasRelationField ? ts14.stringify(
      buildIncludeType({ modelName: this.model.name, context: this.context, fields: this.type.fields }),
      {
        newLine: "leading"
      }
    ) : "";
    const createManyAndReturnIncludeType = hasRelationField && this.createManyAndReturnType ? ts14.stringify(
      buildIncludeType({
        typeName: getIncludeCreateManyAndReturnName(this.model.name),
        modelName: this.model.name,
        context: this.context,
        fields: this.createManyAndReturnType.fields
      }),
      {
        newLine: "leading"
      }
    ) : "";
    const updateManyAndReturnIncludeType = hasRelationField && this.updateManyAndReturnType ? ts14.stringify(
      buildIncludeType({
        typeName: getIncludeUpdateManyAndReturnName(this.model.name),
        modelName: this.model.name,
        context: this.context,
        fields: this.updateManyAndReturnType.fields
      }),
      {
        newLine: "leading"
      }
    ) : "";
    return `
${this.getModelExport()}

${!isComposite ? this.getAggregationTypes() : ""}

${!isComposite ? this.getGroupByTypes() : ""}

${this.getDeepInputTypes()}

${this.getCountTypes()}

${ts14.stringify(buildSelectType({ modelName: this.model.name, fields: this.type.fields, context: this.context }))}
${this.createManyAndReturnType ? ts14.stringify(
      buildSelectType({
        modelName: this.model.name,
        fields: this.createManyAndReturnType.fields,
        context: this.context,
        typeName: getSelectCreateManyAndReturnName(this.model.name)
      }),
      { newLine: "leading" }
    ) : ""}
${this.updateManyAndReturnType ? ts14.stringify(
      buildSelectType({
        modelName: this.model.name,
        fields: this.updateManyAndReturnType.fields,
        context: this.context,
        typeName: getSelectUpdateManyAndReturnName(this.model.name)
      }),
      { newLine: "leading" }
    ) : ""}
${ts14.stringify(buildScalarSelectType({ modelName: this.model.name, fields: this.type.fields, context: this.context }), {
      newLine: "leading"
    })}
${omitType}${includeType}${createManyAndReturnIncludeType}${updateManyAndReturnIncludeType}

${ts14.stringify(buildModelPayload(this.model, this.context), { newLine: "none" })}

export type ${model.name}GetPayload<S extends boolean | null | undefined | ${getModelArgName(
      model.name
    )}> = runtime.Types.Result.GetResult<${getPayloadName(model.name)}, S>

${isComposite ? "" : new ModelDelegate(this.type, this.context).toTS()}

${new ModelFieldRefs(this.type).toTS()}

// Custom InputTypes
${this.argsTypes.map((type) => ts14.stringify(type)).join("\n\n")}
`;
  }
};
var ModelDelegate = class {
  constructor(outputType, context) {
    this.outputType = outputType;
    this.context = context;
  }
  /**
   * Returns all available non-aggregate or group actions
   * Includes both dmmf and client-only actions
   *
   * @param availableActions
   * @returns
   */
  getNonAggregateActions(availableActions) {
    const actions = availableActions.filter(
      (key) => key !== DMMF2.ModelAction.aggregate && key !== DMMF2.ModelAction.groupBy && key !== DMMF2.ModelAction.count
    );
    return actions;
  }
  toTS() {
    const { name } = this.outputType;
    const { dmmf } = this.context;
    const mapping = dmmf.mappingsMap[name] ?? { model: name, plural: `${name}s` };
    const modelOrType = dmmf.typeAndModelMap[name];
    const availableActions = getModelActions(dmmf, name);
    const nonAggregateActions = this.getNonAggregateActions(availableActions);
    const groupByArgsName = getGroupByArgsName(name);
    const countArgsName = getModelArgName(name, DMMF2.ModelAction.count);
    const genericDelegateParams = [extArgsParam, ts14.genericParameter("GlobalOmitOptions").default(ts14.objectType())];
    const excludedArgsForCount = ["select", "include", "distinct", "omit"];
    if (this.context.isPreviewFeatureOn("relationJoins")) {
      excludedArgsForCount.push("relationLoadStrategy");
    }
    const excludedArgsForCountType = excludedArgsForCount.map((name2) => `'${name2}'`).join(" | ");
    return `${availableActions.includes(DMMF2.ModelAction.aggregate) ? `export type ${countArgsName}<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<${getModelArgName(name, DMMF2.ModelAction.findMany)}, ${excludedArgsForCountType}> & {
    select?: ${getCountAggregateInputName(name)} | true
  }
` : ""}
export interface ${name}Delegate<${genericDelegateParams.map((param) => ts14.stringify(param)).join(", ")}> {
${indent5(`[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['${name}'], meta: { name: '${name}' } }`, TAB_SIZE)}
${nonAggregateActions.map((action) => {
      const method3 = buildModelDelegateMethod(name, action, this.context);
      return ts14.stringify(method3, { indentLevel: 1, newLine: "trailing" });
    }).join("\n")}

${availableActions.includes(DMMF2.ModelAction.aggregate) ? `${indent5(getMethodJSDoc(DMMF2.ModelAction.count, mapping, modelOrType), TAB_SIZE)}
  count<T extends ${countArgsName}>(
    args?: Prisma.Subset<T, ${countArgsName}>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], ${getCountAggregateOutputName(name)}>
      : number
  >
` : ""}
${availableActions.includes(DMMF2.ModelAction.aggregate) ? `${indent5(getMethodJSDoc(DMMF2.ModelAction.aggregate, mapping, modelOrType), TAB_SIZE)}
  aggregate<T extends ${getAggregateArgsName(name)}>(args: Prisma.Subset<T, ${getAggregateArgsName(
      name
    )}>): Prisma.PrismaPromise<${getAggregateGetName(name)}<T>>
` : ""}
${availableActions.includes(DMMF2.ModelAction.groupBy) ? `${indent5(getMethodJSDoc(DMMF2.ModelAction.groupBy, mapping, modelOrType), TAB_SIZE)}
  groupBy<
    T extends ${groupByArgsName},
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: ${groupByArgsName}['orderBy'] }
      : { orderBy?: ${groupByArgsName}['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? \`Error: "by" must not be empty.\`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? \`Error: Field "\${P}" used in "having" needs to be provided in "by".\`
          : [
              Error,
              'Field ',
              P,
              \` in "having" needs to be provided in "by"\`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, ${groupByArgsName}, OrderByArg> & InputErrors): {} extends InputErrors ? ${getGroupByPayloadName(
      name
    )}<T> : Prisma.PrismaPromise<InputErrors>` : ""}
/**
 * Fields of the ${name} model
 */
readonly fields: ${getFieldRefsTypeName(name)};
}

${ts14.stringify(buildFluentWrapperDefinition(name, this.outputType, this.context))}
`;
  }
};
function buildModelDelegateMethod(modelName, actionName, context) {
  const mapping = context.dmmf.mappingsMap[modelName] ?? { model: modelName, plural: `${modelName}s` };
  const modelOrType = context.dmmf.typeAndModelMap[modelName];
  const dependencyValidators = getNonAggregateMethodDependencyValidations(mapping, actionName, context);
  const method3 = ts14.method(actionName).setDocComment(ts14.docComment(getMethodJSDocBody(actionName, mapping, modelOrType))).addParameter(getNonAggregateMethodArgs(modelName, actionName, dependencyValidators)).setReturnType(getReturnType({ modelName, actionName }));
  const generic = getNonAggregateMethodGenericParam(modelName, actionName);
  if (generic) {
    method3.addGenericParameter(generic);
  }
  for (const validator of dependencyValidators) {
    method3.addGenericParameter(validator);
  }
  return method3;
}
function getNonAggregateMethodArgs(modelName, actionName, dependencyValidators) {
  const makeParameter = (type2) => {
    if (dependencyValidators.length > 0) {
      type2 = ts14.intersectionType([type2, ...dependencyValidators.map((validator) => ts14.namedType(validator.name))]);
    }
    return ts14.parameter("args", type2);
  };
  if (actionName === DMMF2.ModelAction.count) {
    const type2 = omit(
      ts14.namedType(getModelArgName(modelName, DMMF2.ModelAction.findMany)),
      ts14.unionType(ts14.stringLiteral("select")).addVariant(ts14.stringLiteral("include")).addVariant(ts14.stringLiteral("distinct"))
    );
    return makeParameter(type2).optional();
  }
  if (actionName === DMMF2.ModelAction.findRaw || actionName === DMMF2.ModelAction.aggregateRaw) {
    return makeParameter(ts14.namedType(`Prisma.${getModelArgName(modelName, actionName)}`)).optional();
  }
  const type = ts14.namedType("Prisma.SelectSubset").addGenericArgument(ts14.namedType("T")).addGenericArgument(
    ts14.namedType(getModelArgName(modelName, actionName)).addGenericArgument(extArgsParam.toArgument())
  );
  const param = makeParameter(type);
  if (actionName === DMMF2.ModelAction.findMany || actionName === DMMF2.ModelAction.findFirst || actionName === DMMF2.ModelAction.deleteMany || actionName === DMMF2.ModelAction.createMany || actionName === DMMF2.ModelAction.createManyAndReturn || actionName === DMMF2.ModelAction.findFirstOrThrow) {
    param.optional();
  }
  return param;
}
function getNonAggregateMethodGenericParam(modelName, actionName) {
  if (actionName === DMMF2.ModelAction.count || actionName === DMMF2.ModelAction.findRaw || actionName === DMMF2.ModelAction.aggregateRaw) {
    return null;
  }
  const arg = ts14.genericParameter("T");
  if (actionName === DMMF2.ModelAction.aggregate) {
    return arg.extends(ts14.namedType(getAggregateArgsName(modelName)));
  }
  return arg.extends(ts14.namedType(getModelArgName(modelName, actionName)));
}
function getNonAggregateMethodDependencyValidations(modelMapping, actionName, context) {
  const outputFieldName = modelMapping[actionName];
  if (!outputFieldName) {
    throw new Error(`Missing mapping for ${modelMapping.model}.${actionName}`);
  }
  const outputField = context.dmmf.outputTypeMap.prisma["Query"].fields.find((f) => f.name === outputFieldName) ?? context.dmmf.outputTypeMap.prisma["Mutation"].fields.find((f) => f.name === outputFieldName);
  if (!outputField) {
    throw new Error(`Can't find output field ${outputFieldName} in the schema`);
  }
  const validators = [];
  for (const args of outputField.args) {
    if (args.requiresOtherFields === void 0) {
      continue;
    }
    const objectType11 = ts14.objectType();
    for (const reqArg of args.requiresOtherFields) {
      objectType11.add(ts14.property(reqArg, ts14.objectType()));
    }
    validators.push(
      ts14.genericParameter(`${capitalize9(args.name)}DependenciesValidator`).extends(
        ts14.conditionalType().check(ts14.stringLiteral(args.name)).extends(ts14.namedType("Prisma.Keys<T>")).then(objectType11).else(ts14.objectType())
      )
    );
  }
  return validators;
}
function getReturnType({
  modelName,
  actionName,
  isChaining = false,
  isNullable = false
}) {
  if (actionName === DMMF2.ModelAction.count) {
    return promise(ts14.numberType);
  }
  if (actionName === DMMF2.ModelAction.aggregate) {
    return promise(ts14.namedType(getAggregateGetName(modelName)).addGenericArgument(ts14.namedType("T")));
  }
  if (actionName === DMMF2.ModelAction.findRaw || actionName === DMMF2.ModelAction.aggregateRaw) {
    return prismaPromise(ts14.namedType("Prisma.JsonObject"));
  }
  if (actionName === DMMF2.ModelAction.deleteMany || actionName === DMMF2.ModelAction.updateMany || actionName === DMMF2.ModelAction.createMany) {
    return prismaPromise(ts14.namedType("Prisma.BatchPayload"));
  }
  const isList = actionName === DMMF2.ModelAction.findMany || actionName === DMMF2.ModelAction.createManyAndReturn || actionName === DMMF2.ModelAction.updateManyAndReturn;
  if (isList) {
    let result = getResultType(modelName, actionName);
    if (isChaining) {
      result = ts14.unionType(result).addVariant(ts14.namedType("Null"));
    }
    return prismaPromise(result);
  }
  if (isChaining && actionName === DMMF2.ModelAction.findUniqueOrThrow) {
    const nullType7 = isNullable ? ts14.nullType : ts14.namedType("Null");
    const result = ts14.unionType(getResultType(modelName, actionName)).addVariant(nullType7);
    return getFluentWrapper(modelName, result, nullType7);
  }
  if (actionName === DMMF2.ModelAction.findFirst || actionName === DMMF2.ModelAction.findUnique) {
    const result = ts14.unionType(getResultType(modelName, actionName)).addVariant(ts14.nullType);
    return getFluentWrapper(modelName, result, ts14.nullType);
  }
  return getFluentWrapper(modelName, getResultType(modelName, actionName));
}
function getFluentWrapper(modelName, resultType, nullType7 = ts14.neverType) {
  return ts14.namedType(`Prisma.${fluentWrapperName(modelName)}`).addGenericArgument(resultType).addGenericArgument(nullType7).addGenericArgument(extArgsParam.toArgument()).addGenericArgument(ts14.namedType("GlobalOmitOptions"));
}
function getResultType(modelName, actionName) {
  return ts14.namedType("runtime.Types.Result.GetResult").addGenericArgument(ts14.namedType(getPayloadName(modelName)).addGenericArgument(extArgsParam.toArgument())).addGenericArgument(ts14.namedType("T")).addGenericArgument(ts14.stringLiteral(actionName)).addGenericArgument(ts14.namedType("GlobalOmitOptions"));
}
function buildFluentWrapperDefinition(modelName, outputType, context) {
  const definition = ts14.interfaceDeclaration(fluentWrapperName(modelName));
  definition.addGenericParameter(ts14.genericParameter("T")).addGenericParameter(ts14.genericParameter("Null").default(ts14.neverType)).addGenericParameter(extArgsParam).addGenericParameter(ts14.genericParameter("GlobalOmitOptions").default(ts14.objectType())).extends(prismaPromise(ts14.namedType("T")));
  definition.add(ts14.property(ts14.toStringTag, ts14.stringLiteral("PrismaPromise")).readonly());
  definition.addMultiple(
    outputType.fields.filter(
      (field) => field.outputType.location === "outputObjectTypes" && !context.dmmf.isComposite(field.outputType.type) && field.name !== "_count"
    ).map((field) => {
      const fieldArgType = ts14.namedType(`Prisma.${getFieldArgName(field, modelName)}`).addGenericArgument(extArgsParam.toArgument());
      const argsParam = ts14.genericParameter("T").extends(fieldArgType).default(ts14.objectType());
      return ts14.method(field.name).addGenericParameter(argsParam).addParameter(ts14.parameter("args", subset(argsParam.toArgument(), fieldArgType)).optional()).setReturnType(
        getReturnType({
          modelName: field.outputType.type,
          actionName: field.outputType.isList ? DMMF2.ModelAction.findMany : DMMF2.ModelAction.findUniqueOrThrow,
          isChaining: true,
          isNullable: field.isNullable
        })
      );
    })
  );
  definition.add(
    ts14.method("then").setDocComment(
      ts14.docComment`
          Attaches callbacks for the resolution and/or rejection of the Promise.
          @param onfulfilled The callback to execute when the Promise is resolved.
          @param onrejected The callback to execute when the Promise is rejected.
          @returns A Promise for the completion of which ever callback is executed.
        `
    ).addGenericParameter(ts14.genericParameter("TResult1").default(ts14.namedType("T"))).addGenericParameter(ts14.genericParameter("TResult2").default(ts14.neverType)).addParameter(promiseCallback("onfulfilled", ts14.parameter("value", ts14.namedType("T")), ts14.namedType("TResult1"))).addParameter(promiseCallback("onrejected", ts14.parameter("reason", ts14.anyType), ts14.namedType("TResult2"))).setReturnType(promise(ts14.unionType([ts14.namedType("TResult1"), ts14.namedType("TResult2")])))
  );
  definition.add(
    ts14.method("catch").setDocComment(
      ts14.docComment`
          Attaches a callback for only the rejection of the Promise.
          @param onrejected The callback to execute when the Promise is rejected.
          @returns A Promise for the completion of the callback.
        `
    ).addGenericParameter(ts14.genericParameter("TResult").default(ts14.neverType)).addParameter(promiseCallback("onrejected", ts14.parameter("reason", ts14.anyType), ts14.namedType("TResult"))).setReturnType(promise(ts14.unionType([ts14.namedType("T"), ts14.namedType("TResult")])))
  );
  definition.add(
    ts14.method("finally").setDocComment(
      ts14.docComment`
          Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
          resolved value cannot be modified from the callback.
          @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
          @returns A Promise for the completion of the callback.
      `
    ).addParameter(
      ts14.parameter("onfinally", ts14.unionType([ts14.functionType(), ts14.undefinedType, ts14.nullType])).optional()
    ).setReturnType(promise(ts14.namedType("T")))
  );
  return ts14.moduleExport(definition).setDocComment(ts14.docComment`
      The delegate class that acts as a "Promise-like" for ${modelName}.
      Why is this prefixed with \`Prisma__\`?
      Because we want to prevent naming conflicts as mentioned in
      https://github.com/prisma/prisma-client-js/issues/707
    `);
}
function promiseCallback(name, callbackParam, returnType) {
  return ts14.parameter(
    name,
    ts14.unionType([
      ts14.functionType().addParameter(callbackParam).setReturnType(typeOrPromiseLike(returnType)),
      ts14.undefinedType,
      ts14.nullType
    ])
  ).optional();
}
function typeOrPromiseLike(type) {
  return ts14.unionType([type, ts14.namedType("PromiseLike").addGenericArgument(type)]);
}
function subset(arg, baseType) {
  return ts14.namedType("Prisma.Subset").addGenericArgument(arg).addGenericArgument(baseType);
}
function fluentWrapperName(modelName) {
  return `Prisma__${modelName}Client`;
}

// src/TSClient/file-generators/ModelFile.ts
function createModelFile(context, modelName) {
  const jsDocHeader9 = `/*
 * This file exports the \`${modelName}\` model and its related types.
 *
 * \u{1F7E2} You can import this file directly.
 */
`;
  const imports = [
    ts15.moduleImport(context.runtimeImport).asNamespace("runtime").typeOnly(),
    ts15.moduleImport(context.importFileName(`../enums`)).asNamespace("$Enums").typeOnly(),
    ts15.moduleImport(context.importFileName(`../internal/prismaNamespace`)).asNamespace("Prisma").typeOnly()
  ];
  const importsString = imports.map((i) => ts15.stringify(i)).join("\n");
  const model = context.dmmf.typeAndModelMap[modelName];
  return jsDocHeader9 + importsString + "\n" + new Model(model, context).toTS();
}

// src/TSClient/file-generators/ModelsFile.ts
var jsDocHeader6 = `/*
 * This is a barrel export file for all models and their related types.
 *
 * \u{1F7E2} You can import this file directly.
 */
`;
function createModelsFile(context, modelsNames) {
  const exports = modelsNames.map((m) => `export type * from './models/${context.importFileName(m)}'`);
  exports.push(`export type * from './${context.importFileName("commonInputTypes")}'`);
  return jsDocHeader6 + exports.join("\n");
}

// src/TSClient/file-generators/PrismaNamespaceBrowserFile.ts
import * as ts16 from "@prisma/ts-builders";
var jsDocHeader7 = `/*
 * WARNING: This is an internal file that is subject to change!
 *
 * \u{1F6D1} Under no circumstances should you import this file directly! \u{1F6D1}
 *
 * All exports from this file are wrapped under a \`Prisma\` namespace object in the browser.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the \`model\` directory!
 */
`;
function createPrismaNamespaceBrowserFile(context) {
  const prismaEnums = context.dmmf.schema.enumTypes.prisma?.map((type) => new Enum(type, true).toTS());
  return `${jsDocHeader7}
${ts16.stringify(ts16.moduleImport(`${context.runtimeBase}/index-browser`).asNamespace("runtime"))}
export type * from '${context.importFileName(`../models`)}'
export type * from '${context.importFileName(`./prismaNamespace`)}'
export const Decimal = runtime.Decimal
${new Enum(
    {
      name: "ModelName",
      values: context.dmmf.mappings.modelOperations.map((m) => m.model)
    },
    true
  ).toTS()}
/**
 * Enums
 */
${prismaEnums?.join("\n\n")}
`;
}

// src/TSClient/file-generators/PrismaNamespaceFile.ts
import * as ts19 from "@prisma/ts-builders";

// src/TSClient/common.ts
var commonCodeTS = ({ clientVersion, engineVersion, generator }) => {
  return `export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql

${buildPrismaSkipTs(generator.previewFeatures)}

/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
 * Metrics
 */
export type Metrics = runtime.Metrics
export type Metric<T> = runtime.Metric<T>
export type MetricHistogram = runtime.MetricHistogram
export type MetricHistogramBucket = runtime.MetricHistogramBucket

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: ${clientVersion}
 * Query Engine version: ${engineVersion}
 */
export const prismaVersion: PrismaVersion = {
  client: "${clientVersion}",
  engine: "${engineVersion}"
}

/**
 * Utility Types
 */

export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue

export const NullTypes = {
  DbNull: runtime.objectEnumValues.classes.DbNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.DbNull),
  JsonNull: runtime.objectEnumValues.classes.JsonNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.JsonNull),
  AnyNull: runtime.objectEnumValues.classes.AnyNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.AnyNull),
}

/**
 * Helper for filtering JSON entries that have \`null\` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.objectEnumValues.instances.DbNull

/**
 * Helper for filtering JSON entries that have JSON \`null\` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.objectEnumValues.instances.JsonNull

/**
 * Helper for filtering JSON entries that are \`Prisma.DbNull\` or \`Prisma.JsonNull\`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.objectEnumValues.instances.AnyNull

type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From \`T\` pick properties that exist in \`U\`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From \`T\` pick properties that exist in \`U\`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose \`select\` or \`include\`.'
    : T extends SelectAndOmit
      ? 'Please either choose \`select\` or \`omit\`.'
      : {})

/**
 * Subset + Intersection
 * @desc From \`T\` pick properties that exist in \`U\` and intersect \`K\`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything \`never\` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like \`Pick\`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends \`_\${string}\` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

`;
};
function buildPrismaSkipTs(previewFeatures) {
  if (previewFeatures.includes("strictUndefinedChecks")) {
    return `
/**
 * Prisma.skip
 */
export const skip = runtime.skip
`;
  }
  return "";
}

// src/TSClient/Datasources.ts
import indent6 from "indent-string";
var Datasources = class {
  constructor(internalDatasources) {
    this.internalDatasources = internalDatasources;
  }
  toTS() {
    const sources = this.internalDatasources;
    return `
export type Datasource = {
  url?: string
}
export type Datasources = {
${indent6(sources.map((s) => `${s.name}?: Datasource`).join("\n"), 2)}
}
`;
  }
};

// src/TSClient/FieldRefInput.ts
var FieldRefInput = class {
  constructor(type) {
    this.type = type;
  }
  toTS() {
    const allowedTypes = this.getAllowedTypes();
    return `
/**
 * Reference to a field of type ${allowedTypes}
 */
export type ${this.type.name}<$PrismaModel> = FieldRefInputType<$PrismaModel, ${allowedTypes}>
    `;
  }
  getAllowedTypes() {
    return this.type.allowTypes.map(getRefAllowedTypeName).join(" | ");
  }
};

// src/TSClient/globalOmit.ts
import { uncapitalize as uncapitalize7 } from "@prisma/client-common";
import * as ts17 from "@prisma/ts-builders";
function globalOmitConfig(dmmf) {
  const objectType11 = ts17.objectType().addMultiple(
    dmmf.datamodel.models.map((model) => {
      const type = ts17.namedType(`Prisma.${getOmitName(model.name)}`);
      return ts17.property(uncapitalize7(model.name), type).optional();
    })
  );
  return ts17.moduleExport(ts17.typeDeclaration("GlobalOmitConfig", objectType11));
}

// src/TSClient/TypeMap.ts
import { uncapitalize as uncapitalize8 } from "@prisma/client-common";
import { assertNever as assertNever2 } from "@prisma/internals";
import * as ts18 from "@prisma/ts-builders";
function clientTypeMapDefinition(context) {
  const typeMap = `${ts18.stringify(clientTypeMapModelsDefinition(context))} & ${clientTypeMapOthersDefinition(context)}`;
  return `
export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = ${typeMap}`;
}
function clientTypeMapModelsDefinition(context) {
  const meta = ts18.objectType();
  const modelNames = context.dmmf.datamodel.models.map((m) => m.name);
  if (modelNames.length === 0) {
    meta.add(ts18.property("modelProps", ts18.neverType));
  } else {
    meta.add(ts18.property("modelProps", ts18.unionType(modelNames.map((name) => ts18.stringLiteral(uncapitalize8(name))))));
  }
  const isolationLevel = context.dmmf.hasEnumInNamespace("TransactionIsolationLevel", "prisma") ? ts18.namedType("TransactionIsolationLevel") : ts18.neverType;
  meta.add(ts18.property("txIsolationLevel", isolationLevel));
  const model = ts18.objectType();
  model.addMultiple(
    modelNames.map((modelName) => {
      const entry = ts18.objectType();
      entry.add(
        ts18.property("payload", ts18.namedType(getPayloadName(modelName)).addGenericArgument(extArgsParam.toArgument()))
      );
      entry.add(ts18.property("fields", ts18.namedType(`Prisma.${getFieldRefsTypeName(modelName)}`)));
      const actions = getModelActions(context.dmmf, modelName);
      const operations = ts18.objectType();
      operations.addMultiple(
        actions.map((action) => {
          const operationType = ts18.objectType();
          const argsType = `Prisma.${getModelArgName(modelName, action)}`;
          operationType.add(ts18.property("args", ts18.namedType(argsType).addGenericArgument(extArgsParam.toArgument())));
          operationType.add(ts18.property("result", clientTypeMapModelsResultDefinition(modelName, action)));
          return ts18.property(action, operationType);
        })
      );
      entry.add(ts18.property("operations", operations));
      return ts18.property(modelName, entry);
    })
  );
  return ts18.objectType().add(ts18.property("globalOmitOptions", ts18.objectType().add(ts18.property("omit", ts18.namedType("GlobalOmitOptions"))))).add(ts18.property("meta", meta)).add(ts18.property("model", model));
}
function clientTypeMapOthersDefinition(context) {
  const otherOperationsNames = context.dmmf.getOtherOperationNames().flatMap((name) => {
    const results = [`$${name}`];
    if (name === "executeRaw" || name === "queryRaw") {
      results.push(`$${name}Unsafe`);
    }
    if (name === "queryRaw" && context.isPreviewFeatureOn("typedSql")) {
      results.push(`$queryRawTyped`);
    }
    return results;
  });
  const argsResultMap = {
    $executeRaw: { args: "[query: TemplateStringsArray | Sql, ...values: any[]]", result: "any" },
    $queryRaw: { args: "[query: TemplateStringsArray | Sql, ...values: any[]]", result: "any" },
    $executeRawUnsafe: { args: "[query: string, ...values: any[]]", result: "any" },
    $queryRawUnsafe: { args: "[query: string, ...values: any[]]", result: "any" },
    $runCommandRaw: { args: "Prisma.InputJsonObject", result: "JsonObject" },
    $queryRawTyped: { args: "runtime.UnknownTypedSql", result: "JsonObject" }
  };
  return `{
  other: {
    payload: any
    operations: {${otherOperationsNames.reduce((acc, action) => {
    return `${acc}
      ${action}: {
        args: ${argsResultMap[action].args},
        result: ${argsResultMap[action].result}
      }`;
  }, "")}
    }
  }
}`;
}
function clientTypeMapModelsResultDefinition(modelName, action) {
  if (action === "count")
    return ts18.unionType([optional(ts18.namedType(`Prisma.${getCountAggregateOutputName(modelName)}`)), ts18.numberType]);
  if (action === "groupBy") return ts18.array(optional(ts18.namedType(`Prisma.${getGroupByName(modelName)}`)));
  if (action === "aggregate") return optional(ts18.namedType(`Prisma.${getAggregateName(modelName)}`));
  if (action === "findRaw") return ts18.namedType("Prisma.JsonObject");
  if (action === "aggregateRaw") return ts18.namedType("Prisma.JsonObject");
  if (action === "deleteMany") return ts18.namedType("BatchPayload");
  if (action === "createMany") return ts18.namedType("BatchPayload");
  if (action === "createManyAndReturn") return ts18.array(payloadToResult(modelName));
  if (action === "updateMany") return ts18.namedType("BatchPayload");
  if (action === "updateManyAndReturn") return ts18.array(payloadToResult(modelName));
  if (action === "findMany") return ts18.array(payloadToResult(modelName));
  if (action === "findFirst") return ts18.unionType([payloadToResult(modelName), ts18.nullType]);
  if (action === "findUnique") return ts18.unionType([payloadToResult(modelName), ts18.nullType]);
  if (action === "findFirstOrThrow") return payloadToResult(modelName);
  if (action === "findUniqueOrThrow") return payloadToResult(modelName);
  if (action === "create") return payloadToResult(modelName);
  if (action === "update") return payloadToResult(modelName);
  if (action === "upsert") return payloadToResult(modelName);
  if (action === "delete") return payloadToResult(modelName);
  assertNever2(action, `Unknown action: ${action}`);
}
function payloadToResult(modelName) {
  return ts18.namedType("runtime.Types.Utils.PayloadToResult").addGenericArgument(ts18.namedType(getPayloadName(modelName)));
}

// src/TSClient/file-generators/PrismaNamespaceFile.ts
var jsDocHeader8 = `/*
 * WARNING: This is an internal file that is subject to change!
 *
 * \u{1F6D1} Under no circumstances should you import this file directly! \u{1F6D1}
 *
 * All exports from this file are wrapped under a \`Prisma\` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the \`model\` directory!
 */
`;
function createPrismaNamespaceFile(context, options) {
  const imports = [
    ts19.moduleImport(context.runtimeImport).asNamespace("runtime"),
    ts19.moduleImport(context.importFileName(`../models`)).asNamespace("Prisma").typeOnly(),
    ts19.moduleImport(context.importFileName(`./class`)).named(ts19.namedImport("PrismaClient").typeOnly())
  ].map((i) => ts19.stringify(i));
  const prismaEnums = context.dmmf.schema.enumTypes.prisma?.map((type) => new Enum(type, true).toTS());
  const fieldRefs = context.dmmf.schema.fieldRefTypes.prisma?.map((type) => new FieldRefInput(type).toTS()) ?? [];
  return `${jsDocHeader8}
${imports.join("\n")}

export type * from '${context.importFileName(`../models`)}'

${commonCodeTS(options)}
${new Enum(
    {
      name: "ModelName",
      values: context.dmmf.mappings.modelOperations.map((m) => m.model)
    },
    true
  ).toTS()}

${clientTypeMapDefinition(context)}

/**
 * Enums
 */

${prismaEnums?.join("\n\n")}

${fieldRefs.length > 0 ? `
/**
 * Field references
 */

${fieldRefs.join("\n\n")}` : ""}

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

${new Datasources(options.datasources).toTS()}
${clientExtensionsDefinitions()}
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
${ts19.stringify(ts19.moduleExport(buildClientOptions(context, options)))}
${ts19.stringify(globalOmitConfig(context.dmmf))}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * \`PrismaClient\` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

`;
}
function clientExtensionsDefinitions() {
  const define = ts19.moduleExport(
    ts19.constDeclaration("defineExtension").setValue(
      ts19.namedValue("runtime.Extensions.defineExtension").as(ts19.namedType("unknown")).as(
        ts19.namedType("runtime.Types.Extensions.ExtendsHook").addGenericArgument(ts19.stringLiteral("define")).addGenericArgument(ts19.namedType("TypeMapCb")).addGenericArgument(ts19.namedType("runtime.Types.Extensions.DefaultArgs"))
      )
    )
  );
  return ts19.stringify(define);
}
function buildClientOptions(context, options) {
  const clientOptions = ts19.interfaceDeclaration("PrismaClientOptions").add(
    ts19.property("datasources", ts19.namedType("Datasources")).optional().setDocComment(ts19.docComment("Overwrites the datasource url from your schema.prisma file"))
  ).add(
    ts19.property("datasourceUrl", ts19.stringType).optional().setDocComment(ts19.docComment("Overwrites the datasource url from your schema.prisma file"))
  ).add(
    ts19.property("errorFormat", ts19.namedType("ErrorFormat")).optional().setDocComment(ts19.docComment('@default "colorless"'))
  ).add(
    ts19.property("log", ts19.array(ts19.unionType([ts19.namedType("LogLevel"), ts19.namedType("LogDefinition")]))).optional().setDocComment(ts19.docComment`
             @example
             \`\`\`
             // Shorthand for \`emit: 'stdout'\`
             log: ['query', 'info', 'warn', 'error']

             // Emit as events only
             log: [
               { emit: 'event', level: 'query' },
               { emit: 'event', level: 'info' },
               { emit: 'event', level: 'warn' }
               { emit: 'event', level: 'error' }
             ]

            // Emit as events and log to stdout
            log: [
              { emit: 'stdout', level: 'query' },
              { emit: 'stdout', level: 'info' },
              { emit: 'stdout', level: 'warn' }
              { emit: 'stdout', level: 'error' }
            ]
             \`\`\`
             Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
          `)
  );
  const transactionOptions = ts19.objectType().add(ts19.property("maxWait", ts19.numberType).optional()).add(ts19.property("timeout", ts19.numberType).optional());
  if (context.dmmf.hasEnumInNamespace("TransactionIsolationLevel", "prisma")) {
    transactionOptions.add(ts19.property("isolationLevel", ts19.namedType("TransactionIsolationLevel")).optional());
  }
  clientOptions.add(
    ts19.property("transactionOptions", transactionOptions).optional().setDocComment(ts19.docComment`
             The default values for transactionOptions
             maxWait ?= 2000
             timeout ?= 5000
          `)
  );
  if (["library", "client", "wasm-compiler-edge", "wasm-engine-edge"].includes(options.runtimeName)) {
    clientOptions.add(
      ts19.property("adapter", ts19.unionType([ts19.namedType("runtime.SqlDriverAdapterFactory"), ts19.namedType("null")])).optional().setDocComment(
        ts19.docComment("Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`")
      )
    );
  }
  clientOptions.add(
    ts19.property("omit", ts19.namedType("GlobalOmitConfig")).optional().setDocComment(ts19.docComment`
        Global configuration for omitting model fields by default.

        @example
        \`\`\`
        const prisma = new PrismaClient({
          omit: {
            user: {
              password: true
            }
          }
        })
        \`\`\`
      `)
  );
  return clientOptions;
}

// src/TSClient/GenerateContext.ts
var GenerateContext = class {
  dmmf;
  genericArgsInfo;
  runtimeBase;
  runtimeImport;
  outputFileName;
  importFileName;
  generator;
  constructor({
    dmmf,
    genericArgsInfo,
    runtimeBase,
    runtimeImport: runtimeImport2,
    outputFileName,
    importFileName,
    generator
  }) {
    this.dmmf = dmmf;
    this.genericArgsInfo = genericArgsInfo;
    this.runtimeBase = runtimeBase;
    this.runtimeImport = runtimeImport2;
    this.outputFileName = outputFileName;
    this.importFileName = importFileName;
    this.generator = generator;
  }
  isPreviewFeatureOn(previewFeature) {
    return this.generator?.previewFeatures?.includes(previewFeature) ?? false;
  }
};

// src/TSClient/TSClient.ts
var TSClient = class {
  constructor(options) {
    this.options = options;
    this.dmmf = new DMMFHelper(options.dmmf);
    this.genericsInfo = new GenericArgsInfo(this.dmmf);
  }
  dmmf;
  genericsInfo;
  generateClientFiles() {
    const context = new GenerateContext({
      dmmf: this.dmmf,
      genericArgsInfo: this.genericsInfo,
      runtimeBase: this.options.runtimeBase,
      runtimeImport: `${this.options.runtimeBase}/${this.options.runtimeName}`,
      outputFileName: generatedFileNameMapper(this.options.generatedFileExtension),
      importFileName: importFileNameMapper(this.options.importFileExtension),
      generator: this.options.generator
    });
    const modelNames = Object.values(context.dmmf.typeAndModelMap).filter((model) => context.dmmf.outputTypeMap.model[model.name]).map((model) => model.name);
    const modelsFileMap = modelNames.reduce((acc, modelName) => {
      acc[context.outputFileName(modelName)] = createModelFile(context, modelName);
      return acc;
    }, {});
    return {
      [context.outputFileName("client")]: createClientFile(context, this.options),
      [context.outputFileName("browser")]: createBrowserFile(context, this.options),
      [context.outputFileName("enums")]: createEnumsFile(context),
      [context.outputFileName("commonInputTypes")]: createCommonInputTypeFiles(context),
      [context.outputFileName("models")]: createModelsFile(context, modelNames),
      models: modelsFileMap,
      internal: {
        [context.outputFileName("prismaNamespace")]: createPrismaNamespaceFile(context, this.options),
        [context.outputFileName("prismaNamespaceBrowser")]: createPrismaNamespaceBrowserFile(context),
        [context.outputFileName("class")]: createClassFile(context, this.options)
      }
    };
  }
};

// src/typedSql/buildDbEnums.ts
import { isValidJsIdentifier } from "@prisma/internals";
import * as ts20 from "@prisma/ts-builders";
var DbEnumsList = class {
  enums;
  constructor(enums) {
    this.enums = enums.map((dmmfEnum) => ({
      name: dmmfEnum.dbName ?? dmmfEnum.name,
      values: dmmfEnum.values.map((dmmfValue) => dmmfValue.dbName ?? dmmfValue.name)
    }));
  }
  isEmpty() {
    return this.enums.length === 0;
  }
  hasEnum(name) {
    return Boolean(this.enums.find((dbEnum) => dbEnum.name === name));
  }
  *validJsIdentifiers() {
    for (const dbEnum of this.enums) {
      if (isValidJsIdentifier(dbEnum.name)) {
        yield dbEnum;
      }
    }
  }
  *invalidJsIdentifiers() {
    for (const dbEnum of this.enums) {
      if (!isValidJsIdentifier(dbEnum.name)) {
        yield dbEnum;
      }
    }
  }
};
function buildDbEnums(list) {
  const file4 = ts20.file();
  const iface = ts20.interfaceDeclaration("$DbEnums");
  for (const dbEnum of list.enums) {
    iface.add(ts20.property(dbEnum.name, enumToUnion(dbEnum)));
  }
  file4.add(ts20.moduleExport(iface));
  return ts20.stringify(file4);
}
function enumToUnion(dbEnum) {
  return ts20.unionType(dbEnum.values.map(ts20.stringLiteral));
}
function queryUsesEnums(query, enums) {
  if (enums.isEmpty()) {
    return false;
  }
  return query.parameters.some((param) => enums.hasEnum(param.typ)) || query.resultColumns.some((column) => enums.hasEnum(column.typ));
}

// src/typedSql/buildIndex.ts
import * as ts21 from "@prisma/ts-builders";
function buildIndex({ queries, enums, importName }) {
  const file4 = ts21.file();
  if (!enums.isEmpty()) {
    file4.add(ts21.moduleExportFrom(importName("./sql/$DbEnums")).named(ts21.namedExport("$DbEnums").typeOnly()));
  }
  for (const query of queries) {
    file4.add(ts21.moduleExportFrom(importName(`./sql/${query.name}`)));
  }
  return ts21.stringify(file4);
}

// src/typedSql/buildTypedQuery.ts
import * as ts23 from "@prisma/ts-builders";

// src/typedSql/mapTypes.ts
import * as ts22 from "@prisma/ts-builders";
var decimal = ts22.namedType("$runtime.Decimal");
var uint8Array = ts22.namedType("Uint8Array");
var date = ts22.namedType("Date");
var inputJsonValue = ts22.namedType("$runtime.InputJsonObject");
var jsonValue = ts22.namedType("$runtime.JsonValue");
var bigintIn = ts22.unionType([ts22.numberType, ts22.bigintType]);
var decimalIn = ts22.unionType([ts22.numberType, decimal]);
var typeMappings = {
  unknown: ts22.unknownType,
  string: ts22.stringType,
  int: ts22.numberType,
  bigint: {
    in: bigintIn,
    out: ts22.bigintType
  },
  decimal: {
    in: decimalIn,
    out: decimal
  },
  float: ts22.numberType,
  double: ts22.numberType,
  enum: ts22.stringType,
  // TODO:
  bytes: uint8Array,
  bool: ts22.booleanType,
  char: ts22.stringType,
  json: {
    in: inputJsonValue,
    out: jsonValue
  },
  xml: ts22.stringType,
  uuid: ts22.stringType,
  date,
  datetime: date,
  time: date,
  null: ts22.nullType,
  "int-array": ts22.array(ts22.numberType),
  "string-array": ts22.array(ts22.stringType),
  "json-array": {
    in: ts22.array(inputJsonValue),
    out: ts22.array(jsonValue)
  },
  "uuid-array": ts22.array(ts22.stringType),
  "xml-array": ts22.array(ts22.stringType),
  "bigint-array": {
    in: ts22.array(bigintIn),
    out: ts22.array(ts22.bigintType)
  },
  "float-array": ts22.array(ts22.numberType),
  "double-array": ts22.array(ts22.numberType),
  "char-array": ts22.array(ts22.stringType),
  "bytes-array": ts22.array(uint8Array),
  "bool-array": ts22.array(ts22.booleanType),
  "date-array": ts22.array(date),
  "time-array": ts22.array(date),
  "datetime-array": ts22.array(date),
  "decimal-array": {
    in: ts22.array(decimalIn),
    out: ts22.array(decimal)
  }
};
function getInputType(introspectionType, nullable, enums) {
  const inn = getMappingConfig(introspectionType, enums).in;
  if (!nullable) {
    return inn;
  } else {
    return new ts22.UnionType(inn).addVariant(ts22.nullType);
  }
}
function getOutputType(introspectionType, nullable, enums) {
  const out = getMappingConfig(introspectionType, enums).out;
  if (!nullable) {
    return out;
  } else {
    return new ts22.UnionType(out).addVariant(ts22.nullType);
  }
}
function getMappingConfig(introspectionType, enums) {
  const config = typeMappings[introspectionType];
  if (!config) {
    if (enums.hasEnum(introspectionType)) {
      const type = getEnumType(introspectionType);
      return { in: type, out: type };
    }
    throw new Error("Unknown type");
  }
  if (config instanceof ts22.TypeBuilder) {
    return { in: config, out: config };
  }
  return config;
}
function getEnumType(name) {
  return ts22.namedType("$DbEnums").subKey(name);
}

// src/typedSql/buildTypedQuery.ts
function buildTypedQuery({ query, runtimeBase, runtimeName, enums, importName }) {
  const file4 = ts23.file();
  file4.addImport(ts23.moduleImport(`${runtimeBase}/${runtimeName}`).asNamespace("$runtime"));
  if (queryUsesEnums(query, enums)) {
    file4.addImport(ts23.moduleImport(importName("./$DbEnums")).named(ts23.namedImport("$DbEnums").typeOnly()));
  }
  const doc = ts23.docComment(query.documentation ?? void 0);
  const factoryType = ts23.functionType();
  const parametersType = ts23.tupleType();
  for (const param of query.parameters) {
    const paramType = getInputType(param.typ, param.nullable, enums);
    factoryType.addParameter(ts23.parameter(param.name, paramType));
    parametersType.add(ts23.tupleItem(paramType).setName(param.name));
    if (param.documentation) {
      doc.addText(`@param ${param.name} ${param.documentation}`);
    } else {
      doc.addText(`@param ${param.name}`);
    }
  }
  factoryType.setReturnType(
    ts23.namedType("$runtime.TypedSql").addGenericArgument(ts23.namedType(`${query.name}.Parameters`)).addGenericArgument(ts23.namedType(`${query.name}.Result`))
  );
  file4.add(
    ts23.moduleExport(
      ts23.constDeclaration(query.name).setValue(
        ts23.functionCall("$runtime.makeTypedQueryFactory").addArgument(ts23.stringLiteral(query.source).asValue()).as(factoryType)
      )
    ).setDocComment(doc)
  );
  const namespace2 = ts23.namespace(query.name);
  namespace2.add(ts23.moduleExport(ts23.typeDeclaration("Parameters", parametersType)));
  namespace2.add(buildResultType(query, enums));
  file4.add(ts23.moduleExport(namespace2));
  return ts23.stringify(file4);
}
function buildResultType(query, enums) {
  const type = ts23.objectType().addMultiple(
    query.resultColumns.map((column) => ts23.property(column.name, getOutputType(column.typ, column.nullable, enums)))
  );
  return ts23.moduleExport(ts23.typeDeclaration("Result", type));
}

// src/typedSql/typedSql.ts
function buildTypedSql({
  queries,
  runtimeBase,
  runtimeName,
  dmmf,
  outputName,
  importName
}) {
  const fileMap = {
    sql: {}
  };
  const enums = new DbEnumsList(dmmf.datamodel.enums);
  if (!enums.isEmpty()) {
    fileMap.sql[outputName("$DbEnums")] = buildDbEnums(enums);
  }
  for (const query of queries) {
    const options = { query, runtimeBase, runtimeName, enums, importName };
    fileMap.sql[outputName(query.name)] = buildTypedQuery(options);
  }
  fileMap[outputName("sql")] = buildIndex({ queries, enums, importName });
  return fileMap;
}

// src/utils/addPreamble.ts
var generatedCodePreamble = `
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
`;
var tsNoCheckPreamble = `// @ts-nocheck 
`;
var extensions = [".ts", ".cts", ".mts", ".js", ".cjs", ".mjs"];
function addPreambleToSourceFiles(fileMap, includeTSNoCheckPreamble) {
  for (const [key, value] of Object.entries(fileMap)) {
    if ((typeof value === "string" || Buffer.isBuffer(value)) && extensions.some((ext) => key.endsWith(ext))) {
      fileMap[key] = generatedCodePreamble + (includeTSNoCheckPreamble ? tsNoCheckPreamble : "") + value.toString();
    } else if (typeof value === "object" && value !== null && !Buffer.isBuffer(value)) {
      addPreambleToSourceFiles(value, includeTSNoCheckPreamble);
    }
  }
}

// src/generateClient.ts
var DenylistError = class extends Error {
  constructor(message) {
    super(message);
    this.stack = void 0;
  }
};
setClassName(DenylistError, "DenylistError");
function buildClient({
  schemaPath,
  runtimeBase,
  datamodel,
  binaryPaths,
  outputDir,
  generator,
  dmmf,
  datasources,
  engineVersion,
  clientVersion,
  activeProvider,
  postinstall,
  copyEngine,
  envPaths,
  typedSql,
  target,
  generatedFileExtension,
  importFileExtension,
  moduleFormat,
  tsNoCheckPreamble: tsNoCheckPreamble2
}) {
  const clientEngineType = getClientEngineType4(generator);
  const runtimeName = getRuntimeNameForTarget(target, clientEngineType);
  const outputName = generatedFileNameMapper(generatedFileExtension);
  const importName = importFileNameMapper(importFileExtension);
  const clientOptions = {
    dmmf: getPrismaClientDMMF(dmmf),
    envPaths: envPaths ?? { rootEnvPath: null, schemaEnvPath: void 0 },
    datasources,
    generator,
    binaryPaths,
    schemaPath,
    outputDir,
    runtimeBase,
    clientVersion,
    engineVersion,
    activeProvider,
    postinstall,
    copyEngine,
    datamodel,
    edge: ["edge", "wasm-engine-edge", "wasm-compiler-edge", "react-native"].includes(runtimeName),
    runtimeName,
    target,
    generatedFileExtension,
    importFileExtension,
    moduleFormat,
    tsNoCheckPreamble: tsNoCheckPreamble2
  };
  if (runtimeName === "react-native" && !generator.previewFeatures.includes("reactNative")) {
    throw new Error(`Using the "react-native" runtime requires the "reactNative" preview feature to be enabled.`);
  }
  const client = new TSClient(clientOptions);
  let fileMap = client.generateClientFiles();
  if (typedSql && typedSql.length > 0) {
    fileMap = {
      ...fileMap,
      ...buildTypedSql({
        dmmf,
        runtimeBase: getTypedSqlRuntimeBase(runtimeBase),
        runtimeName,
        queries: typedSql,
        outputName,
        importName
      })
    };
  }
  fileMap = {
    ...fileMap,
    internal: {
      ...fileMap.internal,
      ...buildWasmFileMap({
        runtimeName,
        activeProvider
      })
    }
  };
  addPreambleToSourceFiles(fileMap, tsNoCheckPreamble2);
  return {
    fileMap,
    // a map of file names to their contents
    prismaClientDmmf: dmmf
    // the DMMF document
  };
}
function getTypedSqlRuntimeBase(runtimeBase) {
  if (!runtimeBase.startsWith(".")) {
    return runtimeBase;
  }
  if (runtimeBase.startsWith("./")) {
    return `.${runtimeBase}`;
  }
  return `../${runtimeBase}`;
}
async function generateClient(options) {
  const {
    datamodel,
    schemaPath,
    generator,
    dmmf,
    datasources,
    binaryPaths,
    clientVersion,
    engineVersion,
    activeProvider,
    postinstall,
    envPaths,
    copyEngine = true,
    typedSql,
    target,
    generatedFileExtension,
    importFileExtension,
    moduleFormat,
    tsNoCheckPreamble: tsNoCheckPreamble2
  } = options;
  const clientEngineType = getClientEngineType4(generator);
  const { runtimeBase, outputDir } = await getGenerationDirs(options);
  const { prismaClientDmmf, fileMap } = buildClient({
    datamodel,
    schemaPath,
    runtimeBase,
    outputDir,
    generator,
    dmmf,
    datasources,
    binaryPaths,
    clientVersion,
    engineVersion,
    activeProvider,
    postinstall,
    copyEngine,
    envPaths,
    typedSql,
    target,
    generatedFileExtension,
    importFileExtension,
    moduleFormat,
    tsNoCheckPreamble: tsNoCheckPreamble2
  });
  const denylistsErrors = validateDmmfAgainstDenylists(prismaClientDmmf);
  if (denylistsErrors) {
    let message = `${bold(
      red("Error: ")
    )}The schema at "${schemaPath}" contains reserved keywords.
       Rename the following items:`;
    for (const error of denylistsErrors) {
      message += "\n         - " + error.message;
    }
    message += `
To learn more about how to rename models, check out https://pris.ly/d/naming-models`;
    throw new DenylistError(message);
  }
  await deleteOutputDir(outputDir);
  await (0, import_fs_extra.ensureDir)(outputDir);
  await writeFileMap(outputDir, fileMap);
  const enginePath = clientEngineType === ClientEngineType3.Library ? binaryPaths.libqueryEngine : binaryPaths.queryEngine;
  if (copyEngine && enginePath) {
    if (process.env.NETLIFY) {
      await (0, import_fs_extra.ensureDir)("/tmp/prisma-engines");
    }
    for (const [binaryTarget, filePath] of Object.entries(enginePath)) {
      const fileName = path5.basename(filePath);
      let target2;
      if (process.env.NETLIFY && !["rhel-openssl-1.0.x", "rhel-openssl-3.0.x"].includes(binaryTarget)) {
        target2 = path5.join("/tmp/prisma-engines", fileName);
      } else {
        target2 = path5.join(outputDir, fileName);
      }
      await overwriteFile(filePath, target2);
    }
  }
}
function writeFileMap(outputDir, fileMap) {
  return Promise.all(
    Object.entries(fileMap).map(async ([fileName, content]) => {
      const absolutePath = path5.join(outputDir, fileName);
      await fs2.rm(absolutePath, { recursive: true, force: true });
      if (typeof content === "string" || Buffer.isBuffer(content)) {
        await fs2.writeFile(absolutePath, content);
      } else {
        await fs2.mkdir(absolutePath);
        await writeFileMap(absolutePath, content);
      }
    })
  );
}
function validateDmmfAgainstDenylists(prismaClientDmmf) {
  const errorArray = [];
  const denylists = {
    // A copy of this list is also in prisma-engines. Any edit should be done in both places.
    // https://github.com/prisma/prisma-engines/blob/main/psl/parser-database/src/names/reserved_model_names.rs
    models: [
      // Reserved Prisma keywords
      "PrismaClient",
      "Prisma",
      // JavaScript keywords
      "async",
      "await",
      "break",
      "case",
      "catch",
      "class",
      "const",
      "continue",
      "debugger",
      "default",
      "delete",
      "do",
      "else",
      "enum",
      "export",
      "extends",
      "false",
      "finally",
      "for",
      "function",
      "if",
      "implements",
      "import",
      "in",
      "instanceof",
      "interface",
      "let",
      "new",
      "null",
      "package",
      "private",
      "protected",
      "public",
      "return",
      "super",
      "switch",
      "this",
      "throw",
      "true",
      "try",
      "using",
      "typeof",
      "var",
      "void",
      "while",
      "with",
      "yield"
    ],
    fields: ["AND", "OR", "NOT"],
    dynamic: []
  };
  if (prismaClientDmmf.datamodel.enums) {
    for (const it of prismaClientDmmf.datamodel.enums) {
      if (denylists.models.includes(it.name) || denylists.fields.includes(it.name)) {
        errorArray.push(Error(`"enum ${it.name}"`));
      }
    }
  }
  if (prismaClientDmmf.datamodel.models) {
    for (const it of prismaClientDmmf.datamodel.models) {
      if (denylists.models.includes(it.name) || denylists.fields.includes(it.name)) {
        errorArray.push(Error(`"model ${it.name}"`));
      }
    }
  }
  return errorArray.length > 0 ? errorArray : null;
}
async function getGenerationDirs({ runtimeBase, outputDir }) {
  const normalizedOutputDir = path5.normalize(outputDir);
  const normalizedRuntimeBase = pathToPosix3(runtimeBase);
  const userPackageRoot = await packageUp({ cwd: path5.dirname(normalizedOutputDir) });
  const userProjectRoot = userPackageRoot ? path5.dirname(userPackageRoot) : process.cwd();
  return {
    runtimeBase: normalizedRuntimeBase,
    outputDir: normalizedOutputDir,
    projectRoot: userProjectRoot
  };
}
function getRuntimeNameForTarget(target, engineType) {
  switch (target) {
    case "nodejs":
    case "deno":
      return getNodeRuntimeName(engineType);
    case "workerd":
    case "vercel-edge":
      return engineType === ClientEngineType3.Client ? "wasm-compiler-edge" : "wasm-engine-edge";
    case "react-native":
      return "react-native";
    default:
      assertNever3(target, "Unknown runtime target");
  }
}
function getNodeRuntimeName(engineType) {
  if (engineType === ClientEngineType3.Binary) {
    return "binary";
  }
  if (engineType === ClientEngineType3.Library) {
    return "library";
  }
  if (engineType === ClientEngineType3.Client) {
    return "client";
  }
  assertNever3(engineType, "Unknown engine type");
}
async function deleteOutputDir(outputDir) {
  try {
    const files = await fs2.readdir(outputDir);
    if (files.length === 0) {
      return;
    }
    if (!files.includes("client.ts") && !files.includes("client.mts") && !files.includes("client.cts") && !files.includes("client.d.ts")) {
      throw new Error(
        `${outputDir} exists and is not empty but doesn't look like a generated Prisma Client. Please check your output path and remove the existing directory if you indeed want to generate the Prisma Client in that location.`
      );
    }
    await Promise.allSettled(
      (await glob(
        [
          `${outputDir}/**/*.{js,ts,mts,cts,d.ts}`,
          `${outputDir}/**/*.wasm`,
          `${outputDir}/*.node`,
          `${outputDir}/{query,schema}-engine-*`,
          `${outputDir}/package.json`,
          `${outputDir}/**/*.prisma`
        ],
        {
          followSymbolicLinks: false
        }
      )).map((file4) => fs2.unlink(file4))
    );
  } catch (error) {
    if (error.code !== "ENOENT") {
      throw error;
    }
  }
}

// src/generator.ts
import { Debug as Debug2 } from "@prisma/debug";
import { enginesVersion } from "@prisma/engines-version";
import { ClientEngineType as ClientEngineType4, getClientEngineType as getClientEngineType5, parseEnvValue } from "@prisma/internals";
import { getTsconfig } from "get-tsconfig";
import { match as match2 } from "ts-pattern";

// package.json
var version = "6.16.2";

// src/module-format.ts
function parseModuleFormat(format) {
  switch (format.toLowerCase()) {
    case "cjs":
    case "commonjs":
      return "cjs";
    case "esm":
      return "esm";
    default:
      throw new Error(`Invalid module format: "${format}", expected "esm" or "cjs"`);
  }
}
function parseModuleFormatFromUnknown(value) {
  if (typeof value === "string") {
    return parseModuleFormat(value);
  } else {
    throw new Error(`Invalid module format: ${JSON.stringify(value)}, expected "esm" or "cjs"`);
  }
}
function inferModuleFormat({
  tsconfig,
  generatedFileExtension,
  importFileExtension
}) {
  if (tsconfig?.compilerOptions?.module) {
    return fromTsConfigModule(tsconfig.compilerOptions.module);
  }
  if (generatedFileExtension === "cts" || importFileExtension === "cjs") {
    return "cjs";
  }
  return "esm";
}
function fromTsConfigModule(module) {
  const normalizedModule = module.toLowerCase();
  if (normalizedModule === "commonjs") {
    return "cjs";
  }
  return "esm";
}

// src/runtime-targets.ts
var supportedPublicRuntimes = [
  "nodejs",
  "deno",
  "bun",
  "workerd",
  "cloudflare",
  "vercel-edge",
  "edge-light",
  "react-native"
];
function parseRuntimeTarget(target) {
  switch (target.toLowerCase()) {
    case "workerd":
    case "cloudflare":
      return "workerd";
    case "edge-light":
    case "vercel-edge":
      return "vercel-edge";
    case "nodejs":
    case "bun":
      return "nodejs";
    case "deno":
      return "deno";
    case "react-native":
      return "react-native";
    default:
      throw new Error(
        `Unknown target runtime: "${target}". The available options are: ${supportedPublicRuntimes.map((runtime) => `"${runtime}"`).join(", ")}`
      );
  }
}
function parseRuntimeTargetFromUnknown(target) {
  if (typeof target !== "string") {
    throw new Error(`Invalid target runtime: ${JSON.stringify(target)}. Expected a string.`);
  }
  return parseRuntimeTarget(target);
}

// src/generator.ts
var debug2 = Debug2("prisma:client:generator");
var missingOutputErrorMessage = `An output path is required for the \`prisma-client\` generator. Please provide an output path in your schema file:

${dim(`generator client {
  provider = "prisma-client"`)}
${green('  output   = "../src/generated"')}
${dim("}")}

${bold("Note:")} the output path is relative to the schema directory.
`;
function getOutputPath(config) {
  if (!config.output) {
    throw new Error(missingOutputErrorMessage);
  }
  return parseEnvValue(config.output);
}
var PrismaClientTsGenerator = class {
  name = "prisma-client-ts";
  getManifest(config) {
    const requiresEngines = match2(getClientEngineType5(config)).with(ClientEngineType4.Library, () => ["libqueryEngine"]).with(ClientEngineType4.Binary, () => ["queryEngine"]).with(ClientEngineType4.Client, () => []).exhaustive();
    debug2("requiresEngines", requiresEngines);
    return Promise.resolve({
      defaultOutput: getOutputPath(config),
      prettyName: "Prisma Client",
      version,
      requiresEngines,
      requiresEngineVersion: enginesVersion
    });
  }
  async generate(options) {
    const { config } = options.generator;
    const outputDir = getOutputPath(options.generator);
    const tsconfig = getTsconfig(outputDir)?.config;
    const target = config.runtime !== void 0 ? parseRuntimeTargetFromUnknown(config.runtime) : "nodejs";
    const generatedFileExtension = config.generatedFileExtension !== void 0 ? parseGeneratedFileExtension(config.generatedFileExtension) : "ts";
    const importFileExtension = config.importFileExtension !== void 0 ? parseImportFileExtension(config.importFileExtension) : inferImportFileExtension({
      tsconfig,
      generatedFileExtension,
      target
    });
    const moduleFormat = config.moduleFormat !== void 0 ? parseModuleFormatFromUnknown(config.moduleFormat) : inferModuleFormat({
      tsconfig,
      generatedFileExtension,
      importFileExtension
    });
    await generateClient({
      datamodel: options.datamodel,
      schemaPath: options.schemaPath,
      binaryPaths: options.binaryPaths,
      datasources: options.datasources,
      envPaths: options.envPaths,
      outputDir,
      runtimeBase: "@prisma/client/runtime",
      dmmf: options.dmmf,
      generator: options.generator,
      engineVersion: options.version,
      clientVersion: version,
      activeProvider: options.datasources[0]?.activeProvider,
      postinstall: options.postinstall,
      copyEngine: !options.noEngine,
      typedSql: options.typedSql,
      target,
      generatedFileExtension,
      importFileExtension,
      moduleFormat,
      tsNoCheckPreamble: true
      // Set to false only during internal tests
    });
  }
};
export {
  PrismaClientTsGenerator,
  externalToInternalDmmf,
  generateClient,
  getDMMF
};
