import type { ErrorCapturingSqlDriverAdapterFactory, ErrorRegistry } from '@prisma/driver-adapter-utils';
import { SchemaContext, wasm } from '@prisma/internals';
import { SchemaEngine } from './SchemaEngine';
import { EngineArgs } from './types';
type SchemaEngineMethods = Omit<wasm.SchemaEngineWasm, 'free'>;
export type SchemaEngineInput<M extends keyof SchemaEngineMethods> = Parameters<wasm.SchemaEngineWasm[M]>[0];
export type SchemaEngineOutput<M extends keyof SchemaEngineMethods> = ReturnType<wasm.SchemaEngineWasm[M]>;
interface SchemaEngineWasmSetupInput {
    adapter: ErrorCapturingSqlDriverAdapterFactory;
    enabledPreviewFeatures?: string[];
    schemaContext?: SchemaContext;
}
export interface SchemaEngineWasmOptions extends Omit<SchemaEngineWasmSetupInput, 'adapter'> {
    debug?: boolean;
    engine: wasm.SchemaEngineWasm;
    errorRegistry: ErrorRegistry;
}
/**
 * Wrapper around `@prisma/schema-engine-wasm`, which will eventually replace `SchemaEngineCLI`.
 *
 * TODOs:
 * - Catch and throw "rich" connector errors
 */
export declare class SchemaEngineWasm implements SchemaEngine {
    private engine;
    private errorRegistry;
    private enabledPreviewFeatures?;
    isRunning: boolean;
    private constructor();
    static setup({ adapter, schemaContext, ...rest }: SchemaEngineWasmSetupInput): Promise<SchemaEngineWasm>;
    private runCommand;
    /**
     * Apply the migrations from the migrations directory to the database.
     * This is the command behind prisma migrate deploy.
     */
    applyMigrations(input: SchemaEngineInput<'applyMigrations'>): SchemaEngineOutput<'applyMigrations'>;
    /**
     * Create the next migration in the migrations history.
     * If draft is false and there are no unexecutable steps, it will also apply the newly created migration.
     * Note: This will use the shadow database on the connectors where we need one.
     */
    createMigration(input: SchemaEngineInput<'createMigration'>): SchemaEngineOutput<'createMigration'>;
    /**
     * Execute a database script directly on the specified live database.
     * Note that this may not be defined on all connectors.
     */
    dbExecute(input: SchemaEngineInput<'dbExecute'>): Promise<null>;
    /**
     * Make the Schema engine panic. Only useful to test client error handling.
     */
    debugPanic(): Promise<never>;
    /**
     * The method called at the beginning of migrate dev to decide the course of action,
     * based on the current state of the workspace.
     * It acts as a wrapper around diagnoseMigrationHistory.
     * Its role is to interpret the diagnostic output,
     * and translate it to a concrete action to be performed by the CLI.
     */
    devDiagnostic(input: SchemaEngineInput<'devDiagnostic'>): SchemaEngineOutput<'devDiagnostic'>;
    /**
     * Read the contents of the migrations directory and the migrations table, and returns their relative statuses.
     * At this stage, the Schema engine only reads,
     * it does not write to the database nor the migrations directory, nor does it use a shadow database.
     */
    diagnoseMigrationHistory(input: SchemaEngineInput<'diagnoseMigrationHistory'>): SchemaEngineOutput<'diagnoseMigrationHistory'>;
    /**
     * Make sure the Schema engine can connect to the database from the Prisma schema.
     */
    ensureConnectionValidity(input: SchemaEngineInput<'ensureConnectionValidity'>): Promise<void>;
    /**
     * Development command for migrations.
     * Evaluate the data loss induced by the next migration the engine would generate on the main database.
     */
    evaluateDataLoss(input: SchemaEngineInput<'evaluateDataLoss'>): SchemaEngineOutput<'evaluateDataLoss'>;
    /**
     * Get the database version for error reporting.
     * If no argument is given, the version of the database associated to the Prisma schema provided
     * in the constructor will be returned.
     */
    getDatabaseVersion(input?: SchemaEngineInput<'version'>): SchemaEngineOutput<'version'>;
    /**
     * Given a Prisma schema, introspect the database definitions and update the schema with the results.
     * `compositeTypeDepth` is optional, and only required for MongoDB.
     */
    introspect({ schema, force, baseDirectoryPath, viewsDirectoryPath, compositeTypeDepth, namespaces, }: EngineArgs.IntrospectParams): SchemaEngineOutput<'introspect'>;
    /**
     * Compares two databases schemas from two arbitrary sources,
     * and display the difference as either a human-readable summary,
     * or an executable script that can be passed to dbExecute.
     * Connection to a shadow database is only necessary when either the from or the to params is a migrations directory.
     * Diffs have a direction. Which source is from and which is to matters.
     * The resulting diff should be thought of as a migration from the schema in `args.from` to the schema in `args.to`.
     * By default, we output a human-readable diff. If you want an executable script, pass the "script": true param.
     */
    migrateDiff(input: SchemaEngineInput<'diff'>): Promise<{
        exitCode: number;
    }>;
    /**
     * Mark a migration as applied in the migrations table.
     * There are two possible outcomes:
     * - The migration is already in the table, but in a failed state. In this case, we will mark it as rolled back, then create a new entry.
     * - The migration is not in the table. We will create a new entry in the migrations table. The started_at and finished_at will be the same.
     * If it is already applied, we return a user-facing error.
     */
    markMigrationApplied(input: SchemaEngineInput<'markMigrationApplied'>): Promise<void>;
    /**
     * Mark an existing failed migration as rolled back in the migrations table. It will still be there, but ignored for all purposes except as audit trail.
     */
    markMigrationRolledBack(input: SchemaEngineInput<'markMigrationRolledBack'>): Promise<void>;
    /**
     * Try to make the database empty: no data and no schema.
     * On most connectors, this is implemented by dropping and recreating the database.
     * If that fails (most likely because of insufficient permissions),
     * the engine attempts a “best effort reset” by inspecting the contents of the database and dropping them individually.
     * Drop and recreate the database. The migrations will not be applied, as it would overlap with applyMigrations.
     */
    reset(input: SchemaEngineInput<'reset'>): Promise<void>;
    /**
     * The command behind db push.
     */
    schemaPush(input: SchemaEngineInput<'schemaPush'>): SchemaEngineOutput<'schemaPush'>;
    /**
     * SQL introspection that powers TypedSQL feature
     * @param args
     * @returns
     */
    introspectSql(input: SchemaEngineInput<'introspectSql'>): SchemaEngineOutput<'introspectSql'>;
    /**
     * Stop the engine.
     */
    stop(): Promise<void>;
}
export {};
