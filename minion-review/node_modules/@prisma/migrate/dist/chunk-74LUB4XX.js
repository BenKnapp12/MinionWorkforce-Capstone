"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_74LUB4XX_exports = {};
__export(chunk_74LUB4XX_exports, {
  ensureCanConnectToDatabase: () => ensureCanConnectToDatabase,
  ensureDatabaseExists: () => ensureDatabaseExists,
  getDbLocation: () => getDbLocation,
  parseDatasourceInfo: () => parseDatasourceInfo,
  prettifyProvider: () => prettifyProvider
});
module.exports = __toCommonJS(chunk_74LUB4XX_exports);
var import_chunk_TWPTG4XS = require("./chunk-TWPTG4XS.js");
var import_chunk_SKRR5WT4 = require("./chunk-SKRR5WT4.js");
var import_internals = require("@prisma/internals");
var import_path = __toESM(require("path"));
function parseDatasourceInfo(datasource) {
  if (!datasource) {
    return {
      name: void 0,
      prettyProvider: void 0,
      dbName: void 0,
      dbLocation: void 0,
      url: void 0,
      schema: void 0,
      schemas: void 0,
      configDir: void 0
    };
  }
  const prettyProvider = prettifyProvider(datasource.provider);
  const url = (0, import_internals.getEffectiveUrl)(datasource).value;
  if (!url || datasource.provider === "sqlserver") {
    return {
      name: datasource.name,
      prettyProvider,
      dbName: void 0,
      dbLocation: void 0,
      url: url || void 0,
      schema: void 0,
      schemas: datasource.schemas,
      configDir: import_path.default.dirname(datasource.sourceFilePath)
    };
  }
  try {
    const credentials = (0, import_internals.uriToCredentials)(url);
    const dbLocation = getDbLocation(credentials);
    let schema = void 0;
    if (["postgresql", "cockroachdb"].includes(datasource.provider)) {
      if (credentials.schema) {
        schema = credentials.schema;
      } else {
        schema = "public";
      }
    }
    const datasourceInfo = {
      name: datasource.name,
      prettyProvider,
      dbName: credentials.database,
      dbLocation,
      url,
      schema,
      schemas: datasource.schemas,
      configDir: import_path.default.dirname(datasource.sourceFilePath)
    };
    if (datasource.provider === "postgresql" && datasourceInfo.dbName === void 0) {
      datasourceInfo.dbName = "postgres";
    }
    return datasourceInfo;
  } catch (e) {
    return {
      name: datasource.name,
      prettyProvider,
      dbName: void 0,
      dbLocation: void 0,
      url,
      schema: void 0,
      schemas: datasource.schemas,
      configDir: import_path.default.dirname(datasource.sourceFilePath)
    };
  }
}
async function ensureCanConnectToDatabase(datasource) {
  if (!datasource) {
    throw new Error(`A datasource block is missing in the Prisma schema file.`);
  }
  const schemaDir = import_path.default.dirname(datasource.sourceFilePath);
  const url = getConnectionUrl(datasource);
  const canConnect = await (0, import_internals.canConnectToDatabase)(url, schemaDir);
  if (canConnect === true) {
    return true;
  } else {
    const { code, message } = canConnect;
    throw new Error(`${code}: ${message}`);
  }
}
async function ensureDatabaseExists(datasource) {
  if (!datasource) {
    throw new Error(`A datasource block is missing in the Prisma schema file.`);
  }
  const schemaDir = import_path.default.dirname(datasource.sourceFilePath);
  const url = getConnectionUrl(datasource);
  const canConnect = await (0, import_internals.canConnectToDatabase)(url, schemaDir);
  if (canConnect === true) {
    return;
  }
  const { code, message } = canConnect;
  if (code !== "P1003") {
    throw new Error(`${code}: ${message}`);
  }
  if (await (0, import_internals.createDatabase)(url, schemaDir)) {
    if (datasource.provider === "sqlserver") {
      return `SQL Server database created.
`;
    }
    const credentials = (0, import_internals.uriToCredentials)(url);
    const prettyProvider = prettifyProvider(datasource.provider);
    let message2 = `${prettyProvider} database${credentials.database ? ` ${credentials.database} ` : " "}created`;
    const dbLocation = getDbLocation(credentials);
    if (dbLocation) {
      message2 += ` at ${(0, import_chunk_SKRR5WT4.bold)(dbLocation)}`;
    }
    return message2;
  }
  return void 0;
}
function getDbLocation(credentials) {
  if (credentials.type === "sqlite") {
    return credentials.uri;
  }
  const socket = (0, import_chunk_TWPTG4XS.getSocketFromDatabaseCredentials)(credentials);
  if (socket) {
    return `unix:${socket}`;
  } else if (credentials.host && credentials.port) {
    return `${credentials.host}:${credentials.port}`;
  } else if (credentials.host) {
    return `${credentials.host}`;
  }
  return void 0;
}
function prettifyProvider(provider) {
  switch (provider) {
    case "mysql":
      return `MySQL`;
    case "postgres":
    case "postgresql":
      return `PostgreSQL`;
    case import_internals.PRISMA_POSTGRES_PROVIDER:
      return `Prisma Postgres`;
    case "sqlite":
      return `SQLite`;
    case "cockroachdb":
      return `CockroachDB`;
    case "sqlserver":
      return `SQL Server`;
    case "mongodb":
      return `MongoDB`;
  }
}
function getConnectionUrl(datasource) {
  const url = (0, import_internals.getEffectiveUrl)(datasource);
  if (!url.value) {
    if (url.fromEnvVar) {
      throw new Error(`Environment variable '${url.fromEnvVar}' with database connection URL was not found.`);
    } else {
      throw new Error(`Datasource is missing a database connection URL.`);
    }
  }
  return url.value;
}
