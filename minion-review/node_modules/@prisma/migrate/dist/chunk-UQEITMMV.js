"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_UQEITMMV_exports = {};
__export(chunk_UQEITMMV_exports, {
  DbPull: () => DbPull
});
module.exports = __toCommonJS(chunk_UQEITMMV_exports);
var import_chunk_IINN7QUV = require("./chunk-IINN7QUV.js");
var import_chunk_JZ75RIMZ = require("./chunk-JZ75RIMZ.js");
var import_chunk_RR6BKMNO = require("./chunk-RR6BKMNO.js");
var import_chunk_RTGQXNX6 = require("./chunk-RTGQXNX6.js");
var import_chunk_JFKDSUIE = require("./chunk-JFKDSUIE.js");
var import_chunk_AI6DH66U = require("./chunk-AI6DH66U.js");
var import_chunk_AHJ2N6BJ = require("./chunk-AHJ2N6BJ.js");
var import_chunk_LGYRZ6CV = require("./chunk-LGYRZ6CV.js");
var import_chunk_3WC4XD74 = require("./chunk-3WC4XD74.js");
var import_chunk_2FXU5NZQ = require("./chunk-2FXU5NZQ.js");
var import_chunk_74LUB4XX = require("./chunk-74LUB4XX.js");
var import_chunk_F3JIZWIS = require("./chunk-F3JIZWIS.js");
var import_chunk_AXR7LS2N = require("./chunk-AXR7LS2N.js");
var import_chunk_SKRR5WT4 = require("./chunk-SKRR5WT4.js");
var import_debug = __toESM(require("@prisma/debug"));
var import_internals = require("@prisma/internals");
var import_path = __toESM(require("path"));
var debug = (0, import_debug.default)("prisma:db:pull");
var DbPull = class _DbPull {
  static new() {
    return new _DbPull();
  }
  static help = (0, import_internals.format)(`
Pull the state from the database to the Prisma schema using introspection

${(0, import_chunk_SKRR5WT4.bold)("Usage")}

  ${(0, import_chunk_SKRR5WT4.dim)("$")} prisma db pull [flags/options]

${(0, import_chunk_SKRR5WT4.bold)("Flags")}

              -h, --help   Display this help message
                 --force   Ignore current Prisma schema file
                 --print   Print the introspected Prisma schema to stdout

${(0, import_chunk_SKRR5WT4.bold)("Options")}

                --config   Custom path to your Prisma config file
                --schema   Custom path to your Prisma schema
  --composite-type-depth   Specify the depth for introspecting composite types (e.g. Embedded Documents in MongoDB)
                           Number, default is -1 for infinite depth, 0 = off
               --schemas   Specify the database schemas to introspect. This overrides the schemas defined in the datasource block of your Prisma schema.
              --local-d1   Generate a Prisma schema from a local Cloudflare D1 database
${(0, import_chunk_SKRR5WT4.bold)("Examples")}

With an existing Prisma schema
  ${(0, import_chunk_SKRR5WT4.dim)("$")} prisma db pull

Or specify a Prisma schema path
  ${(0, import_chunk_SKRR5WT4.dim)("$")} prisma db pull --schema=./schema.prisma

Instead of saving the result to the filesystem, you can also print it to stdout
  ${(0, import_chunk_SKRR5WT4.dim)("$")} prisma db pull --print

Overwrite the current schema with the introspected schema instead of enriching it
  ${(0, import_chunk_SKRR5WT4.dim)("$")} prisma db pull --force

Set composite types introspection depth to 2 levels
  ${(0, import_chunk_SKRR5WT4.dim)("$")} prisma db pull --composite-type-depth=2

`);
  urlToDatasource(url, defaultProvider) {
    const provider = defaultProvider || (0, import_internals.protocolToConnectorType)(`${url.split(":")[0]}:`);
    return (0, import_chunk_AI6DH66U.printDatasources)([
      {
        config: {},
        provider,
        name: "db",
        url
      }
    ]);
  }
  async parse(argv, config) {
    const args = (0, import_internals.arg)(argv, {
      "--help": Boolean,
      "-h": "--help",
      "--url": String,
      "--print": Boolean,
      "--schema": String,
      "--config": String,
      "--schemas": String,
      "--force": Boolean,
      "--composite-type-depth": Number,
      // optional, only on mongodb
      "--local-d1": Boolean
      // optional, only on cloudflare D1
    });
    const spinnerFactory = (0, import_chunk_IINN7QUV.createSpinner)(!args["--print"]);
    if (args instanceof Error) {
      return this.help(args.message);
    }
    if (args["--help"]) {
      return this.help();
    }
    const url = args["--url"];
    await (0, import_internals.loadEnvFile)({ schemaPath: args["--schema"], printMessage: !args["--print"], config });
    const schemaContext = await (0, import_internals.loadSchemaContext)({
      schemaPathFromArg: args["--schema"],
      schemaPathFromConfig: config.schema,
      printLoadMessage: false,
      allowNull: true
    });
    const cmd = "db pull";
    (0, import_internals.checkUnsupportedDataProxy)({
      cmd,
      schemaContext: schemaContext && !url ? schemaContext : void 0,
      urls: [url]
    });
    (0, import_internals.checkUnsupportedSchemaEngineWasm)({
      cmd,
      config,
      args,
      flags: ["--url", "--local-d1"]
    });
    const adapter = await config.adapter?.();
    if (schemaContext && !args["--print"]) {
      (0, import_internals.printSchemaLoadedMessage)(schemaContext.loadedFromPathForLogMessages);
      (0, import_chunk_2FXU5NZQ.printDatasource)({ datasourceInfo: (0, import_chunk_74LUB4XX.parseDatasourceInfo)(schemaContext?.primaryDatasource), adapter });
    }
    const fromD1 = Boolean(args["--local-d1"]);
    if (!url && !schemaContext && !fromD1) {
      throw new import_chunk_3WC4XD74.NoSchemaFoundError();
    }
    const { firstDatasource, schema, validationWarning } = await (0, import_chunk_AXR7LS2N.z)({ url, schemaContext, fromD1 }).when(
      (input) => input.schemaContext !== null,
      async (input) => {
        const firstDatasource2 = input.schemaContext.primaryDatasource ? input.schemaContext.primaryDatasource : void 0;
        if (input.url) {
          let providerFromSchema = firstDatasource2?.provider;
          if (providerFromSchema === "postgres") {
            providerFromSchema = "postgresql";
          }
          const providerFromUrl = (0, import_internals.protocolToConnectorType)(`${input.url.split(":")[0]}:`);
          const schema2 = (0, import_chunk_RR6BKMNO.replaceOrAddDatasource)(
            this.urlToDatasource(input.url, providerFromSchema),
            input.schemaContext.schemaFiles
          );
          if (providerFromSchema && providerFromUrl && providerFromSchema !== providerFromUrl && Boolean(providerFromSchema === "cockroachdb" && providerFromUrl === "postgresql") === false) {
            throw new Error(
              `The database provider found in --url (${providerFromUrl}) is different from the provider found in the Prisma schema (${providerFromSchema}).`
            );
          }
          return { firstDatasource: firstDatasource2, schema: schema2, validationWarning: void 0 };
        } else if (input.fromD1) {
          const d1Database = await (0, import_internals.locateLocalCloudflareD1)({ arg: "--from-local-d1" });
          const pathToSQLiteFile = import_path.default.relative(input.schemaContext.schemaRootDir, d1Database);
          const schema2 = [
            ["schema.prisma", this.urlToDatasource(`file:${pathToSQLiteFile}`, "sqlite")]
          ];
          const config2 = await (0, import_internals.getConfig)({
            datamodel: schema2,
            ignoreEnvVarErrors: true
          });
          return { firstDatasource: config2.datasources[0], schema: schema2, validationWarning: void 0 };
        } else {
          await (0, import_internals.getConfig)({
            datamodel: input.schemaContext.schemaFiles,
            ignoreEnvVarErrors: false
          });
        }
        return { firstDatasource: firstDatasource2, schema: input.schemaContext.schemaFiles, validationWarning: void 0 };
      }
    ).when(
      (input) => input.fromD1 === true,
      async (_) => {
        const d1Database = await (0, import_internals.locateLocalCloudflareD1)({ arg: "--from-local-d1" });
        const pathToSQLiteFile = import_path.default.relative(process.cwd(), d1Database);
        const schemaContent = `generator client {
  provider        = "prisma-client-js"
}
${this.urlToDatasource(`file:${pathToSQLiteFile}`, "sqlite")}`;
        const schema2 = [["schema.prisma", schemaContent]];
        const config2 = await (0, import_internals.getConfig)({
          datamodel: schema2,
          ignoreEnvVarErrors: true
        });
        return { firstDatasource: config2.datasources[0], schema: schema2, validationWarning: void 0 };
      }
    ).when(
      (input) => input.url !== void 0,
      async (input) => {
        (0, import_internals.protocolToConnectorType)(`${input.url.split(":")[0]}:`);
        const schema2 = [["schema.prisma", this.urlToDatasource(input.url)]];
        const config2 = await (0, import_internals.getConfig)({
          datamodel: schema2,
          ignoreEnvVarErrors: true
        });
        return { firstDatasource: config2.datasources[0], schema: schema2, validationWarning: void 0 };
      }
    ).run();
    if (schemaContext) {
      const modelRegex = /\s*model\s*(\w+)\s*{/;
      const isReintrospection = schemaContext.schemaFiles.some(([_, schema2]) => !!modelRegex.exec(schema2));
      if (isReintrospection && !args["--force"] && firstDatasource?.provider === "mongodb") {
        throw new Error(`Iterating on one schema using re-introspection with db pull is currently not supported with MongoDB provider.
You can explicitly ignore and override your current local schema file with ${(0, import_chunk_SKRR5WT4.green)(
          (0, import_internals.getCommandWithExecutor)("prisma db pull --force")
        )}
Some information will be lost (relations, comments, mapped fields, @ignore...), follow ${(0, import_internals.link)(
          "https://github.com/prisma/prisma/issues/9585"
        )} for more info.`);
      }
    }
    const migrate = await import_chunk_F3JIZWIS.Migrate.setup({ adapter, schemaContext: schemaContext ?? void 0 });
    const engine = migrate.engine;
    const basedOn = !args["--url"] && schemaContext?.primaryDatasource ? ` based on datasource defined in ${(0, import_chunk_SKRR5WT4.underline)(schemaContext.loadedFromPathForLogMessages)}` : "";
    const introspectionSpinner = spinnerFactory(`Introspecting${basedOn}`);
    const before = Math.round(performance.now());
    let introspectionSchema = void 0;
    let introspectionWarnings;
    try {
      const directoryConfig = (0, import_internals.inferDirectoryConfig)(schemaContext, config);
      const introspectionResult = await engine.introspect({
        schema: (0, import_internals.toSchemasContainer)(schema),
        baseDirectoryPath: schemaContext?.schemaRootDir ?? process.cwd(),
        viewsDirectoryPath: directoryConfig.viewsDirPath,
        force: args["--force"],
        compositeTypeDepth: args["--composite-type-depth"],
        namespaces: args["--schemas"]?.split(",")
      });
      introspectionSchema = introspectionResult.schema;
      introspectionWarnings = introspectionResult.warnings;
      debug(`Introspection warnings`, introspectionWarnings);
    } catch (e) {
      introspectionSpinner.failure();
      if (e.code === "P4001" && (0, import_chunk_JFKDSUIE.isSchemaEmpty)(introspectionSchema)) {
        throw new Error(`
${(0, import_chunk_SKRR5WT4.red)((0, import_chunk_SKRR5WT4.bold)(`${e.code} `))}${(0, import_chunk_SKRR5WT4.red)("The introspected database was empty:")}

${(0, import_chunk_SKRR5WT4.bold)("prisma db pull")} could not create any models in your ${(0, import_chunk_SKRR5WT4.bold)(
          "schema.prisma"
        )} file and you will not be able to generate Prisma Client with the ${(0, import_chunk_SKRR5WT4.bold)(
          (0, import_internals.getCommandWithExecutor)("prisma generate")
        )} command.

${(0, import_chunk_SKRR5WT4.bold)("To fix this, you have two options:")}

- manually create a table in your database.
- make sure the database connection URL inside the ${(0, import_chunk_SKRR5WT4.bold)("datasource")} block in ${(0, import_chunk_SKRR5WT4.bold)(
          "schema.prisma"
        )} points to a database that is not empty (it must contain at least one table).

Then you can run ${(0, import_chunk_SKRR5WT4.green)((0, import_internals.getCommandWithExecutor)("prisma db pull"))} again. 
`);
      } else if (e.code === "P1003") {
        throw new Error(`
${(0, import_chunk_SKRR5WT4.red)((0, import_chunk_SKRR5WT4.bold)(`${e.code} `))}${(0, import_chunk_SKRR5WT4.red)("The introspected database does not exist:")}

${(0, import_chunk_SKRR5WT4.bold)("prisma db pull")} could not create any models in your ${(0, import_chunk_SKRR5WT4.bold)(
          "schema.prisma"
        )} file and you will not be able to generate Prisma Client with the ${(0, import_chunk_SKRR5WT4.bold)(
          (0, import_internals.getCommandWithExecutor)("prisma generate")
        )} command.

${(0, import_chunk_SKRR5WT4.bold)("To fix this, you have two options:")}

- manually create a database.
- make sure the database connection URL inside the ${(0, import_chunk_SKRR5WT4.bold)("datasource")} block in ${(0, import_chunk_SKRR5WT4.bold)(
          "schema.prisma"
        )} points to an existing database.

Then you can run ${(0, import_chunk_SKRR5WT4.green)((0, import_internals.getCommandWithExecutor)("prisma db pull"))} again. 
`);
      } else if (e.code === "P1012") {
        process.stdout.write("\n");
        const message = (0, import_internals.relativizePathInPSLError)(e.message);
        throw new Error(`${(0, import_chunk_SKRR5WT4.red)(message)}
Introspection failed as your current Prisma schema file is invalid

Please fix your current schema manually (using either ${(0, import_chunk_SKRR5WT4.green)(
          (0, import_internals.getCommandWithExecutor)("prisma validate")
        )} or the Prisma VS Code extension to understand what's broken and confirm you fixed it), and then run this command again.
Or run this command with the ${(0, import_chunk_SKRR5WT4.green)(
          "--force"
        )} flag to ignore your current schema and overwrite it. All local modifications will be lost.
`);
      }
      process.stdout.write("\n");
      throw e;
    }
    const introspectionWarningsMessage = this.getWarningMessage(introspectionWarnings);
    if (args["--print"]) {
      (0, import_chunk_AHJ2N6BJ.printIntrospectedSchema)(introspectionSchema, process.stdout);
      if (introspectionWarningsMessage.trim().length > 0) {
        console.error(introspectionWarningsMessage.replace(/(\n)/gm, "\n// "));
      }
    } else {
      if (args["--force"]) {
        await (0, import_chunk_JZ75RIMZ.removeSchemaFiles)(schema);
      }
      await (0, import_chunk_RTGQXNX6.saveSchemaFiles)(introspectionSchema);
      const { modelsCount, typesCount } = (0, import_chunk_LGYRZ6CV.countModelsAndTypes)(introspectionSchema);
      const modelsCountMessage = `${modelsCount} ${modelsCount > 1 ? "models" : "model"}`;
      const typesCountMessage = `${typesCount} ${typesCount > 1 ? "embedded documents" : "embedded document"}`;
      let modelsAndTypesMessage;
      if (typesCount > 0) {
        modelsAndTypesMessage = `${modelsCountMessage} and ${typesCountMessage}`;
      } else {
        modelsAndTypesMessage = `${modelsCountMessage}`;
      }
      const modelsAndTypesCountMessage = modelsCount + typesCount > 1 ? `${modelsAndTypesMessage} and wrote them` : `${modelsAndTypesMessage} and wrote it`;
      const renderValidationWarning = validationWarning ? `
${(0, import_chunk_SKRR5WT4.yellow)(validationWarning)}` : "";
      const introspectedSchemaPath = schemaContext?.loadedFromPathForLogMessages || introspectionSchema.files[0].path;
      introspectionSpinner.success(`Introspected ${modelsAndTypesCountMessage} into ${(0, import_chunk_SKRR5WT4.underline)(
        import_path.default.relative(process.cwd(), introspectedSchemaPath)
      )} in ${(0, import_chunk_SKRR5WT4.bold)((0, import_internals.formatms)(Math.round(performance.now()) - before))}
      ${(0, import_chunk_SKRR5WT4.yellow)(introspectionWarningsMessage)}
${`Run ${(0, import_chunk_SKRR5WT4.green)((0, import_internals.getCommandWithExecutor)("prisma generate"))} to generate Prisma Client.`}${renderValidationWarning}`);
    }
    return "";
  }
  getWarningMessage(warnings) {
    if (warnings) {
      return `
${warnings}`;
    }
    return "";
  }
  help(error) {
    if (error) {
      return new import_internals.HelpError(`
${(0, import_chunk_SKRR5WT4.bold)((0, import_chunk_SKRR5WT4.red)(`!`))} ${error}
${_DbPull.help}`);
    }
    return _DbPull.help;
  }
};
