"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_DYXEUKV3_exports = {};
__export(chunk_DYXEUKV3_exports, {
  DbSeed: () => DbSeed
});
module.exports = __toCommonJS(chunk_DYXEUKV3_exports);
var import_chunk_HFXUQT52 = require("./chunk-HFXUQT52.js");
var import_chunk_SKRR5WT4 = require("./chunk-SKRR5WT4.js");
var import_chunk_2ESYSVXG = require("./chunk-2ESYSVXG.js");
var import_internals = require("@prisma/internals");
var require_arg = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/arg@5.0.2/node_modules/arg/index.js"(exports, module2) {
    "use strict";
    var flagSymbol = Symbol("arg flag");
    var ArgError2 = class _ArgError extends Error {
      constructor(msg, code) {
        super(msg);
        this.name = "ArgError";
        this.code = code;
        Object.setPrototypeOf(this, _ArgError.prototype);
      }
    };
    function arg2(opts, {
      argv = process.argv.slice(2),
      permissive = false,
      stopAtPositional = false
    } = {}) {
      if (!opts) {
        throw new ArgError2(
          "argument specification object is required",
          "ARG_CONFIG_NO_SPEC"
        );
      }
      const result = { _: [] };
      const aliases = {};
      const handlers = {};
      for (const key of Object.keys(opts)) {
        if (!key) {
          throw new ArgError2(
            "argument key cannot be an empty string",
            "ARG_CONFIG_EMPTY_KEY"
          );
        }
        if (key[0] !== "-") {
          throw new ArgError2(
            `argument key must start with '-' but found: '${key}'`,
            "ARG_CONFIG_NONOPT_KEY"
          );
        }
        if (key.length === 1) {
          throw new ArgError2(
            `argument key must have a name; singular '-' keys are not allowed: ${key}`,
            "ARG_CONFIG_NONAME_KEY"
          );
        }
        if (typeof opts[key] === "string") {
          aliases[key] = opts[key];
          continue;
        }
        let type = opts[key];
        let isFlag = false;
        if (Array.isArray(type) && type.length === 1 && typeof type[0] === "function") {
          const [fn] = type;
          type = (value, name, prev = []) => {
            prev.push(fn(value, name, prev[prev.length - 1]));
            return prev;
          };
          isFlag = fn === Boolean || fn[flagSymbol] === true;
        } else if (typeof type === "function") {
          isFlag = type === Boolean || type[flagSymbol] === true;
        } else {
          throw new ArgError2(
            `type missing or not a function or valid array type: ${key}`,
            "ARG_CONFIG_VAD_TYPE"
          );
        }
        if (key[1] !== "-" && key.length > 2) {
          throw new ArgError2(
            `short argument keys (with a single hyphen) must have only one character: ${key}`,
            "ARG_CONFIG_SHORTOPT_TOOLONG"
          );
        }
        handlers[key] = [type, isFlag];
      }
      for (let i = 0, len = argv.length; i < len; i++) {
        const wholeArg = argv[i];
        if (stopAtPositional && result._.length > 0) {
          result._ = result._.concat(argv.slice(i));
          break;
        }
        if (wholeArg === "--") {
          result._ = result._.concat(argv.slice(i + 1));
          break;
        }
        if (wholeArg.length > 1 && wholeArg[0] === "-") {
          const separatedArguments = wholeArg[1] === "-" || wholeArg.length === 2 ? [wholeArg] : wholeArg.slice(1).split("").map((a) => `-${a}`);
          for (let j = 0; j < separatedArguments.length; j++) {
            const arg3 = separatedArguments[j];
            const [originalArgName, argStr] = arg3[1] === "-" ? arg3.split(/=(.*)/, 2) : [arg3, void 0];
            let argName = originalArgName;
            while (argName in aliases) {
              argName = aliases[argName];
            }
            if (!(argName in handlers)) {
              if (permissive) {
                result._.push(arg3);
                continue;
              } else {
                throw new ArgError2(
                  `unknown or unexpected option: ${originalArgName}`,
                  "ARG_UNKNOWN_OPTION"
                );
              }
            }
            const [type, isFlag] = handlers[argName];
            if (!isFlag && j + 1 < separatedArguments.length) {
              throw new ArgError2(
                `option requires argument (but was followed by another short argument): ${originalArgName}`,
                "ARG_MISSING_REQUIRED_SHORTARG"
              );
            }
            if (isFlag) {
              result[argName] = type(true, argName, result[argName]);
            } else if (argStr === void 0) {
              if (argv.length < i + 2 || argv[i + 1].length > 1 && argv[i + 1][0] === "-" && !(argv[i + 1].match(/^-?\d*(\.(?=\d))?\d*$/) && (type === Number || // eslint-disable-next-line no-undef
              typeof BigInt !== "undefined" && type === BigInt))) {
                const extended = originalArgName === argName ? "" : ` (alias for ${argName})`;
                throw new ArgError2(
                  `option requires argument: ${originalArgName}${extended}`,
                  "ARG_MISSING_REQUIRED_LONGARG"
                );
              }
              result[argName] = type(argv[i + 1], argName, result[argName]);
              ++i;
            } else {
              result[argName] = type(argStr, argName, result[argName]);
            }
          }
        } else {
          result._.push(wholeArg);
        }
      }
      return result;
    }
    arg2.flag = (fn) => {
      fn[flagSymbol] = true;
      return fn;
    };
    arg2.COUNT = arg2.flag((v, name, existingCount) => (existingCount || 0) + 1);
    arg2.ArgError = ArgError2;
    module2.exports = arg2;
  }
});
var import_arg = (0, import_chunk_2ESYSVXG.__toESM)(require_arg());
var DbSeed = class _DbSeed {
  static new() {
    return new _DbSeed();
  }
  static help = (0, import_internals.format)(`
${process.platform === "win32" ? "" : "\u{1F64C}  "}Seed your database

${(0, import_chunk_SKRR5WT4.bold)("Usage")}

  ${(0, import_chunk_SKRR5WT4.dim)("$")} prisma db seed [options]

${(0, import_chunk_SKRR5WT4.bold)("Options")}

  -h, --help   Display this help message
    --config   Custom path to your Prisma config file

${(0, import_chunk_SKRR5WT4.bold)("Examples")}

  Passing extra arguments to the seed command
    ${(0, import_chunk_SKRR5WT4.dim)("$")} prisma db seed -- --arg1 value1 --arg2 value2
`);
  async parse(argv, config) {
    const args = (0, import_internals.arg)(
      argv,
      {
        "--help": Boolean,
        "-h": "--help",
        "--schema": String,
        "--config": String,
        "--telemetry-information": String
      },
      false
    );
    if ((0, import_internals.isError)(args)) {
      if (args instanceof import_arg.ArgError && args.code === "ARG_UNKNOWN_OPTION") {
        throw new Error(`${args.message}
Did you mean to pass these as arguments to your seed script? If so, add a -- separator before them:
${(0, import_chunk_SKRR5WT4.dim)("$")} prisma db seed -- --arg1 value1 --arg2 value2`);
      }
      return this.help(args.message);
    }
    if (args["--help"]) {
      return this.help();
    }
    await (0, import_internals.loadEnvFile)({ schemaPath: args["--schema"], printMessage: true, config });
    const seedCommandFromPrismaConfig = config.migrations?.seed;
    const seedCommandFromPkgJson = await (0, import_chunk_HFXUQT52.getSeedCommandFromPackageJson)(process.cwd());
    const seedCommand = seedCommandFromPrismaConfig ?? seedCommandFromPkgJson;
    if (!seedCommand) return ``;
    const extraArgs = args._.join(" ");
    const successfulSeeding = await (0, import_chunk_HFXUQT52.executeSeedCommand)({ commandFromConfig: seedCommand, extraArgs });
    if (successfulSeeding) {
      return `
${process.platform === "win32" ? "" : "\u{1F331}  "}The seed command has been executed.`;
    } else {
      process.exit(1);
    }
  }
  help(error) {
    if (error) {
      return new import_internals.HelpError(`
${(0, import_chunk_SKRR5WT4.bold)((0, import_chunk_SKRR5WT4.red)(`!`))} ${error}
${_DbSeed.help}`);
    }
    return _DbSeed.help;
  }
};
