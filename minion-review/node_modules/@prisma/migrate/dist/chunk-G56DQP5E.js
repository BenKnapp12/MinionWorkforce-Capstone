"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_G56DQP5E_exports = {};
__export(chunk_G56DQP5E_exports, {
  introspectSql: () => introspectSql
});
module.exports = __toCommonJS(chunk_G56DQP5E_exports);
var import_chunk_F3JIZWIS = require("./chunk-F3JIZWIS.js");
var import_internals = require("@prisma/internals");
var supportedProviders = ["postgresql", "cockroachdb", "mysql", "sqlite"];
async function introspectSql(schemaContext, queries) {
  if (!isTypedSqlEnabled(schemaContext.generators)) {
    throw new Error(`\`typedSql\` preview feature needs to be enabled in ${schemaContext.loadedFromPathForLogMessages}`);
  }
  const firstDatasource = schemaContext.primaryDatasource;
  if (!firstDatasource) {
    throw new Error(`Could not find datasource in schema ${schemaContext.loadedFromPathForLogMessages}`);
  }
  if (!supportedProviders.includes(firstDatasource.activeProvider)) {
    throw new Error(`Typed SQL is supported only for ${supportedProviders.join(", ")} providers`);
  }
  const url = (0, import_internals.getEffectiveUrl)(firstDatasource).value;
  if (!url) {
    throw new Error(
      `Could not get url from datasource ${firstDatasource.name} in ${schemaContext.loadedFromPathForLogMessages}`
    );
  }
  const migrate = await import_chunk_F3JIZWIS.Migrate.setup({ schemaContext });
  const schemaEngine = migrate.engine;
  const results = [];
  const errors = [];
  try {
    for (const query of queries) {
      const queryResult = await introspectSingleQuery(schemaEngine, url, query);
      if (queryResult.ok) {
        results.push(queryResult.result);
      } else {
        errors.push(queryResult.error);
      }
    }
  } finally {
    await schemaEngine.stop();
  }
  if (errors.length > 0) {
    return { ok: false, errors };
  }
  return { ok: true, queries: results };
}
async function introspectSingleQuery(schemaEngine, url, query) {
  try {
    const result = await schemaEngine.introspectSql({
      url,
      queries: [query]
    });
    const queryResult = result.queries[0];
    if (!queryResult) {
      return {
        ok: false,
        error: {
          fileName: query.fileName,
          message: "Invalid response from schema engine"
        }
      };
    }
    return {
      ok: true,
      result: queryResult
    };
  } catch (error) {
    return {
      ok: false,
      error: {
        fileName: query.fileName,
        message: String(error)
      }
    };
  }
}
function isTypedSqlEnabled(generators) {
  return generators.some((gen) => gen?.previewFeatures?.includes("typedSql"));
}
