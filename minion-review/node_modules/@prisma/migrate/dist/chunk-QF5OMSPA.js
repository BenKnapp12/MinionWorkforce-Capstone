"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_QF5OMSPA_exports = {};
__export(chunk_QF5OMSPA_exports, {
  MigrateDiff: () => MigrateDiff
});
module.exports = __toCommonJS(chunk_QF5OMSPA_exports);
var import_chunk_VAJ4VX67 = require("./chunk-VAJ4VX67.js");
var import_chunk_F3JIZWIS = require("./chunk-F3JIZWIS.js");
var import_chunk_GGA2F64G = require("./chunk-GGA2F64G.js");
var import_chunk_SKRR5WT4 = require("./chunk-SKRR5WT4.js");
var import_chunk_2ESYSVXG = require("./chunk-2ESYSVXG.js");
var import_debug = __toESM(require("@prisma/debug"));
var import_internals = require("@prisma/internals");
var import_path = __toESM(require("path"));
var import_config = require("@prisma/config");
var import_debug2 = require("@prisma/debug");
var import_fs = __toESM(require("fs"));
var import_path2 = __toESM(require("path"));
var import_util = require("util");
var require_promisify = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/promisify.js"(exports, module2) {
    "use strict";
    module2.exports = (fn) => {
      return function() {
        const length = arguments.length;
        const args = new Array(length);
        for (let i = 0; i < length; i += 1) {
          args[i] = arguments[i];
        }
        return new Promise((resolve, reject) => {
          args.push((err, data) => {
            if (err) {
              reject(err);
            } else {
              resolve(data);
            }
          });
          fn.apply(null, args);
        });
      };
    };
  }
});
var require_fs = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/fs.js"(exports, module2) {
    "use strict";
    var fs3 = (0, import_chunk_2ESYSVXG.__require)("fs");
    var promisify2 = require_promisify();
    var isCallbackMethod = (key) => {
      return [
        typeof fs3[key] === "function",
        !key.match(/Sync$/),
        !key.match(/^[A-Z]/),
        !key.match(/^create/),
        !key.match(/^(un)?watch/)
      ].every(Boolean);
    };
    var adaptMethod = (name) => {
      const original = fs3[name];
      return promisify2(original);
    };
    var adaptAllMethods = () => {
      const adapted = {};
      Object.keys(fs3).forEach((key) => {
        if (isCallbackMethod(key)) {
          if (key === "exists") {
            adapted.exists = () => {
              throw new Error("fs.exists() is deprecated");
            };
          } else {
            adapted[key] = adaptMethod(key);
          }
        } else {
          adapted[key] = fs3[key];
        }
      });
      return adapted;
    };
    module2.exports = adaptAllMethods();
  }
});
var require_validate = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/validate.js"(exports, module2) {
    "use strict";
    var prettyPrintTypes = (types) => {
      const addArticle = (str) => {
        const vowels = ["a", "e", "i", "o", "u"];
        if (vowels.indexOf(str[0]) !== -1) {
          return `an ${str}`;
        }
        return `a ${str}`;
      };
      return types.map(addArticle).join(" or ");
    };
    var isArrayOfNotation = (typeDefinition) => {
      return /array of /.test(typeDefinition);
    };
    var extractTypeFromArrayOfNotation = (typeDefinition) => {
      return typeDefinition.split(" of ")[1];
    };
    var isValidTypeDefinition = (typeStr) => {
      if (isArrayOfNotation(typeStr)) {
        return isValidTypeDefinition(extractTypeFromArrayOfNotation(typeStr));
      }
      return [
        "string",
        "number",
        "boolean",
        "array",
        "object",
        "buffer",
        "null",
        "undefined",
        "function"
      ].some((validType) => {
        return validType === typeStr;
      });
    };
    var detectType = (value) => {
      if (value === null) {
        return "null";
      }
      if (Array.isArray(value)) {
        return "array";
      }
      if (Buffer.isBuffer(value)) {
        return "buffer";
      }
      return typeof value;
    };
    var onlyUniqueValuesInArrayFilter = (value, index, self) => {
      return self.indexOf(value) === index;
    };
    var detectTypeDeep = (value) => {
      let type = detectType(value);
      let typesInArray;
      if (type === "array") {
        typesInArray = value.map((element) => {
          return detectType(element);
        }).filter(onlyUniqueValuesInArrayFilter);
        type += ` of ${typesInArray.join(", ")}`;
      }
      return type;
    };
    var validateArray = (argumentValue, typeToCheck) => {
      const allowedTypeInArray = extractTypeFromArrayOfNotation(typeToCheck);
      if (detectType(argumentValue) !== "array") {
        return false;
      }
      return argumentValue.every((element) => {
        return detectType(element) === allowedTypeInArray;
      });
    };
    var validateArgument = (methodName, argumentName, argumentValue, argumentMustBe) => {
      const isOneOfAllowedTypes = argumentMustBe.some((type) => {
        if (!isValidTypeDefinition(type)) {
          throw new Error(`Unknown type "${type}"`);
        }
        if (isArrayOfNotation(type)) {
          return validateArray(argumentValue, type);
        }
        return type === detectType(argumentValue);
      });
      if (!isOneOfAllowedTypes) {
        throw new Error(
          `Argument "${argumentName}" passed to ${methodName} must be ${prettyPrintTypes(
            argumentMustBe
          )}. Received ${detectTypeDeep(argumentValue)}`
        );
      }
    };
    var validateOptions = (methodName, optionsObjName, obj, allowedOptions) => {
      if (obj !== void 0) {
        validateArgument(methodName, optionsObjName, obj, ["object"]);
        Object.keys(obj).forEach((key) => {
          const argName = `${optionsObjName}.${key}`;
          if (allowedOptions[key] !== void 0) {
            validateArgument(methodName, argName, obj[key], allowedOptions[key]);
          } else {
            throw new Error(
              `Unknown argument "${argName}" passed to ${methodName}`
            );
          }
        });
      }
    };
    module2.exports = {
      argument: validateArgument,
      options: validateOptions
    };
  }
});
var require_mode = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/mode.js"(exports) {
    "use strict";
    exports.normalizeFileMode = (mode) => {
      let modeAsString;
      if (typeof mode === "number") {
        modeAsString = mode.toString(8);
      } else {
        modeAsString = mode;
      }
      return modeAsString.substring(modeAsString.length - 3);
    };
  }
});
var require_remove = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/remove.js"(exports) {
    "use strict";
    var fs3 = require_fs();
    var validate = require_validate();
    var validateInput = (methodName, path3) => {
      const methodSignature = `${methodName}([path])`;
      validate.argument(methodSignature, "path", path3, ["string", "undefined"]);
    };
    var removeSync = (path3) => {
      fs3.rmSync(path3, {
        recursive: true,
        force: true,
        maxRetries: 3
      });
    };
    var removeAsync = (path3) => {
      return fs3.rm(path3, {
        recursive: true,
        force: true,
        maxRetries: 3
      });
    };
    exports.validateInput = validateInput;
    exports.sync = removeSync;
    exports.async = removeAsync;
  }
});
var require_dir = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/dir.js"(exports) {
    "use strict";
    var pathUtil = (0, import_chunk_2ESYSVXG.__require)("path");
    var fs3 = require_fs();
    var modeUtil = require_mode();
    var validate = require_validate();
    var remove = require_remove();
    var validateInput = (methodName, path3, criteria) => {
      const methodSignature = `${methodName}(path, [criteria])`;
      validate.argument(methodSignature, "path", path3, ["string"]);
      validate.options(methodSignature, "criteria", criteria, {
        empty: ["boolean"],
        mode: ["string", "number"]
      });
    };
    var getCriteriaDefaults = (passedCriteria) => {
      const criteria = passedCriteria || {};
      if (typeof criteria.empty !== "boolean") {
        criteria.empty = false;
      }
      if (criteria.mode !== void 0) {
        criteria.mode = modeUtil.normalizeFileMode(criteria.mode);
      }
      return criteria;
    };
    var generatePathOccupiedByNotDirectoryError = (path3) => {
      return new Error(
        `Path ${path3} exists but is not a directory. Halting jetpack.dir() call for safety reasons.`
      );
    };
    var checkWhatAlreadyOccupiesPathSync = (path3) => {
      let stat2;
      try {
        stat2 = fs3.statSync(path3);
      } catch (err) {
        if (err.code !== "ENOENT") {
          throw err;
        }
      }
      if (stat2 && !stat2.isDirectory()) {
        throw generatePathOccupiedByNotDirectoryError(path3);
      }
      return stat2;
    };
    var createBrandNewDirectorySync = (path3, opts) => {
      const options = opts || {};
      try {
        fs3.mkdirSync(path3, options.mode);
      } catch (err) {
        if (err.code === "ENOENT") {
          createBrandNewDirectorySync(pathUtil.dirname(path3), options);
          fs3.mkdirSync(path3, options.mode);
        } else if (err.code === "EEXIST") {
        } else {
          throw err;
        }
      }
    };
    var checkExistingDirectoryFulfillsCriteriaSync = (path3, stat2, criteria) => {
      const checkMode = () => {
        const mode = modeUtil.normalizeFileMode(stat2.mode);
        if (criteria.mode !== void 0 && criteria.mode !== mode) {
          fs3.chmodSync(path3, criteria.mode);
        }
      };
      const checkEmptiness = () => {
        if (criteria.empty) {
          const list = fs3.readdirSync(path3);
          list.forEach((filename) => {
            remove.sync(pathUtil.resolve(path3, filename));
          });
        }
      };
      checkMode();
      checkEmptiness();
    };
    var dirSync = (path3, passedCriteria) => {
      const criteria = getCriteriaDefaults(passedCriteria);
      const stat2 = checkWhatAlreadyOccupiesPathSync(path3);
      if (stat2) {
        checkExistingDirectoryFulfillsCriteriaSync(path3, stat2, criteria);
      } else {
        createBrandNewDirectorySync(path3, criteria);
      }
    };
    var checkWhatAlreadyOccupiesPathAsync = (path3) => {
      return new Promise((resolve, reject) => {
        fs3.stat(path3).then((stat2) => {
          if (stat2.isDirectory()) {
            resolve(stat2);
          } else {
            reject(generatePathOccupiedByNotDirectoryError(path3));
          }
        }).catch((err) => {
          if (err.code === "ENOENT") {
            resolve(void 0);
          } else {
            reject(err);
          }
        });
      });
    };
    var emptyAsync = (path3) => {
      return new Promise((resolve, reject) => {
        fs3.readdir(path3).then((list) => {
          const doOne = (index) => {
            if (index === list.length) {
              resolve();
            } else {
              const subPath = pathUtil.resolve(path3, list[index]);
              remove.async(subPath).then(() => {
                doOne(index + 1);
              });
            }
          };
          doOne(0);
        }).catch(reject);
      });
    };
    var checkExistingDirectoryFulfillsCriteriaAsync = (path3, stat2, criteria) => {
      return new Promise((resolve, reject) => {
        const checkMode = () => {
          const mode = modeUtil.normalizeFileMode(stat2.mode);
          if (criteria.mode !== void 0 && criteria.mode !== mode) {
            return fs3.chmod(path3, criteria.mode);
          }
          return Promise.resolve();
        };
        const checkEmptiness = () => {
          if (criteria.empty) {
            return emptyAsync(path3);
          }
          return Promise.resolve();
        };
        checkMode().then(checkEmptiness).then(resolve, reject);
      });
    };
    var createBrandNewDirectoryAsync = (path3, opts) => {
      const options = opts || {};
      return new Promise((resolve, reject) => {
        fs3.mkdir(path3, options.mode).then(resolve).catch((err) => {
          if (err.code === "ENOENT") {
            createBrandNewDirectoryAsync(pathUtil.dirname(path3), options).then(() => {
              return fs3.mkdir(path3, options.mode);
            }).then(resolve).catch((err2) => {
              if (err2.code === "EEXIST") {
                resolve();
              } else {
                reject(err2);
              }
            });
          } else if (err.code === "EEXIST") {
            resolve();
          } else {
            reject(err);
          }
        });
      });
    };
    var dirAsync = (path3, passedCriteria) => {
      return new Promise((resolve, reject) => {
        const criteria = getCriteriaDefaults(passedCriteria);
        checkWhatAlreadyOccupiesPathAsync(path3).then((stat2) => {
          if (stat2 !== void 0) {
            return checkExistingDirectoryFulfillsCriteriaAsync(
              path3,
              stat2,
              criteria
            );
          }
          return createBrandNewDirectoryAsync(path3, criteria);
        }).then(resolve, reject);
      });
    };
    exports.validateInput = validateInput;
    exports.sync = dirSync;
    exports.createSync = createBrandNewDirectorySync;
    exports.async = dirAsync;
    exports.createAsync = createBrandNewDirectoryAsync;
  }
});
var require_write = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/write.js"(exports) {
    "use strict";
    var pathUtil = (0, import_chunk_2ESYSVXG.__require)("path");
    var fs3 = require_fs();
    var validate = require_validate();
    var dir = require_dir();
    var validateInput = (methodName, path3, data, options) => {
      const methodSignature = `${methodName}(path, data, [options])`;
      validate.argument(methodSignature, "path", path3, ["string"]);
      validate.argument(methodSignature, "data", data, [
        "string",
        "buffer",
        "object",
        "array"
      ]);
      validate.options(methodSignature, "options", options, {
        mode: ["string", "number"],
        atomic: ["boolean"],
        jsonIndent: ["number"]
      });
    };
    var newExt = ".__new__";
    var serializeToJsonMaybe = (data, jsonIndent) => {
      let indent = jsonIndent;
      if (typeof indent !== "number") {
        indent = 2;
      }
      if (typeof data === "object" && !Buffer.isBuffer(data) && data !== null) {
        return JSON.stringify(data, null, indent);
      }
      return data;
    };
    var writeFileSync = (path3, data, options) => {
      try {
        fs3.writeFileSync(path3, data, options);
      } catch (err) {
        if (err.code === "ENOENT") {
          dir.createSync(pathUtil.dirname(path3));
          fs3.writeFileSync(path3, data, options);
        } else {
          throw err;
        }
      }
    };
    var writeAtomicSync = (path3, data, options) => {
      writeFileSync(path3 + newExt, data, options);
      fs3.renameSync(path3 + newExt, path3);
    };
    var writeSync = (path3, data, options) => {
      const opts = options || {};
      const processedData = serializeToJsonMaybe(data, opts.jsonIndent);
      let writeStrategy = writeFileSync;
      if (opts.atomic) {
        writeStrategy = writeAtomicSync;
      }
      writeStrategy(path3, processedData, { mode: opts.mode });
    };
    var writeFileAsync = (path3, data, options) => {
      return new Promise((resolve, reject) => {
        fs3.writeFile(path3, data, options).then(resolve).catch((err) => {
          if (err.code === "ENOENT") {
            dir.createAsync(pathUtil.dirname(path3)).then(() => {
              return fs3.writeFile(path3, data, options);
            }).then(resolve, reject);
          } else {
            reject(err);
          }
        });
      });
    };
    var writeAtomicAsync = (path3, data, options) => {
      return new Promise((resolve, reject) => {
        writeFileAsync(path3 + newExt, data, options).then(() => {
          return fs3.rename(path3 + newExt, path3);
        }).then(resolve, reject);
      });
    };
    var writeAsync = (path3, data, options) => {
      const opts = options || {};
      const processedData = serializeToJsonMaybe(data, opts.jsonIndent);
      let writeStrategy = writeFileAsync;
      if (opts.atomic) {
        writeStrategy = writeAtomicAsync;
      }
      return writeStrategy(path3, processedData, { mode: opts.mode });
    };
    exports.validateInput = validateInput;
    exports.sync = writeSync;
    exports.async = writeAsync;
  }
});
var require_append = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/append.js"(exports) {
    "use strict";
    var fs3 = require_fs();
    var write = require_write();
    var validate = require_validate();
    var validateInput = (methodName, path3, data, options) => {
      const methodSignature = `${methodName}(path, data, [options])`;
      validate.argument(methodSignature, "path", path3, ["string"]);
      validate.argument(methodSignature, "data", data, ["string", "buffer"]);
      validate.options(methodSignature, "options", options, {
        mode: ["string", "number"]
      });
    };
    var appendSync = (path3, data, options) => {
      try {
        fs3.appendFileSync(path3, data, options);
      } catch (err) {
        if (err.code === "ENOENT") {
          write.sync(path3, data, options);
        } else {
          throw err;
        }
      }
    };
    var appendAsync = (path3, data, options) => {
      return new Promise((resolve, reject) => {
        fs3.appendFile(path3, data, options).then(resolve).catch((err) => {
          if (err.code === "ENOENT") {
            write.async(path3, data, options).then(resolve, reject);
          } else {
            reject(err);
          }
        });
      });
    };
    exports.validateInput = validateInput;
    exports.sync = appendSync;
    exports.async = appendAsync;
  }
});
var require_file = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/file.js"(exports) {
    "use strict";
    var fs3 = require_fs();
    var modeUtil = require_mode();
    var validate = require_validate();
    var write = require_write();
    var validateInput = (methodName, path3, criteria) => {
      const methodSignature = `${methodName}(path, [criteria])`;
      validate.argument(methodSignature, "path", path3, ["string"]);
      validate.options(methodSignature, "criteria", criteria, {
        content: ["string", "buffer", "object", "array"],
        jsonIndent: ["number"],
        mode: ["string", "number"]
      });
    };
    var getCriteriaDefaults = (passedCriteria) => {
      const criteria = passedCriteria || {};
      if (criteria.mode !== void 0) {
        criteria.mode = modeUtil.normalizeFileMode(criteria.mode);
      }
      return criteria;
    };
    var generatePathOccupiedByNotFileError = (path3) => {
      return new Error(
        `Path ${path3} exists but is not a file. Halting jetpack.file() call for safety reasons.`
      );
    };
    var checkWhatAlreadyOccupiesPathSync = (path3) => {
      let stat2;
      try {
        stat2 = fs3.statSync(path3);
      } catch (err) {
        if (err.code !== "ENOENT") {
          throw err;
        }
      }
      if (stat2 && !stat2.isFile()) {
        throw generatePathOccupiedByNotFileError(path3);
      }
      return stat2;
    };
    var checkExistingFileFulfillsCriteriaSync = (path3, stat2, criteria) => {
      const mode = modeUtil.normalizeFileMode(stat2.mode);
      const checkContent = () => {
        if (criteria.content !== void 0) {
          write.sync(path3, criteria.content, {
            mode,
            jsonIndent: criteria.jsonIndent
          });
          return true;
        }
        return false;
      };
      const checkMode = () => {
        if (criteria.mode !== void 0 && criteria.mode !== mode) {
          fs3.chmodSync(path3, criteria.mode);
        }
      };
      const contentReplaced = checkContent();
      if (!contentReplaced) {
        checkMode();
      }
    };
    var createBrandNewFileSync = (path3, criteria) => {
      let content = "";
      if (criteria.content !== void 0) {
        content = criteria.content;
      }
      write.sync(path3, content, {
        mode: criteria.mode,
        jsonIndent: criteria.jsonIndent
      });
    };
    var fileSync = (path3, passedCriteria) => {
      const criteria = getCriteriaDefaults(passedCriteria);
      const stat2 = checkWhatAlreadyOccupiesPathSync(path3);
      if (stat2 !== void 0) {
        checkExistingFileFulfillsCriteriaSync(path3, stat2, criteria);
      } else {
        createBrandNewFileSync(path3, criteria);
      }
    };
    var checkWhatAlreadyOccupiesPathAsync = (path3) => {
      return new Promise((resolve, reject) => {
        fs3.stat(path3).then((stat2) => {
          if (stat2.isFile()) {
            resolve(stat2);
          } else {
            reject(generatePathOccupiedByNotFileError(path3));
          }
        }).catch((err) => {
          if (err.code === "ENOENT") {
            resolve(void 0);
          } else {
            reject(err);
          }
        });
      });
    };
    var checkExistingFileFulfillsCriteriaAsync = (path3, stat2, criteria) => {
      const mode = modeUtil.normalizeFileMode(stat2.mode);
      const checkContent = () => {
        return new Promise((resolve, reject) => {
          if (criteria.content !== void 0) {
            write.async(path3, criteria.content, {
              mode,
              jsonIndent: criteria.jsonIndent
            }).then(() => {
              resolve(true);
            }).catch(reject);
          } else {
            resolve(false);
          }
        });
      };
      const checkMode = () => {
        if (criteria.mode !== void 0 && criteria.mode !== mode) {
          return fs3.chmod(path3, criteria.mode);
        }
        return void 0;
      };
      return checkContent().then((contentReplaced) => {
        if (!contentReplaced) {
          return checkMode();
        }
        return void 0;
      });
    };
    var createBrandNewFileAsync = (path3, criteria) => {
      let content = "";
      if (criteria.content !== void 0) {
        content = criteria.content;
      }
      return write.async(path3, content, {
        mode: criteria.mode,
        jsonIndent: criteria.jsonIndent
      });
    };
    var fileAsync = (path3, passedCriteria) => {
      return new Promise((resolve, reject) => {
        const criteria = getCriteriaDefaults(passedCriteria);
        checkWhatAlreadyOccupiesPathAsync(path3).then((stat2) => {
          if (stat2 !== void 0) {
            return checkExistingFileFulfillsCriteriaAsync(path3, stat2, criteria);
          }
          return createBrandNewFileAsync(path3, criteria);
        }).then(resolve, reject);
      });
    };
    exports.validateInput = validateInput;
    exports.sync = fileSync;
    exports.async = fileAsync;
  }
});
var require_inspect = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/inspect.js"(exports) {
    "use strict";
    var crypto = (0, import_chunk_2ESYSVXG.__require)("crypto");
    var pathUtil = (0, import_chunk_2ESYSVXG.__require)("path");
    var fs3 = require_fs();
    var validate = require_validate();
    var supportedChecksumAlgorithms = ["md5", "sha1", "sha256", "sha512"];
    var symlinkOptions = ["report", "follow"];
    var validateInput = (methodName, path3, options) => {
      const methodSignature = `${methodName}(path, [options])`;
      validate.argument(methodSignature, "path", path3, ["string"]);
      validate.options(methodSignature, "options", options, {
        checksum: ["string"],
        mode: ["boolean"],
        times: ["boolean"],
        absolutePath: ["boolean"],
        symlinks: ["string"]
      });
      if (options && options.checksum !== void 0 && supportedChecksumAlgorithms.indexOf(options.checksum) === -1) {
        throw new Error(
          `Argument "options.checksum" passed to ${methodSignature} must have one of values: ${supportedChecksumAlgorithms.join(
            ", "
          )}`
        );
      }
      if (options && options.symlinks !== void 0 && symlinkOptions.indexOf(options.symlinks) === -1) {
        throw new Error(
          `Argument "options.symlinks" passed to ${methodSignature} must have one of values: ${symlinkOptions.join(
            ", "
          )}`
        );
      }
    };
    var createInspectObj = (path3, options, stat2) => {
      const obj = {};
      obj.name = pathUtil.basename(path3);
      if (stat2.isFile()) {
        obj.type = "file";
        obj.size = stat2.size;
      } else if (stat2.isDirectory()) {
        obj.type = "dir";
      } else if (stat2.isSymbolicLink()) {
        obj.type = "symlink";
      } else {
        obj.type = "other";
      }
      if (options.mode) {
        obj.mode = stat2.mode;
      }
      if (options.times) {
        obj.accessTime = stat2.atime;
        obj.modifyTime = stat2.mtime;
        obj.changeTime = stat2.ctime;
        obj.birthTime = stat2.birthtime;
      }
      if (options.absolutePath) {
        obj.absolutePath = path3;
      }
      return obj;
    };
    var fileChecksum = (path3, algo) => {
      const hash = crypto.createHash(algo);
      const data = fs3.readFileSync(path3);
      hash.update(data);
      return hash.digest("hex");
    };
    var addExtraFieldsSync = (path3, inspectObj, options) => {
      if (inspectObj.type === "file" && options.checksum) {
        inspectObj[options.checksum] = fileChecksum(path3, options.checksum);
      } else if (inspectObj.type === "symlink") {
        inspectObj.pointsAt = fs3.readlinkSync(path3);
      }
    };
    var inspectSync = (path3, options) => {
      let statOperation = fs3.lstatSync;
      let stat2;
      const opts = options || {};
      if (opts.symlinks === "follow") {
        statOperation = fs3.statSync;
      }
      try {
        stat2 = statOperation(path3);
      } catch (err) {
        if (err.code === "ENOENT") {
          return void 0;
        }
        throw err;
      }
      const inspectObj = createInspectObj(path3, opts, stat2);
      addExtraFieldsSync(path3, inspectObj, opts);
      return inspectObj;
    };
    var fileChecksumAsync = (path3, algo) => {
      return new Promise((resolve, reject) => {
        const hash = crypto.createHash(algo);
        const s = fs3.createReadStream(path3);
        s.on("data", (data) => {
          hash.update(data);
        });
        s.on("end", () => {
          resolve(hash.digest("hex"));
        });
        s.on("error", reject);
      });
    };
    var addExtraFieldsAsync = (path3, inspectObj, options) => {
      if (inspectObj.type === "file" && options.checksum) {
        return fileChecksumAsync(path3, options.checksum).then((checksum) => {
          inspectObj[options.checksum] = checksum;
          return inspectObj;
        });
      } else if (inspectObj.type === "symlink") {
        return fs3.readlink(path3).then((linkPath) => {
          inspectObj.pointsAt = linkPath;
          return inspectObj;
        });
      }
      return Promise.resolve(inspectObj);
    };
    var inspectAsync = (path3, options) => {
      return new Promise((resolve, reject) => {
        let statOperation = fs3.lstat;
        const opts = options || {};
        if (opts.symlinks === "follow") {
          statOperation = fs3.stat;
        }
        statOperation(path3).then((stat2) => {
          const inspectObj = createInspectObj(path3, opts, stat2);
          addExtraFieldsAsync(path3, inspectObj, opts).then(resolve, reject);
        }).catch((err) => {
          if (err.code === "ENOENT") {
            resolve(void 0);
          } else {
            reject(err);
          }
        });
      });
    };
    exports.supportedChecksumAlgorithms = supportedChecksumAlgorithms;
    exports.symlinkOptions = symlinkOptions;
    exports.validateInput = validateInput;
    exports.sync = inspectSync;
    exports.async = inspectAsync;
  }
});
var require_list = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/list.js"(exports) {
    "use strict";
    var fs3 = require_fs();
    var validate = require_validate();
    var validateInput = (methodName, path3) => {
      const methodSignature = `${methodName}(path)`;
      validate.argument(methodSignature, "path", path3, ["string", "undefined"]);
    };
    var listSync = (path3) => {
      try {
        return fs3.readdirSync(path3);
      } catch (err) {
        if (err.code === "ENOENT") {
          return void 0;
        }
        throw err;
      }
    };
    var listAsync = (path3) => {
      return new Promise((resolve, reject) => {
        fs3.readdir(path3).then((list) => {
          resolve(list);
        }).catch((err) => {
          if (err.code === "ENOENT") {
            resolve(void 0);
          } else {
            reject(err);
          }
        });
      });
    };
    exports.validateInput = validateInput;
    exports.sync = listSync;
    exports.async = listAsync;
  }
});
var require_tree_walker = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/tree_walker.js"(exports) {
    "use strict";
    var fs3 = (0, import_chunk_2ESYSVXG.__require)("fs");
    var pathUtil = (0, import_chunk_2ESYSVXG.__require)("path");
    var inspect = require_inspect();
    var list = require_list();
    var fileType = (dirent) => {
      if (dirent.isDirectory()) {
        return "dir";
      }
      if (dirent.isFile()) {
        return "file";
      }
      if (dirent.isSymbolicLink()) {
        return "symlink";
      }
      return "other";
    };
    var initialWalkSync = (path3, options, callback) => {
      if (options.maxLevelsDeep === void 0) {
        options.maxLevelsDeep = Infinity;
      }
      const performInspectOnEachNode = options.inspectOptions !== void 0;
      if (options.symlinks) {
        if (options.inspectOptions === void 0) {
          options.inspectOptions = { symlinks: options.symlinks };
        } else {
          options.inspectOptions.symlinks = options.symlinks;
        }
      }
      const walkSync = (path4, currentLevel) => {
        fs3.readdirSync(path4, { withFileTypes: true }).forEach((direntItem) => {
          const withFileTypesNotSupported = typeof direntItem === "string";
          let fileItemPath;
          if (withFileTypesNotSupported) {
            fileItemPath = pathUtil.join(path4, direntItem);
          } else {
            fileItemPath = pathUtil.join(path4, direntItem.name);
          }
          let fileItem;
          if (performInspectOnEachNode) {
            fileItem = inspect.sync(fileItemPath, options.inspectOptions);
          } else if (withFileTypesNotSupported) {
            const inspectObject = inspect.sync(
              fileItemPath,
              options.inspectOptions
            );
            fileItem = { name: inspectObject.name, type: inspectObject.type };
          } else {
            const type = fileType(direntItem);
            if (type === "symlink" && options.symlinks === "follow") {
              const symlinkPointsTo = fs3.statSync(fileItemPath);
              fileItem = { name: direntItem.name, type: fileType(symlinkPointsTo) };
            } else {
              fileItem = { name: direntItem.name, type };
            }
          }
          if (fileItem !== void 0) {
            callback(fileItemPath, fileItem);
            if (fileItem.type === "dir" && currentLevel < options.maxLevelsDeep) {
              walkSync(fileItemPath, currentLevel + 1);
            }
          }
        });
      };
      const item = inspect.sync(path3, options.inspectOptions);
      if (item) {
        if (performInspectOnEachNode) {
          callback(path3, item);
        } else {
          callback(path3, { name: item.name, type: item.type });
        }
        if (item.type === "dir") {
          walkSync(path3, 1);
        }
      } else {
        callback(path3, void 0);
      }
    };
    var maxConcurrentOperations = 5;
    var initialWalkAsync = (path3, options, callback, doneCallback) => {
      if (options.maxLevelsDeep === void 0) {
        options.maxLevelsDeep = Infinity;
      }
      const performInspectOnEachNode = options.inspectOptions !== void 0;
      if (options.symlinks) {
        if (options.inspectOptions === void 0) {
          options.inspectOptions = { symlinks: options.symlinks };
        } else {
          options.inspectOptions.symlinks = options.symlinks;
        }
      }
      const concurrentOperationsQueue = [];
      let nowDoingConcurrentOperations = 0;
      const checkConcurrentOperations = () => {
        if (concurrentOperationsQueue.length === 0 && nowDoingConcurrentOperations === 0) {
          doneCallback();
        } else if (concurrentOperationsQueue.length > 0 && nowDoingConcurrentOperations < maxConcurrentOperations) {
          const operation = concurrentOperationsQueue.pop();
          nowDoingConcurrentOperations += 1;
          operation();
        }
      };
      const whenConcurrencySlotAvailable = (operation) => {
        concurrentOperationsQueue.push(operation);
        checkConcurrentOperations();
      };
      const concurrentOperationDone = () => {
        nowDoingConcurrentOperations -= 1;
        checkConcurrentOperations();
      };
      const walkAsync = (path4, currentLevel) => {
        const goDeeperIfDir = (fileItemPath, fileItem) => {
          if (fileItem.type === "dir" && currentLevel < options.maxLevelsDeep) {
            walkAsync(fileItemPath, currentLevel + 1);
          }
        };
        whenConcurrencySlotAvailable(() => {
          fs3.readdir(path4, { withFileTypes: true }, (err, files) => {
            if (err) {
              doneCallback(err);
            } else {
              files.forEach((direntItem) => {
                const withFileTypesNotSupported = typeof direntItem === "string";
                let fileItemPath;
                if (withFileTypesNotSupported) {
                  fileItemPath = pathUtil.join(path4, direntItem);
                } else {
                  fileItemPath = pathUtil.join(path4, direntItem.name);
                }
                if (performInspectOnEachNode || withFileTypesNotSupported) {
                  whenConcurrencySlotAvailable(() => {
                    inspect.async(fileItemPath, options.inspectOptions).then((fileItem) => {
                      if (fileItem !== void 0) {
                        if (performInspectOnEachNode) {
                          callback(fileItemPath, fileItem);
                        } else {
                          callback(fileItemPath, {
                            name: fileItem.name,
                            type: fileItem.type
                          });
                        }
                        goDeeperIfDir(fileItemPath, fileItem);
                      }
                      concurrentOperationDone();
                    }).catch((err2) => {
                      doneCallback(err2);
                    });
                  });
                } else {
                  const type = fileType(direntItem);
                  if (type === "symlink" && options.symlinks === "follow") {
                    whenConcurrencySlotAvailable(() => {
                      fs3.stat(fileItemPath, (err2, symlinkPointsTo) => {
                        if (err2) {
                          doneCallback(err2);
                        } else {
                          const fileItem = {
                            name: direntItem.name,
                            type: fileType(symlinkPointsTo)
                          };
                          callback(fileItemPath, fileItem);
                          goDeeperIfDir(fileItemPath, fileItem);
                          concurrentOperationDone();
                        }
                      });
                    });
                  } else {
                    const fileItem = { name: direntItem.name, type };
                    callback(fileItemPath, fileItem);
                    goDeeperIfDir(fileItemPath, fileItem);
                  }
                }
              });
              concurrentOperationDone();
            }
          });
        });
      };
      inspect.async(path3, options.inspectOptions).then((item) => {
        if (item) {
          if (performInspectOnEachNode) {
            callback(path3, item);
          } else {
            callback(path3, { name: item.name, type: item.type });
          }
          if (item.type === "dir") {
            walkAsync(path3, 1);
          } else {
            doneCallback();
          }
        } else {
          callback(path3, void 0);
          doneCallback();
        }
      }).catch((err) => {
        doneCallback(err);
      });
    };
    exports.sync = initialWalkSync;
    exports.async = initialWalkAsync;
  }
});
var require_path = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/minimatch@5.1.0/node_modules/minimatch/lib/path.js"(exports, module2) {
    "use strict";
    var isWindows = typeof process === "object" && process && process.platform === "win32";
    module2.exports = isWindows ? { sep: "\\" } : { sep: "/" };
  }
});
var require_balanced_match = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});
var require_brace_expansion = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js"(exports, module2) {
    "use strict";
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m) return [str];
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});
var require_minimatch = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/minimatch@5.1.0/node_modules/minimatch/minimatch.js"(exports, module2) {
    "use strict";
    var minimatch = module2.exports = (p, pattern, options = {}) => {
      assertValidPattern(pattern);
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    };
    module2.exports = minimatch;
    var path3 = require_path();
    minimatch.sep = path3.sep;
    var GLOBSTAR = Symbol("globstar **");
    minimatch.GLOBSTAR = GLOBSTAR;
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var charSet = (s) => s.split("").reduce((set, c) => {
      set[c] = true;
      return set;
    }, {});
    var reSpecials = charSet("().*{}+?[]^$\\!");
    var addPatternStartSet = charSet("[.(");
    var slashSplit = /\/+/;
    minimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);
    var ext = (a, b = {}) => {
      const t = {};
      Object.keys(a).forEach((k) => t[k] = a[k]);
      Object.keys(b).forEach((k) => t[k] = b[k]);
      return t;
    };
    minimatch.defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      const orig = minimatch;
      const m = (p, pattern, options) => orig(p, pattern, ext(def, options));
      m.Minimatch = class Minimatch extends orig.Minimatch {
        constructor(pattern, options) {
          super(pattern, ext(def, options));
        }
      };
      m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
      m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
      m.defaults = (options) => orig.defaults(ext(def, options));
      m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
      m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
      m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
      return m;
    };
    minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);
    var braceExpand = (pattern, options = {}) => {
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    };
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    var SUBPARSE = Symbol("subparse");
    minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
    minimatch.match = (list, pattern, options = {}) => {
      const mm = new Minimatch(pattern, options);
      list = list.filter((f) => mm.match(f));
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var Minimatch = class {
      constructor(pattern, options) {
        assertValidPattern(pattern);
        if (!options) options = {};
        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.make();
      }
      debug() {
      }
      make() {
        const pattern = this.pattern;
        const options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        let set = this.globSet = this.braceExpand();
        if (options.debug) this.debug = (...args) => console.error(...args);
        this.debug(this.pattern, set);
        set = this.globParts = set.map((s) => s.split(slashSplit));
        this.debug(this.pattern, set);
        set = set.map((s, si, set2) => s.map(this.parse, this));
        this.debug(this.pattern, set);
        set = set.filter((s) => s.indexOf(false) === -1);
        this.debug(this.pattern, set);
        this.set = set;
      }
      parseNegate() {
        if (this.options.nonegate) return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset) this.pattern = pattern.substr(negateOffset);
        this.negate = negate;
      }
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      matchOne(file, pattern, partial) {
        var options = this.options;
        this.debug(
          "matchOne",
          { "this": this, file, pattern }
        );
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false) return false;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl) return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit) return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      }
      braceExpand() {
        return braceExpand(this.pattern, this.options);
      }
      parse(pattern, isSub) {
        assertValidPattern(pattern);
        const options = this.options;
        if (pattern === "**") {
          if (!options.noglobstar)
            return GLOBSTAR;
          else
            pattern = "*";
        }
        if (pattern === "") return "";
        let re = "";
        let hasMagic = !!options.nocase;
        let escaping = false;
        const patternListStack = [];
        const negativeLists = [];
        let stateChar;
        let inClass = false;
        let reClassStart = -1;
        let classStart = -1;
        let cs;
        let pl;
        let sp;
        const patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const clearStateChar = () => {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            this.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        };
        for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
          this.debug("%s	%s %s %j", pattern, i, re, c);
          if (escaping) {
            if (c === "/") {
              return false;
            }
            if (reSpecials[c]) {
              re += "\\";
            }
            re += c;
            escaping = false;
            continue;
          }
          switch (c) {
            /* istanbul ignore next */
            case "/": {
              return false;
            }
            case "\\":
              clearStateChar();
              escaping = true;
              continue;
            // the various stateChar values
            // for the "extglob" stuff.
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1) c = "^";
                re += c;
                continue;
              }
              this.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options.noext) clearStateChar();
              continue;
            case "(":
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              patternListStack.push({
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              });
              re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            case ")":
              if (inClass || !patternListStack.length) {
                re += "\\)";
                continue;
              }
              clearStateChar();
              hasMagic = true;
              pl = patternListStack.pop();
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(pl);
              }
              pl.reEnd = re.length;
              continue;
            case "|":
              if (inClass || !patternListStack.length) {
                re += "\\|";
                continue;
              }
              clearStateChar();
              re += "|";
              continue;
            // these are mostly the same in regexp and glob
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                continue;
              }
              cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
              hasMagic = true;
              inClass = false;
              re += c;
              continue;
            default:
              clearStateChar();
              if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
              break;
          }
        }
        if (inClass) {
          cs = pattern.substr(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substr(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          let tail;
          tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        const addPatternStart = addPatternStartSet[re.charAt(0)];
        for (let n = negativeLists.length - 1; n > -1; n--) {
          const nl = negativeLists[n];
          const nlBefore = re.slice(0, nl.reStart);
          const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          let nlAfter = re.slice(nl.reEnd);
          const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
          const openParensBefore = nlBefore.split("(").length - 1;
          let cleanAfter = nlAfter;
          for (let i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          const dollar = nlAfter === "" && isSub !== SUBPARSE ? "$" : "";
          re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        }
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }
        if (addPatternStart) {
          re = patternStart + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }
        if (!hasMagic) {
          return globUnescape(pattern);
        }
        const flags = options.nocase ? "i" : "";
        try {
          return Object.assign(new RegExp("^" + re + "$", flags), {
            _glob: pattern,
            _src: re
          });
        } catch (er) {
          return new RegExp("$.");
        }
      }
      makeRe() {
        if (this.regexp || this.regexp === false) return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = options.nocase ? "i" : "";
        let re = set.map((pattern) => {
          pattern = pattern.map(
            (p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src
          ).reduce((set2, p) => {
            if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
              set2.push(p);
            }
            return set2;
          }, []);
          pattern.forEach((p, i) => {
            if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
              return;
            }
            if (i === 0) {
              if (pattern.length > 1) {
                pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
              } else {
                pattern[i] = twoStar;
              }
            } else if (i === pattern.length - 1) {
              pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
            } else {
              pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
              pattern[i + 1] = GLOBSTAR;
            }
          });
          return pattern.filter((p) => p !== GLOBSTAR).join("/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate) re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment) return false;
        if (this.empty) return f === "";
        if (f === "/" && partial) return true;
        const options = this.options;
        if (path3.sep !== "/") {
          f = f.split(path3.sep).join("/");
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename;
        for (let i = f.length - 1; i >= 0; i--) {
          filename = f[i];
          if (filename) break;
        }
        for (let i = 0; i < set.length; i++) {
          const pattern = set[i];
          let file = f;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate) return true;
            return !this.negate;
          }
        }
        if (options.flipNegate) return false;
        return this.negate;
      }
      static defaults(def) {
        return minimatch.defaults(def).Minimatch;
      }
    };
    minimatch.Minimatch = Minimatch;
  }
});
var require_matcher = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/matcher.js"(exports) {
    "use strict";
    var Minimatch = require_minimatch().Minimatch;
    var convertPatternToAbsolutePath = (basePath, pattern) => {
      const hasSlash = pattern.indexOf("/") !== -1;
      const isAbsolute = /^!?\//.test(pattern);
      const isNegated = /^!/.test(pattern);
      let separator;
      if (!isAbsolute && hasSlash) {
        const patternWithoutFirstCharacters = pattern.replace(/^!/, "").replace(/^\.\//, "");
        if (/\/$/.test(basePath)) {
          separator = "";
        } else {
          separator = "/";
        }
        if (isNegated) {
          return `!${basePath}${separator}${patternWithoutFirstCharacters}`;
        }
        return `${basePath}${separator}${patternWithoutFirstCharacters}`;
      }
      return pattern;
    };
    exports.create = (basePath, patterns, ignoreCase) => {
      let normalizedPatterns;
      if (typeof patterns === "string") {
        normalizedPatterns = [patterns];
      } else {
        normalizedPatterns = patterns;
      }
      const matchers = normalizedPatterns.map((pattern) => {
        return convertPatternToAbsolutePath(basePath, pattern);
      }).map((pattern) => {
        return new Minimatch(pattern, {
          matchBase: true,
          nocomment: true,
          nocase: ignoreCase || false,
          dot: true,
          windowsPathsNoEscape: true
        });
      });
      const performMatch = (absolutePath) => {
        let mode = "matching";
        let weHaveMatch = false;
        let currentMatcher;
        let i;
        for (i = 0; i < matchers.length; i += 1) {
          currentMatcher = matchers[i];
          if (currentMatcher.negate) {
            mode = "negation";
            if (i === 0) {
              weHaveMatch = true;
            }
          }
          if (mode === "negation" && weHaveMatch && !currentMatcher.match(absolutePath)) {
            return false;
          }
          if (mode === "matching" && !weHaveMatch) {
            weHaveMatch = currentMatcher.match(absolutePath);
          }
        }
        return weHaveMatch;
      };
      return performMatch;
    };
  }
});
var require_find = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/find.js"(exports) {
    "use strict";
    var pathUtil = (0, import_chunk_2ESYSVXG.__require)("path");
    var treeWalker = require_tree_walker();
    var inspect = require_inspect();
    var matcher = require_matcher();
    var validate = require_validate();
    var validateInput = (methodName, path3, options) => {
      const methodSignature = `${methodName}([path], options)`;
      validate.argument(methodSignature, "path", path3, ["string"]);
      validate.options(methodSignature, "options", options, {
        matching: ["string", "array of string"],
        filter: ["function"],
        files: ["boolean"],
        directories: ["boolean"],
        recursive: ["boolean"],
        ignoreCase: ["boolean"]
      });
    };
    var normalizeOptions = (options) => {
      const opts = options || {};
      if (opts.matching === void 0) {
        opts.matching = "*";
      }
      if (opts.files === void 0) {
        opts.files = true;
      }
      if (opts.ignoreCase === void 0) {
        opts.ignoreCase = false;
      }
      if (opts.directories === void 0) {
        opts.directories = false;
      }
      if (opts.recursive === void 0) {
        opts.recursive = true;
      }
      return opts;
    };
    var processFoundPaths = (foundPaths, cwd) => {
      return foundPaths.map((path3) => {
        return pathUtil.relative(cwd, path3);
      });
    };
    var generatePathDoesntExistError = (path3) => {
      const err = new Error(`Path you want to find stuff in doesn't exist ${path3}`);
      err.code = "ENOENT";
      return err;
    };
    var generatePathNotDirectoryError = (path3) => {
      const err = new Error(
        `Path you want to find stuff in must be a directory ${path3}`
      );
      err.code = "ENOTDIR";
      return err;
    };
    var findSync = (path3, options) => {
      const foundAbsolutePaths = [];
      const matchesAnyOfGlobs = matcher.create(
        path3,
        options.matching,
        options.ignoreCase
      );
      let maxLevelsDeep = Infinity;
      if (options.recursive === false) {
        maxLevelsDeep = 1;
      }
      treeWalker.sync(
        path3,
        {
          maxLevelsDeep,
          symlinks: "follow",
          inspectOptions: { times: true, absolutePath: true }
        },
        (itemPath, item) => {
          if (item && itemPath !== path3 && matchesAnyOfGlobs(itemPath)) {
            const weHaveMatch = item.type === "file" && options.files === true || item.type === "dir" && options.directories === true;
            if (weHaveMatch) {
              if (options.filter) {
                const passedThroughFilter = options.filter(item);
                if (passedThroughFilter) {
                  foundAbsolutePaths.push(itemPath);
                }
              } else {
                foundAbsolutePaths.push(itemPath);
              }
            }
          }
        }
      );
      foundAbsolutePaths.sort();
      return processFoundPaths(foundAbsolutePaths, options.cwd);
    };
    var findSyncInit = (path3, options) => {
      const entryPointInspect = inspect.sync(path3, { symlinks: "follow" });
      if (entryPointInspect === void 0) {
        throw generatePathDoesntExistError(path3);
      } else if (entryPointInspect.type !== "dir") {
        throw generatePathNotDirectoryError(path3);
      }
      return findSync(path3, normalizeOptions(options));
    };
    var findAsync = (path3, options) => {
      return new Promise((resolve, reject) => {
        const foundAbsolutePaths = [];
        const matchesAnyOfGlobs = matcher.create(
          path3,
          options.matching,
          options.ignoreCase
        );
        let maxLevelsDeep = Infinity;
        if (options.recursive === false) {
          maxLevelsDeep = 1;
        }
        let waitingForFiltersToFinish = 0;
        let treeWalkerDone = false;
        const maybeDone = () => {
          if (treeWalkerDone && waitingForFiltersToFinish === 0) {
            foundAbsolutePaths.sort();
            resolve(processFoundPaths(foundAbsolutePaths, options.cwd));
          }
        };
        treeWalker.async(
          path3,
          {
            maxLevelsDeep,
            symlinks: "follow",
            inspectOptions: { times: true, absolutePath: true }
          },
          (itemPath, item) => {
            if (item && itemPath !== path3 && matchesAnyOfGlobs(itemPath)) {
              const weHaveMatch = item.type === "file" && options.files === true || item.type === "dir" && options.directories === true;
              if (weHaveMatch) {
                if (options.filter) {
                  const passedThroughFilter = options.filter(item);
                  const isPromise = typeof passedThroughFilter.then === "function";
                  if (isPromise) {
                    waitingForFiltersToFinish += 1;
                    passedThroughFilter.then((passedThroughFilterResult) => {
                      if (passedThroughFilterResult) {
                        foundAbsolutePaths.push(itemPath);
                      }
                      waitingForFiltersToFinish -= 1;
                      maybeDone();
                    }).catch((err) => {
                      reject(err);
                    });
                  } else if (passedThroughFilter) {
                    foundAbsolutePaths.push(itemPath);
                  }
                } else {
                  foundAbsolutePaths.push(itemPath);
                }
              }
            }
          },
          (err) => {
            if (err) {
              reject(err);
            } else {
              treeWalkerDone = true;
              maybeDone();
            }
          }
        );
      });
    };
    var findAsyncInit = (path3, options) => {
      return inspect.async(path3, { symlinks: "follow" }).then((entryPointInspect) => {
        if (entryPointInspect === void 0) {
          throw generatePathDoesntExistError(path3);
        } else if (entryPointInspect.type !== "dir") {
          throw generatePathNotDirectoryError(path3);
        }
        return findAsync(path3, normalizeOptions(options));
      });
    };
    exports.validateInput = validateInput;
    exports.sync = findSyncInit;
    exports.async = findAsyncInit;
  }
});
var require_inspect_tree = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/inspect_tree.js"(exports) {
    "use strict";
    var crypto = (0, import_chunk_2ESYSVXG.__require)("crypto");
    var pathUtil = (0, import_chunk_2ESYSVXG.__require)("path");
    var inspect = require_inspect();
    var list = require_list();
    var validate = require_validate();
    var treeWalker = require_tree_walker();
    var validateInput = (methodName, path3, options) => {
      const methodSignature = `${methodName}(path, [options])`;
      validate.argument(methodSignature, "path", path3, ["string"]);
      validate.options(methodSignature, "options", options, {
        checksum: ["string"],
        relativePath: ["boolean"],
        times: ["boolean"],
        symlinks: ["string"]
      });
      if (options && options.checksum !== void 0 && inspect.supportedChecksumAlgorithms.indexOf(options.checksum) === -1) {
        throw new Error(
          `Argument "options.checksum" passed to ${methodSignature} must have one of values: ${inspect.supportedChecksumAlgorithms.join(
            ", "
          )}`
        );
      }
      if (options && options.symlinks !== void 0 && inspect.symlinkOptions.indexOf(options.symlinks) === -1) {
        throw new Error(
          `Argument "options.symlinks" passed to ${methodSignature} must have one of values: ${inspect.symlinkOptions.join(
            ", "
          )}`
        );
      }
    };
    var relativePathInTree = (parentInspectObj, inspectObj) => {
      if (parentInspectObj === void 0) {
        return ".";
      }
      return parentInspectObj.relativePath + "/" + inspectObj.name;
    };
    var checksumOfDir = (inspectList, algo) => {
      const hash = crypto.createHash(algo);
      inspectList.forEach((inspectObj) => {
        hash.update(inspectObj.name + inspectObj[algo]);
      });
      return hash.digest("hex");
    };
    var calculateTreeDependentProperties = (parentInspectObj, inspectObj, options) => {
      if (options.relativePath) {
        inspectObj.relativePath = relativePathInTree(parentInspectObj, inspectObj);
      }
      if (inspectObj.type === "dir") {
        inspectObj.children.forEach((childInspectObj) => {
          calculateTreeDependentProperties(inspectObj, childInspectObj, options);
        });
        inspectObj.size = 0;
        inspectObj.children.sort((a, b) => {
          if (a.type === "dir" && b.type === "file") {
            return -1;
          }
          if (a.type === "file" && b.type === "dir") {
            return 1;
          }
          return a.name.localeCompare(b.name);
        });
        inspectObj.children.forEach((child) => {
          inspectObj.size += child.size || 0;
        });
        if (options.checksum) {
          inspectObj[options.checksum] = checksumOfDir(
            inspectObj.children,
            options.checksum
          );
        }
      }
    };
    var findParentInTree = (treeNode, pathChain, item) => {
      const name = pathChain[0];
      if (pathChain.length > 1) {
        const itemInTreeForPathChain = treeNode.children.find((child) => {
          return child.name === name;
        });
        return findParentInTree(itemInTreeForPathChain, pathChain.slice(1), item);
      }
      return treeNode;
    };
    var inspectTreeSync = (path3, opts) => {
      const options = opts || {};
      let tree;
      treeWalker.sync(path3, { inspectOptions: options }, (itemPath, item) => {
        if (item) {
          if (item.type === "dir") {
            item.children = [];
          }
          const relativePath = pathUtil.relative(path3, itemPath);
          if (relativePath === "") {
            tree = item;
          } else {
            const parentItem = findParentInTree(
              tree,
              relativePath.split(pathUtil.sep),
              item
            );
            parentItem.children.push(item);
          }
        }
      });
      if (tree) {
        calculateTreeDependentProperties(void 0, tree, options);
      }
      return tree;
    };
    var inspectTreeAsync = (path3, opts) => {
      const options = opts || {};
      let tree;
      return new Promise((resolve, reject) => {
        treeWalker.async(
          path3,
          { inspectOptions: options },
          (itemPath, item) => {
            if (item) {
              if (item.type === "dir") {
                item.children = [];
              }
              const relativePath = pathUtil.relative(path3, itemPath);
              if (relativePath === "") {
                tree = item;
              } else {
                const parentItem = findParentInTree(
                  tree,
                  relativePath.split(pathUtil.sep),
                  item
                );
                parentItem.children.push(item);
              }
            }
          },
          (err) => {
            if (err) {
              reject(err);
            } else {
              if (tree) {
                calculateTreeDependentProperties(void 0, tree, options);
              }
              resolve(tree);
            }
          }
        );
      });
    };
    exports.validateInput = validateInput;
    exports.sync = inspectTreeSync;
    exports.async = inspectTreeAsync;
  }
});
var require_exists = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/exists.js"(exports) {
    "use strict";
    var fs3 = require_fs();
    var validate = require_validate();
    var validateInput = (methodName, path3) => {
      const methodSignature = `${methodName}(path)`;
      validate.argument(methodSignature, "path", path3, ["string"]);
    };
    var existsSync = (path3) => {
      try {
        const stat2 = fs3.statSync(path3);
        if (stat2.isDirectory()) {
          return "dir";
        } else if (stat2.isFile()) {
          return "file";
        }
        return "other";
      } catch (err) {
        if (err.code !== "ENOENT") {
          throw err;
        }
      }
      return false;
    };
    var existsAsync = (path3) => {
      return new Promise((resolve, reject) => {
        fs3.stat(path3).then((stat2) => {
          if (stat2.isDirectory()) {
            resolve("dir");
          } else if (stat2.isFile()) {
            resolve("file");
          } else {
            resolve("other");
          }
        }).catch((err) => {
          if (err.code === "ENOENT") {
            resolve(false);
          } else {
            reject(err);
          }
        });
      });
    };
    exports.validateInput = validateInput;
    exports.sync = existsSync;
    exports.async = existsAsync;
  }
});
var require_copy = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/copy.js"(exports) {
    "use strict";
    var pathUtil = (0, import_chunk_2ESYSVXG.__require)("path");
    var fs3 = require_fs();
    var dir = require_dir();
    var exists = require_exists();
    var inspect = require_inspect();
    var write = require_write();
    var matcher = require_matcher();
    var fileMode = require_mode();
    var treeWalker = require_tree_walker();
    var validate = require_validate();
    var validateInput = (methodName, from, to, options) => {
      const methodSignature = `${methodName}(from, to, [options])`;
      validate.argument(methodSignature, "from", from, ["string"]);
      validate.argument(methodSignature, "to", to, ["string"]);
      validate.options(methodSignature, "options", options, {
        overwrite: ["boolean", "function"],
        matching: ["string", "array of string"],
        ignoreCase: ["boolean"]
      });
    };
    var parseOptions = (options, from) => {
      const opts = options || {};
      const parsedOptions = {};
      if (opts.ignoreCase === void 0) {
        opts.ignoreCase = false;
      }
      parsedOptions.overwrite = opts.overwrite;
      if (opts.matching) {
        parsedOptions.allowedToCopy = matcher.create(
          from,
          opts.matching,
          opts.ignoreCase
        );
      } else {
        parsedOptions.allowedToCopy = () => {
          return true;
        };
      }
      return parsedOptions;
    };
    var generateNoSourceError = (path3) => {
      const err = new Error(`Path to copy doesn't exist ${path3}`);
      err.code = "ENOENT";
      return err;
    };
    var generateDestinationExistsError = (path3) => {
      const err = new Error(`Destination path already exists ${path3}`);
      err.code = "EEXIST";
      return err;
    };
    var inspectOptions = {
      mode: true,
      symlinks: "report",
      times: true,
      absolutePath: true
    };
    var shouldThrowDestinationExistsError = (context) => {
      return typeof context.opts.overwrite !== "function" && context.opts.overwrite !== true;
    };
    var checksBeforeCopyingSync = (from, to, opts) => {
      if (!exists.sync(from)) {
        throw generateNoSourceError(from);
      }
      if (exists.sync(to) && !opts.overwrite) {
        throw generateDestinationExistsError(to);
      }
    };
    var canOverwriteItSync = (context) => {
      if (typeof context.opts.overwrite === "function") {
        const destInspectData = inspect.sync(context.destPath, inspectOptions);
        return context.opts.overwrite(context.srcInspectData, destInspectData);
      }
      return context.opts.overwrite === true;
    };
    var copyFileSync = (srcPath, destPath, mode, context) => {
      const data = fs3.readFileSync(srcPath);
      try {
        fs3.writeFileSync(destPath, data, { mode, flag: "wx" });
      } catch (err) {
        if (err.code === "ENOENT") {
          write.sync(destPath, data, { mode });
        } else if (err.code === "EEXIST") {
          if (canOverwriteItSync(context)) {
            fs3.writeFileSync(destPath, data, { mode });
          } else if (shouldThrowDestinationExistsError(context)) {
            throw generateDestinationExistsError(context.destPath);
          }
        } else {
          throw err;
        }
      }
    };
    var copySymlinkSync = (from, to) => {
      const symlinkPointsAt = fs3.readlinkSync(from);
      try {
        fs3.symlinkSync(symlinkPointsAt, to);
      } catch (err) {
        if (err.code === "EEXIST") {
          fs3.unlinkSync(to);
          fs3.symlinkSync(symlinkPointsAt, to);
        } else {
          throw err;
        }
      }
    };
    var copyItemSync = (srcPath, srcInspectData, destPath, opts) => {
      const context = { srcPath, destPath, srcInspectData, opts };
      const mode = fileMode.normalizeFileMode(srcInspectData.mode);
      if (srcInspectData.type === "dir") {
        dir.createSync(destPath, { mode });
      } else if (srcInspectData.type === "file") {
        copyFileSync(srcPath, destPath, mode, context);
      } else if (srcInspectData.type === "symlink") {
        copySymlinkSync(srcPath, destPath);
      }
    };
    var copySync = (from, to, options) => {
      const opts = parseOptions(options, from);
      checksBeforeCopyingSync(from, to, opts);
      treeWalker.sync(from, { inspectOptions }, (srcPath, srcInspectData) => {
        const rel = pathUtil.relative(from, srcPath);
        const destPath = pathUtil.resolve(to, rel);
        if (opts.allowedToCopy(srcPath, destPath, srcInspectData)) {
          copyItemSync(srcPath, srcInspectData, destPath, opts);
        }
      });
    };
    var checksBeforeCopyingAsync = (from, to, opts) => {
      return exists.async(from).then((srcPathExists) => {
        if (!srcPathExists) {
          throw generateNoSourceError(from);
        } else {
          return exists.async(to);
        }
      }).then((destPathExists) => {
        if (destPathExists && !opts.overwrite) {
          throw generateDestinationExistsError(to);
        }
      });
    };
    var canOverwriteItAsync = (context) => {
      return new Promise((resolve, reject) => {
        if (typeof context.opts.overwrite === "function") {
          inspect.async(context.destPath, inspectOptions).then((destInspectData) => {
            resolve(
              context.opts.overwrite(context.srcInspectData, destInspectData)
            );
          }).catch(reject);
        } else {
          resolve(context.opts.overwrite === true);
        }
      });
    };
    var copyFileAsync = (srcPath, destPath, mode, context, runOptions) => {
      return new Promise((resolve, reject) => {
        const runOpts = runOptions || {};
        let flags = "wx";
        if (runOpts.overwrite) {
          flags = "w";
        }
        const readStream = fs3.createReadStream(srcPath);
        const writeStream = fs3.createWriteStream(destPath, { mode, flags });
        readStream.on("error", reject);
        writeStream.on("error", (err) => {
          readStream.resume();
          if (err.code === "ENOENT") {
            dir.createAsync(pathUtil.dirname(destPath)).then(() => {
              copyFileAsync(srcPath, destPath, mode, context).then(
                resolve,
                reject
              );
            }).catch(reject);
          } else if (err.code === "EEXIST") {
            canOverwriteItAsync(context).then((canOverwite) => {
              if (canOverwite) {
                copyFileAsync(srcPath, destPath, mode, context, {
                  overwrite: true
                }).then(resolve, reject);
              } else if (shouldThrowDestinationExistsError(context)) {
                reject(generateDestinationExistsError(destPath));
              } else {
                resolve();
              }
            }).catch(reject);
          } else {
            reject(err);
          }
        });
        writeStream.on("finish", resolve);
        readStream.pipe(writeStream);
      });
    };
    var copySymlinkAsync = (from, to) => {
      return fs3.readlink(from).then((symlinkPointsAt) => {
        return new Promise((resolve, reject) => {
          fs3.symlink(symlinkPointsAt, to).then(resolve).catch((err) => {
            if (err.code === "EEXIST") {
              fs3.unlink(to).then(() => {
                return fs3.symlink(symlinkPointsAt, to);
              }).then(resolve, reject);
            } else {
              reject(err);
            }
          });
        });
      });
    };
    var copyItemAsync = (srcPath, srcInspectData, destPath, opts) => {
      const context = { srcPath, destPath, srcInspectData, opts };
      const mode = fileMode.normalizeFileMode(srcInspectData.mode);
      if (srcInspectData.type === "dir") {
        return dir.createAsync(destPath, { mode });
      } else if (srcInspectData.type === "file") {
        return copyFileAsync(srcPath, destPath, mode, context);
      } else if (srcInspectData.type === "symlink") {
        return copySymlinkAsync(srcPath, destPath);
      }
      return Promise.resolve();
    };
    var copyAsync = (from, to, options) => {
      return new Promise((resolve, reject) => {
        const opts = parseOptions(options, from);
        checksBeforeCopyingAsync(from, to, opts).then(() => {
          let allFilesDelivered = false;
          let filesInProgress = 0;
          treeWalker.async(
            from,
            { inspectOptions },
            (srcPath, item) => {
              if (item) {
                const rel = pathUtil.relative(from, srcPath);
                const destPath = pathUtil.resolve(to, rel);
                if (opts.allowedToCopy(srcPath, item, destPath)) {
                  filesInProgress += 1;
                  copyItemAsync(srcPath, item, destPath, opts).then(() => {
                    filesInProgress -= 1;
                    if (allFilesDelivered && filesInProgress === 0) {
                      resolve();
                    }
                  }).catch(reject);
                }
              }
            },
            (err) => {
              if (err) {
                reject(err);
              } else {
                allFilesDelivered = true;
                if (allFilesDelivered && filesInProgress === 0) {
                  resolve();
                }
              }
            }
          );
        }).catch(reject);
      });
    };
    exports.validateInput = validateInput;
    exports.sync = copySync;
    exports.async = copyAsync;
  }
});
var require_move = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/move.js"(exports) {
    "use strict";
    var pathUtil = (0, import_chunk_2ESYSVXG.__require)("path");
    var fs3 = require_fs();
    var validate = require_validate();
    var copy = require_copy();
    var dir = require_dir();
    var exists = require_exists();
    var remove = require_remove();
    var validateInput = (methodName, from, to, options) => {
      const methodSignature = `${methodName}(from, to, [options])`;
      validate.argument(methodSignature, "from", from, ["string"]);
      validate.argument(methodSignature, "to", to, ["string"]);
      validate.options(methodSignature, "options", options, {
        overwrite: ["boolean"]
      });
    };
    var parseOptions = (options) => {
      const opts = options || {};
      return opts;
    };
    var generateDestinationExistsError = (path3) => {
      const err = new Error(`Destination path already exists ${path3}`);
      err.code = "EEXIST";
      return err;
    };
    var generateSourceDoesntExistError = (path3) => {
      const err = new Error(`Path to move doesn't exist ${path3}`);
      err.code = "ENOENT";
      return err;
    };
    var moveSync = (from, to, options) => {
      const opts = parseOptions(options);
      if (exists.sync(to) !== false && opts.overwrite !== true) {
        throw generateDestinationExistsError(to);
      }
      try {
        fs3.renameSync(from, to);
      } catch (err) {
        if (err.code === "EISDIR" || err.code === "EPERM") {
          remove.sync(to);
          fs3.renameSync(from, to);
        } else if (err.code === "EXDEV") {
          copy.sync(from, to, { overwrite: true });
          remove.sync(from);
        } else if (err.code === "ENOENT") {
          if (!exists.sync(from)) {
            throw generateSourceDoesntExistError(from);
          }
          dir.createSync(pathUtil.dirname(to));
          fs3.renameSync(from, to);
        } else {
          throw err;
        }
      }
    };
    var ensureDestinationPathExistsAsync = (to) => {
      return new Promise((resolve, reject) => {
        const destDir = pathUtil.dirname(to);
        exists.async(destDir).then((dstExists) => {
          if (!dstExists) {
            dir.createAsync(destDir).then(resolve, reject);
          } else {
            reject();
          }
        }).catch(reject);
      });
    };
    var moveAsync = (from, to, options) => {
      const opts = parseOptions(options);
      return new Promise((resolve, reject) => {
        exists.async(to).then((destinationExists) => {
          if (destinationExists !== false && opts.overwrite !== true) {
            reject(generateDestinationExistsError(to));
          } else {
            fs3.rename(from, to).then(resolve).catch((err) => {
              if (err.code === "EISDIR" || err.code === "EPERM") {
                remove.async(to).then(() => fs3.rename(from, to)).then(resolve, reject);
              } else if (err.code === "EXDEV") {
                copy.async(from, to, { overwrite: true }).then(() => remove.async(from)).then(resolve, reject);
              } else if (err.code === "ENOENT") {
                exists.async(from).then((srcExists) => {
                  if (!srcExists) {
                    reject(generateSourceDoesntExistError(from));
                  } else {
                    ensureDestinationPathExistsAsync(to).then(() => {
                      return fs3.rename(from, to);
                    }).then(resolve, reject);
                  }
                }).catch(reject);
              } else {
                reject(err);
              }
            });
          }
        });
      });
    };
    exports.validateInput = validateInput;
    exports.sync = moveSync;
    exports.async = moveAsync;
  }
});
var require_read = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/read.js"(exports) {
    "use strict";
    var fs3 = require_fs();
    var validate = require_validate();
    var supportedReturnAs = ["utf8", "buffer", "json", "jsonWithDates"];
    var validateInput = (methodName, path3, returnAs) => {
      const methodSignature = `${methodName}(path, returnAs)`;
      validate.argument(methodSignature, "path", path3, ["string"]);
      validate.argument(methodSignature, "returnAs", returnAs, [
        "string",
        "undefined"
      ]);
      if (returnAs && supportedReturnAs.indexOf(returnAs) === -1) {
        throw new Error(
          `Argument "returnAs" passed to ${methodSignature} must have one of values: ${supportedReturnAs.join(
            ", "
          )}`
        );
      }
    };
    var jsonDateParser = (key, value) => {
      const reISO = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*))(?:Z|(\+|-)([\d|:]*))?$/;
      if (typeof value === "string") {
        if (reISO.exec(value)) {
          return new Date(value);
        }
      }
      return value;
    };
    var makeNicerJsonParsingError = (path3, err) => {
      const nicerError = new Error(
        `JSON parsing failed while reading ${path3} [${err}]`
      );
      nicerError.originalError = err;
      return nicerError;
    };
    var readSync = (path3, returnAs) => {
      const retAs = returnAs || "utf8";
      let data;
      let encoding = "utf8";
      if (retAs === "buffer") {
        encoding = null;
      }
      try {
        data = fs3.readFileSync(path3, { encoding });
      } catch (err) {
        if (err.code === "ENOENT") {
          return void 0;
        }
        throw err;
      }
      try {
        if (retAs === "json") {
          data = JSON.parse(data);
        } else if (retAs === "jsonWithDates") {
          data = JSON.parse(data, jsonDateParser);
        }
      } catch (err) {
        throw makeNicerJsonParsingError(path3, err);
      }
      return data;
    };
    var readAsync = (path3, returnAs) => {
      return new Promise((resolve, reject) => {
        const retAs = returnAs || "utf8";
        let encoding = "utf8";
        if (retAs === "buffer") {
          encoding = null;
        }
        fs3.readFile(path3, { encoding }).then((data) => {
          try {
            if (retAs === "json") {
              resolve(JSON.parse(data));
            } else if (retAs === "jsonWithDates") {
              resolve(JSON.parse(data, jsonDateParser));
            } else {
              resolve(data);
            }
          } catch (err) {
            reject(makeNicerJsonParsingError(path3, err));
          }
        }).catch((err) => {
          if (err.code === "ENOENT") {
            resolve(void 0);
          } else {
            reject(err);
          }
        });
      });
    };
    exports.validateInput = validateInput;
    exports.sync = readSync;
    exports.async = readAsync;
  }
});
var require_rename = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/rename.js"(exports) {
    "use strict";
    var pathUtil = (0, import_chunk_2ESYSVXG.__require)("path");
    var move = require_move();
    var validate = require_validate();
    var validateInput = (methodName, path3, newName, options) => {
      const methodSignature = `${methodName}(path, newName, [options])`;
      validate.argument(methodSignature, "path", path3, ["string"]);
      validate.argument(methodSignature, "newName", newName, ["string"]);
      validate.options(methodSignature, "options", options, {
        overwrite: ["boolean"]
      });
      if (pathUtil.basename(newName) !== newName) {
        throw new Error(
          `Argument "newName" passed to ${methodSignature} should be a filename, not a path. Received "${newName}"`
        );
      }
    };
    var renameSync = (path3, newName, options) => {
      const newPath = pathUtil.join(pathUtil.dirname(path3), newName);
      move.sync(path3, newPath, options);
    };
    var renameAsync = (path3, newName, options) => {
      const newPath = pathUtil.join(pathUtil.dirname(path3), newName);
      return move.async(path3, newPath, options);
    };
    exports.validateInput = validateInput;
    exports.sync = renameSync;
    exports.async = renameAsync;
  }
});
var require_symlink = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/symlink.js"(exports) {
    "use strict";
    var pathUtil = (0, import_chunk_2ESYSVXG.__require)("path");
    var fs3 = require_fs();
    var validate = require_validate();
    var dir = require_dir();
    var validateInput = (methodName, symlinkValue, path3) => {
      const methodSignature = `${methodName}(symlinkValue, path)`;
      validate.argument(methodSignature, "symlinkValue", symlinkValue, ["string"]);
      validate.argument(methodSignature, "path", path3, ["string"]);
    };
    var symlinkSync = (symlinkValue, path3) => {
      try {
        fs3.symlinkSync(symlinkValue, path3);
      } catch (err) {
        if (err.code === "ENOENT") {
          dir.createSync(pathUtil.dirname(path3));
          fs3.symlinkSync(symlinkValue, path3);
        } else {
          throw err;
        }
      }
    };
    var symlinkAsync = (symlinkValue, path3) => {
      return new Promise((resolve, reject) => {
        fs3.symlink(symlinkValue, path3).then(resolve).catch((err) => {
          if (err.code === "ENOENT") {
            dir.createAsync(pathUtil.dirname(path3)).then(() => {
              return fs3.symlink(symlinkValue, path3);
            }).then(resolve, reject);
          } else {
            reject(err);
          }
        });
      });
    };
    exports.validateInput = validateInput;
    exports.sync = symlinkSync;
    exports.async = symlinkAsync;
  }
});
var require_streams = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/streams.js"(exports) {
    "use strict";
    var fs3 = (0, import_chunk_2ESYSVXG.__require)("fs");
    exports.createWriteStream = fs3.createWriteStream;
    exports.createReadStream = fs3.createReadStream;
  }
});
var require_tmp_dir = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/tmp_dir.js"(exports) {
    "use strict";
    var pathUtil = (0, import_chunk_2ESYSVXG.__require)("path");
    var os = (0, import_chunk_2ESYSVXG.__require)("os");
    var crypto = (0, import_chunk_2ESYSVXG.__require)("crypto");
    var dir = require_dir();
    var fs3 = require_fs();
    var validate = require_validate();
    var validateInput = (methodName, options) => {
      const methodSignature = `${methodName}([options])`;
      validate.options(methodSignature, "options", options, {
        prefix: ["string"],
        basePath: ["string"]
      });
    };
    var getOptionsDefaults = (passedOptions, cwdPath) => {
      passedOptions = passedOptions || {};
      const options = {};
      if (typeof passedOptions.prefix !== "string") {
        options.prefix = "";
      } else {
        options.prefix = passedOptions.prefix;
      }
      if (typeof passedOptions.basePath === "string") {
        options.basePath = pathUtil.resolve(cwdPath, passedOptions.basePath);
      } else {
        options.basePath = os.tmpdir();
      }
      return options;
    };
    var randomStringLength = 32;
    var tmpDirSync = (cwdPath, passedOptions) => {
      const options = getOptionsDefaults(passedOptions, cwdPath);
      const randomString = crypto.randomBytes(randomStringLength / 2).toString("hex");
      const dirPath = pathUtil.join(
        options.basePath,
        options.prefix + randomString
      );
      try {
        fs3.mkdirSync(dirPath);
      } catch (err) {
        if (err.code === "ENOENT") {
          dir.sync(dirPath);
        } else {
          throw err;
        }
      }
      return dirPath;
    };
    var tmpDirAsync = (cwdPath, passedOptions) => {
      return new Promise((resolve, reject) => {
        const options = getOptionsDefaults(passedOptions, cwdPath);
        crypto.randomBytes(randomStringLength / 2, (err, bytes) => {
          if (err) {
            reject(err);
          } else {
            const randomString = bytes.toString("hex");
            const dirPath = pathUtil.join(
              options.basePath,
              options.prefix + randomString
            );
            fs3.mkdir(dirPath, (err2) => {
              if (err2) {
                if (err2.code === "ENOENT") {
                  dir.async(dirPath).then(() => {
                    resolve(dirPath);
                  }, reject);
                } else {
                  reject(err2);
                }
              } else {
                resolve(dirPath);
              }
            });
          }
        });
      });
    };
    exports.validateInput = validateInput;
    exports.sync = tmpDirSync;
    exports.async = tmpDirAsync;
  }
});
var require_jetpack = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/jetpack.js"(exports, module2) {
    "use strict";
    var util = (0, import_chunk_2ESYSVXG.__require)("util");
    var pathUtil = (0, import_chunk_2ESYSVXG.__require)("path");
    var append = require_append();
    var dir = require_dir();
    var file = require_file();
    var find = require_find();
    var inspect = require_inspect();
    var inspectTree = require_inspect_tree();
    var copy = require_copy();
    var exists = require_exists();
    var list = require_list();
    var move = require_move();
    var read = require_read();
    var remove = require_remove();
    var rename = require_rename();
    var symlink = require_symlink();
    var streams = require_streams();
    var tmpDir = require_tmp_dir();
    var write = require_write();
    var jetpackContext = (cwdPath) => {
      const getCwdPath = () => {
        return cwdPath || process.cwd();
      };
      const cwd = function() {
        if (arguments.length === 0) {
          return getCwdPath();
        }
        const args = Array.prototype.slice.call(arguments);
        const pathParts = [getCwdPath()].concat(args);
        return jetpackContext(pathUtil.resolve.apply(null, pathParts));
      };
      const resolvePath = (path3) => {
        return pathUtil.resolve(getCwdPath(), path3);
      };
      const getPath = function() {
        Array.prototype.unshift.call(arguments, getCwdPath());
        return pathUtil.resolve.apply(null, arguments);
      };
      const normalizeOptions = (options) => {
        const opts = options || {};
        opts.cwd = getCwdPath();
        return opts;
      };
      const api = {
        cwd,
        path: getPath,
        append: (path3, data, options) => {
          append.validateInput("append", path3, data, options);
          append.sync(resolvePath(path3), data, options);
        },
        appendAsync: (path3, data, options) => {
          append.validateInput("appendAsync", path3, data, options);
          return append.async(resolvePath(path3), data, options);
        },
        copy: (from, to, options) => {
          copy.validateInput("copy", from, to, options);
          copy.sync(resolvePath(from), resolvePath(to), options);
        },
        copyAsync: (from, to, options) => {
          copy.validateInput("copyAsync", from, to, options);
          return copy.async(resolvePath(from), resolvePath(to), options);
        },
        createWriteStream: (path3, options) => {
          return streams.createWriteStream(resolvePath(path3), options);
        },
        createReadStream: (path3, options) => {
          return streams.createReadStream(resolvePath(path3), options);
        },
        dir: (path3, criteria) => {
          dir.validateInput("dir", path3, criteria);
          const normalizedPath = resolvePath(path3);
          dir.sync(normalizedPath, criteria);
          return cwd(normalizedPath);
        },
        dirAsync: (path3, criteria) => {
          dir.validateInput("dirAsync", path3, criteria);
          return new Promise((resolve, reject) => {
            const normalizedPath = resolvePath(path3);
            dir.async(normalizedPath, criteria).then(() => {
              resolve(cwd(normalizedPath));
            }, reject);
          });
        },
        exists: (path3) => {
          exists.validateInput("exists", path3);
          return exists.sync(resolvePath(path3));
        },
        existsAsync: (path3) => {
          exists.validateInput("existsAsync", path3);
          return exists.async(resolvePath(path3));
        },
        file: (path3, criteria) => {
          file.validateInput("file", path3, criteria);
          file.sync(resolvePath(path3), criteria);
          return api;
        },
        fileAsync: (path3, criteria) => {
          file.validateInput("fileAsync", path3, criteria);
          return new Promise((resolve, reject) => {
            file.async(resolvePath(path3), criteria).then(() => {
              resolve(api);
            }, reject);
          });
        },
        find: (startPath, options) => {
          if (typeof options === "undefined" && typeof startPath === "object") {
            options = startPath;
            startPath = ".";
          }
          find.validateInput("find", startPath, options);
          return find.sync(resolvePath(startPath), normalizeOptions(options));
        },
        findAsync: (startPath, options) => {
          if (typeof options === "undefined" && typeof startPath === "object") {
            options = startPath;
            startPath = ".";
          }
          find.validateInput("findAsync", startPath, options);
          return find.async(resolvePath(startPath), normalizeOptions(options));
        },
        inspect: (path3, fieldsToInclude) => {
          inspect.validateInput("inspect", path3, fieldsToInclude);
          return inspect.sync(resolvePath(path3), fieldsToInclude);
        },
        inspectAsync: (path3, fieldsToInclude) => {
          inspect.validateInput("inspectAsync", path3, fieldsToInclude);
          return inspect.async(resolvePath(path3), fieldsToInclude);
        },
        inspectTree: (path3, options) => {
          inspectTree.validateInput("inspectTree", path3, options);
          return inspectTree.sync(resolvePath(path3), options);
        },
        inspectTreeAsync: (path3, options) => {
          inspectTree.validateInput("inspectTreeAsync", path3, options);
          return inspectTree.async(resolvePath(path3), options);
        },
        list: (path3) => {
          list.validateInput("list", path3);
          return list.sync(resolvePath(path3 || "."));
        },
        listAsync: (path3) => {
          list.validateInput("listAsync", path3);
          return list.async(resolvePath(path3 || "."));
        },
        move: (from, to, options) => {
          move.validateInput("move", from, to, options);
          move.sync(resolvePath(from), resolvePath(to), options);
        },
        moveAsync: (from, to, options) => {
          move.validateInput("moveAsync", from, to, options);
          return move.async(resolvePath(from), resolvePath(to), options);
        },
        read: (path3, returnAs) => {
          read.validateInput("read", path3, returnAs);
          return read.sync(resolvePath(path3), returnAs);
        },
        readAsync: (path3, returnAs) => {
          read.validateInput("readAsync", path3, returnAs);
          return read.async(resolvePath(path3), returnAs);
        },
        remove: (path3) => {
          remove.validateInput("remove", path3);
          remove.sync(resolvePath(path3 || "."));
        },
        removeAsync: (path3) => {
          remove.validateInput("removeAsync", path3);
          return remove.async(resolvePath(path3 || "."));
        },
        rename: (path3, newName, options) => {
          rename.validateInput("rename", path3, newName, options);
          rename.sync(resolvePath(path3), newName, options);
        },
        renameAsync: (path3, newName, options) => {
          rename.validateInput("renameAsync", path3, newName, options);
          return rename.async(resolvePath(path3), newName, options);
        },
        symlink: (symlinkValue, path3) => {
          symlink.validateInput("symlink", symlinkValue, path3);
          symlink.sync(symlinkValue, resolvePath(path3));
        },
        symlinkAsync: (symlinkValue, path3) => {
          symlink.validateInput("symlinkAsync", symlinkValue, path3);
          return symlink.async(symlinkValue, resolvePath(path3));
        },
        tmpDir: (options) => {
          tmpDir.validateInput("tmpDir", options);
          const pathOfCreatedDirectory = tmpDir.sync(getCwdPath(), options);
          return cwd(pathOfCreatedDirectory);
        },
        tmpDirAsync: (options) => {
          tmpDir.validateInput("tmpDirAsync", options);
          return new Promise((resolve, reject) => {
            tmpDir.async(getCwdPath(), options).then((pathOfCreatedDirectory) => {
              resolve(cwd(pathOfCreatedDirectory));
            }, reject);
          });
        },
        write: (path3, data, options) => {
          write.validateInput("write", path3, data, options);
          write.sync(resolvePath(path3), data, options);
        },
        writeAsync: (path3, data, options) => {
          write.validateInput("writeAsync", path3, data, options);
          return write.async(resolvePath(path3), data, options);
        }
      };
      if (util.inspect.custom !== void 0) {
        api[util.inspect.custom] = () => {
          return `[fs-jetpack CWD: ${getCwdPath()}]`;
        };
      }
      return api;
    };
    module2.exports = jetpackContext;
  }
});
var require_main = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/main.js"(exports, module2) {
    "use strict";
    var jetpack = require_jetpack();
    module2.exports = jetpack();
  }
});
var require_universalify = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/universalify@2.0.1/node_modules/universalify/index.js"(exports) {
    "use strict";
    exports.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function") fn.apply(this, args);
        else {
          return new Promise((resolve, reject) => {
            args.push((err, res) => err != null ? reject(err) : resolve(res));
            fn.apply(this, args);
          });
        }
      }, "name", { value: fn.name });
    };
    exports.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function") return fn.apply(this, args);
        else {
          args.pop();
          fn.apply(this, args).then((r) => cb(null, r), cb);
        }
      }, "name", { value: fn.name });
    };
  }
});
var require_polyfills = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js"(exports, module2) {
    "use strict";
    var constants = (0, import_chunk_2ESYSVXG.__require)("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs3) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs3);
      }
      if (!fs3.lutimes) {
        patchLutimes(fs3);
      }
      fs3.chown = chownFix(fs3.chown);
      fs3.fchown = chownFix(fs3.fchown);
      fs3.lchown = chownFix(fs3.lchown);
      fs3.chmod = chmodFix(fs3.chmod);
      fs3.fchmod = chmodFix(fs3.fchmod);
      fs3.lchmod = chmodFix(fs3.lchmod);
      fs3.chownSync = chownFixSync(fs3.chownSync);
      fs3.fchownSync = chownFixSync(fs3.fchownSync);
      fs3.lchownSync = chownFixSync(fs3.lchownSync);
      fs3.chmodSync = chmodFixSync(fs3.chmodSync);
      fs3.fchmodSync = chmodFixSync(fs3.fchmodSync);
      fs3.lchmodSync = chmodFixSync(fs3.lchmodSync);
      fs3.stat = statFix(fs3.stat);
      fs3.fstat = statFix(fs3.fstat);
      fs3.lstat = statFix(fs3.lstat);
      fs3.statSync = statFixSync(fs3.statSync);
      fs3.fstatSync = statFixSync(fs3.fstatSync);
      fs3.lstatSync = statFixSync(fs3.lstatSync);
      if (fs3.chmod && !fs3.lchmod) {
        fs3.lchmod = function(path3, mode, cb) {
          if (cb) process.nextTick(cb);
        };
        fs3.lchmodSync = function() {
        };
      }
      if (fs3.chown && !fs3.lchown) {
        fs3.lchown = function(path3, uid, gid, cb) {
          if (cb) process.nextTick(cb);
        };
        fs3.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs3.rename = typeof fs3.rename !== "function" ? fs3.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs3.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb) cb(er);
            });
          }
          if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs3.rename);
      }
      fs3.read = typeof fs3.read !== "function" ? fs3.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs3, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs3, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs3.read);
      fs3.readSync = typeof fs3.readSync !== "function" ? fs3.readSync : /* @__PURE__ */ function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs3, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs3.readSync);
      function patchLchmod(fs4) {
        fs4.lchmod = function(path3, mode, callback) {
          fs4.open(
            path3,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback) callback(err);
                return;
              }
              fs4.fchmod(fd, mode, function(err2) {
                fs4.close(fd, function(err22) {
                  if (callback) callback(err2 || err22);
                });
              });
            }
          );
        };
        fs4.lchmodSync = function(path3, mode) {
          var fd = fs4.openSync(path3, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs4.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs4.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs4.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs4) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs4.futimes) {
          fs4.lutimes = function(path3, at, mt, cb) {
            fs4.open(path3, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb) cb(er);
                return;
              }
              fs4.futimes(fd, at, mt, function(er2) {
                fs4.close(fd, function(er22) {
                  if (cb) cb(er2 || er22);
                });
              });
            });
          };
          fs4.lutimesSync = function(path3, at, mt) {
            var fd = fs4.openSync(path3, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs4.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs4.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs4.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs4.futimes) {
          fs4.lutimes = function(_a, _b, _c, cb) {
            if (cb) process.nextTick(cb);
          };
          fs4.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig) return orig;
        return function(target, mode, cb) {
          return orig.call(fs3, target, mode, function(er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig) return orig;
        return function(target, mode) {
          try {
            return orig.call(fs3, target, mode);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig) return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs3, target, uid, gid, function(er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig) return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs3, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig) return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0) stats.uid += 4294967296;
              if (stats.gid < 0) stats.gid += 4294967296;
            }
            if (cb) cb.apply(this, arguments);
          }
          return options ? orig.call(fs3, target, options, callback) : orig.call(fs3, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig) return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs3, target, options) : orig.call(fs3, target);
          if (stats) {
            if (stats.uid < 0) stats.uid += 4294967296;
            if (stats.gid < 0) stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});
var require_legacy_streams = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js"(exports, module2) {
    "use strict";
    var Stream = (0, import_chunk_2ESYSVXG.__require)("stream").Stream;
    module2.exports = legacy;
    function legacy(fs3) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path3, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path3, options);
        Stream.call(this);
        var self = this;
        this.path = path3;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding) this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }
        fs3.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self.emit("error", err);
            self.readable = false;
            return;
          }
          self.fd = fd;
          self.emit("open", fd);
          self._read();
        });
      }
      function WriteStream(path3, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path3, options);
        Stream.call(this);
        this.path = path3;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs3.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});
var require_clone = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js"(exports, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});
var require_graceful_fs = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js"(exports, module2) {
    "use strict";
    var fs3 = (0, import_chunk_2ESYSVXG.__require)("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = (0, import_chunk_2ESYSVXG.__require)("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug3 = noop;
    if (util.debuglog)
      debug3 = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug3 = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs3[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs3, queue);
      fs3.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs3, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs3.close);
      fs3.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs3, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs3.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug3(fs3[gracefulQueue]);
          (0, import_chunk_2ESYSVXG.__require)("assert").equal(fs3[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs3[gracefulQueue]);
    }
    module2.exports = patch(clone(fs3));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs3.__patched) {
      module2.exports = patch(fs3);
      fs3.__patched = true;
    }
    function patch(fs4) {
      polyfills(fs4);
      fs4.gracefulify = patch;
      fs4.createReadStream = createReadStream;
      fs4.createWriteStream = createWriteStream;
      var fs$readFile = fs4.readFile;
      fs4.readFile = readFile2;
      function readFile2(path3, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path3, options, cb);
        function go$readFile(path4, options2, cb2, startTime) {
          return fs$readFile(path4, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path4, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs4.writeFile;
      fs4.writeFile = writeFile;
      function writeFile(path3, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path3, data, options, cb);
        function go$writeFile(path4, data2, options2, cb2, startTime) {
          return fs$writeFile(path4, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path4, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs4.appendFile;
      if (fs$appendFile)
        fs4.appendFile = appendFile;
      function appendFile(path3, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path3, data, options, cb);
        function go$appendFile(path4, data2, options2, cb2, startTime) {
          return fs$appendFile(path4, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path4, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs4.copyFile;
      if (fs$copyFile)
        fs4.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs4.readdir;
      fs4.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path3, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path4, options2, cb2, startTime) {
          return fs$readdir(path4, fs$readdirCallback(
            path4,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path4, options2, cb2, startTime) {
          return fs$readdir(path4, options2, fs$readdirCallback(
            path4,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path3, options, cb);
        function fs$readdirCallback(path4, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path4, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs4);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs4.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs4.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs4, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs4, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs4, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs4, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path3, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path3, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path3, options) {
        return new fs4.ReadStream(path3, options);
      }
      function createWriteStream(path3, options) {
        return new fs4.WriteStream(path3, options);
      }
      var fs$open = fs4.open;
      fs4.open = open;
      function open(path3, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path3, flags, mode, cb);
        function go$open(path4, flags2, mode2, cb2, startTime) {
          return fs$open(path4, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path4, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs4;
    }
    function enqueue(elem) {
      debug3("ENQUEUE", elem[0].name, elem[1]);
      fs3[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs3[gracefulQueue].length; ++i) {
        if (fs3[gracefulQueue][i].length > 2) {
          fs3[gracefulQueue][i][3] = now;
          fs3[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs3[gracefulQueue].length === 0)
        return;
      var elem = fs3[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug3("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug3("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug3("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs3[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});
var require_fs2 = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/fs/index.js"(exports) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs3 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "cp",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "glob",
      "lchmod",
      "lchown",
      "lutimes",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "statfs",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs3[key] === "function";
    });
    Object.assign(exports, fs3);
    api.forEach((method) => {
      exports[method] = u(fs3[method]);
    });
    exports.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs3.exists(filename, callback);
      }
      return new Promise((resolve) => {
        return fs3.exists(filename, resolve);
      });
    };
    exports.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs3.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve, reject) => {
        fs3.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err) return reject(err);
          resolve({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs3.write(fd, buffer, ...args);
      }
      return new Promise((resolve, reject) => {
        fs3.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err) return reject(err);
          resolve({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    exports.readv = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs3.readv(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs3.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
          if (err) return reject(err);
          resolve({ bytesRead, buffers: buffers2 });
        });
      });
    };
    exports.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs3.writev(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs3.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err) return reject(err);
          resolve({ bytesWritten, buffers: buffers2 });
        });
      });
    };
    if (typeof fs3.realpath.native === "function") {
      exports.realpath.native = u(fs3.realpath.native);
    } else {
      process.emitWarning(
        "fs.realpath.native is not a function. Is fs being monkey-patched?",
        "Warning",
        "fs-extra-WARN0003"
      );
    }
  }
});
var require_utils = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/mkdirs/utils.js"(exports, module2) {
    "use strict";
    var path3 = (0, import_chunk_2ESYSVXG.__require)("path");
    module2.exports.checkPath = function checkPath(pth) {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path3.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
  }
});
var require_make_dir = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports, module2) {
    "use strict";
    var fs3 = require_fs2();
    var { checkPath } = require_utils();
    var getMode = (options) => {
      const defaults = { mode: 511 };
      if (typeof options === "number") return options;
      return { ...defaults, ...options }.mode;
    };
    module2.exports.makeDir = async (dir, options) => {
      checkPath(dir);
      return fs3.mkdir(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
    module2.exports.makeDirSync = (dir, options) => {
      checkPath(dir);
      return fs3.mkdirSync(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
  }
});
var require_mkdirs = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/mkdirs/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir();
    var makeDir = u(_makeDir);
    module2.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});
var require_path_exists = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/path-exists/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs3 = require_fs2();
    function pathExists(path3) {
      return fs3.access(path3).then(() => true).catch(() => false);
    }
    module2.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs3.existsSync
    };
  }
});
var require_utimes = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/util/utimes.js"(exports, module2) {
    "use strict";
    var fs3 = require_fs2();
    var u = require_universalify().fromPromise;
    async function utimesMillis(path3, atime, mtime) {
      const fd = await fs3.open(path3, "r+");
      let closeErr = null;
      try {
        await fs3.futimes(fd, atime, mtime);
      } finally {
        try {
          await fs3.close(fd);
        } catch (e) {
          closeErr = e;
        }
      }
      if (closeErr) {
        throw closeErr;
      }
    }
    function utimesMillisSync(path3, atime, mtime) {
      const fd = fs3.openSync(path3, "r+");
      fs3.futimesSync(fd, atime, mtime);
      return fs3.closeSync(fd);
    }
    module2.exports = {
      utimesMillis: u(utimesMillis),
      utimesMillisSync
    };
  }
});
var require_stat = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/util/stat.js"(exports, module2) {
    "use strict";
    var fs3 = require_fs2();
    var path3 = (0, import_chunk_2ESYSVXG.__require)("path");
    var u = require_universalify().fromPromise;
    function getStats(src, dest, opts) {
      const statFunc = opts.dereference ? (file) => fs3.stat(file, { bigint: true }) : (file) => fs3.lstat(file, { bigint: true });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT") return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest, opts) {
      let destStat;
      const statFunc = opts.dereference ? (file) => fs3.statSync(file, { bigint: true }) : (file) => fs3.lstatSync(file, { bigint: true });
      const srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT") return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    async function checkPaths(src, dest, funcName, opts) {
      const { srcStat, destStat } = await getStats(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path3.basename(src);
          const destBaseName = path3.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkPathsSync(src, dest, funcName, opts) {
      const { srcStat, destStat } = getStatsSync(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path3.basename(src);
          const destBaseName = path3.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    async function checkParentPaths(src, srcStat, dest, funcName) {
      const srcParent = path3.resolve(path3.dirname(src));
      const destParent = path3.resolve(path3.dirname(dest));
      if (destParent === srcParent || destParent === path3.parse(destParent).root) return;
      let destStat;
      try {
        destStat = await fs3.stat(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT") return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPaths(src, srcStat, destParent, funcName);
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path3.resolve(path3.dirname(src));
      const destParent = path3.resolve(path3.dirname(dest));
      if (destParent === srcParent || destParent === path3.parse(destParent).root) return;
      let destStat;
      try {
        destStat = fs3.statSync(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT") return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path3.resolve(src).split(path3.sep).filter((i) => i);
      const destArr = path3.resolve(dest).split(path3.sep).filter((i) => i);
      return srcArr.every((cur, i) => destArr[i] === cur);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module2.exports = {
      // checkPaths
      checkPaths: u(checkPaths),
      checkPathsSync,
      // checkParent
      checkParentPaths: u(checkParentPaths),
      checkParentPathsSync,
      // Misc
      isSrcSubdir,
      areIdentical
    };
  }
});
var require_copy2 = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/copy/copy.js"(exports, module2) {
    "use strict";
    var fs3 = require_fs2();
    var path3 = (0, import_chunk_2ESYSVXG.__require)("path");
    var { mkdirs } = require_mkdirs();
    var { pathExists } = require_path_exists();
    var { utimesMillis } = require_utimes();
    var stat2 = require_stat();
    async function copy(src, dest, opts = {}) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0001"
        );
      }
      const { srcStat, destStat } = await stat2.checkPaths(src, dest, "copy", opts);
      await stat2.checkParentPaths(src, srcStat, dest, "copy");
      const include = await runFilter(src, dest, opts);
      if (!include) return;
      const destParent = path3.dirname(dest);
      const dirExists = await pathExists(destParent);
      if (!dirExists) {
        await mkdirs(destParent);
      }
      await getStatsAndPerformCopy(destStat, src, dest, opts);
    }
    async function runFilter(src, dest, opts) {
      if (!opts.filter) return true;
      return opts.filter(src, dest);
    }
    async function getStatsAndPerformCopy(destStat, src, dest, opts) {
      const statFn = opts.dereference ? fs3.stat : fs3.lstat;
      const srcStat = await statFn(src);
      if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);
      if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);
      if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
      if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);
      if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    async function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat) return copyFile(srcStat, src, dest, opts);
      if (opts.overwrite) {
        await fs3.unlink(dest);
        return copyFile(srcStat, src, dest, opts);
      }
      if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    async function copyFile(srcStat, src, dest, opts) {
      await fs3.copyFile(src, dest);
      if (opts.preserveTimestamps) {
        if (fileIsNotWritable(srcStat.mode)) {
          await makeFileWritable(dest, srcStat.mode);
        }
        const updatedSrcStat = await fs3.stat(src);
        await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
      }
      return fs3.chmod(dest, srcStat.mode);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return fs3.chmod(dest, srcMode | 128);
    }
    async function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat) {
        await fs3.mkdir(dest);
      }
      const promises = [];
      for await (const item of await fs3.opendir(src)) {
        const srcItem = path3.join(src, item.name);
        const destItem = path3.join(dest, item.name);
        promises.push(
          runFilter(srcItem, destItem, opts).then((include) => {
            if (include) {
              return stat2.checkPaths(srcItem, destItem, "copy", opts).then(({ destStat: destStat2 }) => {
                return getStatsAndPerformCopy(destStat2, srcItem, destItem, opts);
              });
            }
          })
        );
      }
      await Promise.all(promises);
      if (!destStat) {
        await fs3.chmod(dest, srcStat.mode);
      }
    }
    async function onLink(destStat, src, dest, opts) {
      let resolvedSrc = await fs3.readlink(src);
      if (opts.dereference) {
        resolvedSrc = path3.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs3.symlink(resolvedSrc, dest);
      }
      let resolvedDest = null;
      try {
        resolvedDest = await fs3.readlink(dest);
      } catch (e) {
        if (e.code === "EINVAL" || e.code === "UNKNOWN") return fs3.symlink(resolvedSrc, dest);
        throw e;
      }
      if (opts.dereference) {
        resolvedDest = path3.resolve(process.cwd(), resolvedDest);
      }
      if (stat2.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (stat2.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      await fs3.unlink(dest);
      return fs3.symlink(resolvedSrc, dest);
    }
    module2.exports = copy;
  }
});
var require_copy_sync = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/copy/copy-sync.js"(exports, module2) {
    "use strict";
    var fs3 = require_graceful_fs();
    var path3 = (0, import_chunk_2ESYSVXG.__require)("path");
    var mkdirsSync = require_mkdirs().mkdirsSync;
    var utimesMillisSync = require_utimes().utimesMillisSync;
    var stat2 = require_stat();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0002"
        );
      }
      const { srcStat, destStat } = stat2.checkPathsSync(src, dest, "copy", opts);
      stat2.checkParentPathsSync(src, srcStat, dest, "copy");
      if (opts.filter && !opts.filter(src, dest)) return;
      const destParent = path3.dirname(dest);
      if (!fs3.existsSync(destParent)) mkdirsSync(destParent);
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs3.statSync : fs3.lstatSync;
      const srcStat = statSync(src);
      if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
      else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);
      else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat) return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs3.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      fs3.copyFileSync(src, dest);
      if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs3.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs3.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs3.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      const dir = fs3.opendirSync(src);
      try {
        let dirent;
        while ((dirent = dir.readSync()) !== null) {
          copyDirItem(dirent.name, src, dest, opts);
        }
      } finally {
        dir.closeSync();
      }
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path3.join(src, item);
      const destItem = path3.join(dest, item);
      if (opts.filter && !opts.filter(srcItem, destItem)) return;
      const { destStat } = stat2.checkPathsSync(srcItem, destItem, "copy", opts);
      return getStats(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs3.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path3.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs3.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs3.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN") return fs3.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path3.resolve(process.cwd(), resolvedDest);
        }
        if (stat2.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (stat2.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs3.unlinkSync(dest);
      return fs3.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});
var require_copy3 = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/copy/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    module2.exports = {
      copy: u(require_copy2()),
      copySync: require_copy_sync()
    };
  }
});
var require_remove2 = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/remove/index.js"(exports, module2) {
    "use strict";
    var fs3 = require_graceful_fs();
    var u = require_universalify().fromCallback;
    function remove(path3, callback) {
      fs3.rm(path3, { recursive: true, force: true }, callback);
    }
    function removeSync(path3) {
      fs3.rmSync(path3, { recursive: true, force: true });
    }
    module2.exports = {
      remove: u(remove),
      removeSync
    };
  }
});
var require_empty = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/empty/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs3 = require_fs2();
    var path3 = (0, import_chunk_2ESYSVXG.__require)("path");
    var mkdir = require_mkdirs();
    var remove = require_remove2();
    var emptyDir = u(async function emptyDir2(dir) {
      let items;
      try {
        items = await fs3.readdir(dir);
      } catch {
        return mkdir.mkdirs(dir);
      }
      return Promise.all(items.map((item) => remove.remove(path3.join(dir, item))));
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs3.readdirSync(dir);
      } catch {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path3.join(dir, item);
        remove.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});
var require_file2 = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/file.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path3 = (0, import_chunk_2ESYSVXG.__require)("path");
    var fs3 = require_fs2();
    var mkdir = require_mkdirs();
    async function createFile(file) {
      let stats;
      try {
        stats = await fs3.stat(file);
      } catch {
      }
      if (stats && stats.isFile()) return;
      const dir = path3.dirname(file);
      let dirStats = null;
      try {
        dirStats = await fs3.stat(dir);
      } catch (err) {
        if (err.code === "ENOENT") {
          await mkdir.mkdirs(dir);
          await fs3.writeFile(file, "");
          return;
        } else {
          throw err;
        }
      }
      if (dirStats.isDirectory()) {
        await fs3.writeFile(file, "");
      } else {
        await fs3.readdir(dir);
      }
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs3.statSync(file);
      } catch {
      }
      if (stats && stats.isFile()) return;
      const dir = path3.dirname(file);
      try {
        if (!fs3.statSync(dir).isDirectory()) {
          fs3.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT") mkdir.mkdirsSync(dir);
        else throw err;
      }
      fs3.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});
var require_link = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/link.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path3 = (0, import_chunk_2ESYSVXG.__require)("path");
    var fs3 = require_fs2();
    var mkdir = require_mkdirs();
    var { pathExists } = require_path_exists();
    var { areIdentical } = require_stat();
    async function createLink(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = await fs3.lstat(dstpath);
      } catch {
      }
      let srcStat;
      try {
        srcStat = await fs3.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      if (dstStat && areIdentical(srcStat, dstStat)) return;
      const dir = path3.dirname(dstpath);
      const dirExists = await pathExists(dir);
      if (!dirExists) {
        await mkdir.mkdirs(dir);
      }
      await fs3.link(srcpath, dstpath);
    }
    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs3.lstatSync(dstpath);
      } catch {
      }
      try {
        const srcStat = fs3.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat)) return;
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path3.dirname(dstpath);
      const dirExists = fs3.existsSync(dir);
      if (dirExists) return fs3.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs3.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});
var require_symlink_paths = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports, module2) {
    "use strict";
    var path3 = (0, import_chunk_2ESYSVXG.__require)("path");
    var fs3 = require_fs2();
    var { pathExists } = require_path_exists();
    var u = require_universalify().fromPromise;
    async function symlinkPaths(srcpath, dstpath) {
      if (path3.isAbsolute(srcpath)) {
        try {
          await fs3.lstat(srcpath);
        } catch (err) {
          err.message = err.message.replace("lstat", "ensureSymlink");
          throw err;
        }
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      const dstdir = path3.dirname(dstpath);
      const relativeToDst = path3.join(dstdir, srcpath);
      const exists = await pathExists(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      }
      try {
        await fs3.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        throw err;
      }
      return {
        toCwd: srcpath,
        toDst: path3.relative(dstdir, srcpath)
      };
    }
    function symlinkPathsSync(srcpath, dstpath) {
      if (path3.isAbsolute(srcpath)) {
        const exists2 = fs3.existsSync(srcpath);
        if (!exists2) throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      const dstdir = path3.dirname(dstpath);
      const relativeToDst = path3.join(dstdir, srcpath);
      const exists = fs3.existsSync(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      }
      const srcExists = fs3.existsSync(srcpath);
      if (!srcExists) throw new Error("relative srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: path3.relative(dstdir, srcpath)
      };
    }
    module2.exports = {
      symlinkPaths: u(symlinkPaths),
      symlinkPathsSync
    };
  }
});
var require_symlink_type = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/symlink-type.js"(exports, module2) {
    "use strict";
    var fs3 = require_fs2();
    var u = require_universalify().fromPromise;
    async function symlinkType(srcpath, type) {
      if (type) return type;
      let stats;
      try {
        stats = await fs3.lstat(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    function symlinkTypeSync(srcpath, type) {
      if (type) return type;
      let stats;
      try {
        stats = fs3.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType: u(symlinkType),
      symlinkTypeSync
    };
  }
});
var require_symlink2 = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/symlink.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path3 = (0, import_chunk_2ESYSVXG.__require)("path");
    var fs3 = require_fs2();
    var { mkdirs, mkdirsSync } = require_mkdirs();
    var { symlinkPaths, symlinkPathsSync } = require_symlink_paths();
    var { symlinkType, symlinkTypeSync } = require_symlink_type();
    var { pathExists } = require_path_exists();
    var { areIdentical } = require_stat();
    async function createSymlink(srcpath, dstpath, type) {
      let stats;
      try {
        stats = await fs3.lstat(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const [srcStat, dstStat] = await Promise.all([
          fs3.stat(srcpath),
          fs3.stat(dstpath)
        ]);
        if (areIdentical(srcStat, dstStat)) return;
      }
      const relative = await symlinkPaths(srcpath, dstpath);
      srcpath = relative.toDst;
      const toType = await symlinkType(relative.toCwd, type);
      const dir = path3.dirname(dstpath);
      if (!await pathExists(dir)) {
        await mkdirs(dir);
      }
      return fs3.symlink(srcpath, dstpath, toType);
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs3.lstatSync(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const srcStat = fs3.statSync(srcpath);
        const dstStat = fs3.statSync(dstpath);
        if (areIdentical(srcStat, dstStat)) return;
      }
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path3.dirname(dstpath);
      const exists = fs3.existsSync(dir);
      if (exists) return fs3.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs3.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});
var require_ensure = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/ensure/index.js"(exports, module2) {
    "use strict";
    var { createFile, createFileSync } = require_file2();
    var { createLink, createLinkSync } = require_link();
    var { createSymlink, createSymlinkSync } = require_symlink2();
    module2.exports = {
      // file
      createFile,
      createFileSync,
      ensureFile: createFile,
      ensureFileSync: createFileSync,
      // link
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      // symlink
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync
    };
  }
});
var require_utils2 = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/utils.js"(exports, module2) {
    "use strict";
    function stringify(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
      const EOF = finalEOL ? EOL : "";
      const str = JSON.stringify(obj, replacer, spaces);
      return str.replace(/\n/g, EOL) + EOF;
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content)) content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module2.exports = { stringify, stripBom };
  }
});
var require_jsonfile = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/index.js"(exports, module2) {
    "use strict";
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_) {
      _fs = (0, import_chunk_2ESYSVXG.__require)("fs");
    }
    var universalify = require_universalify();
    var { stringify, stripBom } = require_utils2();
    async function _readFile(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs3 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = await universalify.fromCallback(fs3.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile2 = universalify.fromPromise(_readFile);
    function readFileSync(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs3 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      try {
        let content = fs3.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options = {}) {
      const fs3 = options.fs || _fs;
      const str = stringify(obj, options);
      await universalify.fromCallback(fs3.writeFile)(file, str, options);
    }
    var writeFile = universalify.fromPromise(_writeFile);
    function writeFileSync(file, obj, options = {}) {
      const fs3 = options.fs || _fs;
      const str = stringify(obj, options);
      return fs3.writeFileSync(file, str, options);
    }
    var jsonfile = {
      readFile: readFile2,
      readFileSync,
      writeFile,
      writeFileSync
    };
    module2.exports = jsonfile;
  }
});
var require_jsonfile2 = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/jsonfile.js"(exports, module2) {
    "use strict";
    var jsonFile = require_jsonfile();
    module2.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});
var require_output_file = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/output-file/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs3 = require_fs2();
    var path3 = (0, import_chunk_2ESYSVXG.__require)("path");
    var mkdir = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    async function outputFile(file, data, encoding = "utf-8") {
      const dir = path3.dirname(file);
      if (!await pathExists(dir)) {
        await mkdir.mkdirs(dir);
      }
      return fs3.writeFile(file, data, encoding);
    }
    function outputFileSync(file, ...args) {
      const dir = path3.dirname(file);
      if (!fs3.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
      }
      fs3.writeFileSync(file, ...args);
    }
    module2.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});
var require_output_json = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/output-json.js"(exports, module2) {
    "use strict";
    var { stringify } = require_utils2();
    var { outputFile } = require_output_file();
    async function outputJson(file, data, options = {}) {
      const str = stringify(data, options);
      await outputFile(file, str, options);
    }
    module2.exports = outputJson;
  }
});
var require_output_json_sync = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/output-json-sync.js"(exports, module2) {
    "use strict";
    var { stringify } = require_utils2();
    var { outputFileSync } = require_output_file();
    function outputJsonSync(file, data, options) {
      const str = stringify(data, options);
      outputFileSync(file, str, options);
    }
    module2.exports = outputJsonSync;
  }
});
var require_json = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/json/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});
var require_move2 = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/move/move.js"(exports, module2) {
    "use strict";
    var fs3 = require_fs2();
    var path3 = (0, import_chunk_2ESYSVXG.__require)("path");
    var { copy } = require_copy3();
    var { remove } = require_remove2();
    var { mkdirp } = require_mkdirs();
    var { pathExists } = require_path_exists();
    var stat2 = require_stat();
    async function move(src, dest, opts = {}) {
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = await stat2.checkPaths(src, dest, "move", opts);
      await stat2.checkParentPaths(src, srcStat, dest, "move");
      const destParent = path3.dirname(dest);
      const parsedParentPath = path3.parse(destParent);
      if (parsedParentPath.root !== destParent) {
        await mkdirp(destParent);
      }
      return doRename(src, dest, overwrite, isChangingCase);
    }
    async function doRename(src, dest, overwrite, isChangingCase) {
      if (!isChangingCase) {
        if (overwrite) {
          await remove(dest);
        } else if (await pathExists(dest)) {
          throw new Error("dest already exists.");
        }
      }
      try {
        await fs3.rename(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV") {
          throw err;
        }
        await moveAcrossDevice(src, dest, overwrite);
      }
    }
    async function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      await copy(src, dest, opts);
      return remove(src);
    }
    module2.exports = move;
  }
});
var require_move_sync = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/move/move-sync.js"(exports, module2) {
    "use strict";
    var fs3 = require_graceful_fs();
    var path3 = (0, import_chunk_2ESYSVXG.__require)("path");
    var copySync = require_copy3().copySync;
    var removeSync = require_remove2().removeSync;
    var mkdirpSync = require_mkdirs().mkdirpSync;
    var stat2 = require_stat();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = stat2.checkPathsSync(src, dest, "move", opts);
      stat2.checkParentPathsSync(src, srcStat, dest, "move");
      if (!isParentRoot(dest)) mkdirpSync(path3.dirname(dest));
      return doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      const parent = path3.dirname(dest);
      const parsedPath = path3.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase) return rename(src, dest, overwrite);
      if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
      }
      if (fs3.existsSync(dest)) throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
      try {
        fs3.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV") throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module2.exports = moveSync;
  }
});
var require_move3 = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/move/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    module2.exports = {
      move: u(require_move2()),
      moveSync: require_move_sync()
    };
  }
});
var require_lib = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-extra@11.3.0/node_modules/fs-extra/lib/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      // Export promiseified graceful-fs:
      ...require_fs2(),
      // Export extra methods:
      ...require_copy3(),
      ...require_empty(),
      ...require_ensure(),
      ...require_json(),
      ...require_mkdirs(),
      ...require_move3(),
      ...require_output_file(),
      ...require_path_exists(),
      ...require_remove2()
    };
  }
});
var require_dist = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../schema-files-loader/dist/index.js"(exports, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM22 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      CompositeFilesResolver: () => CompositeFilesResolver,
      InMemoryFilesResolver: () => InMemoryFilesResolver,
      ensureType: () => ensureType2,
      loadRelatedSchemaFiles: () => loadRelatedSchemaFiles,
      loadSchemaFiles: () => loadSchemaFiles2,
      realFsResolver: () => realFsResolver
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_node_path2 = __toESM22((0, import_chunk_2ESYSVXG.__require)("node:path"));
    var import_node_path = __toESM22((0, import_chunk_2ESYSVXG.__require)("node:path"));
    function createFileNameToKeyMapper(options) {
      if (options.caseSensitive) {
        return (fileName) => fileName;
      }
      return (fileName) => fileName.toLocaleLowerCase();
    }
    var CompositeFilesResolver = class {
      constructor(primary, secondary, options) {
        this.primary = primary;
        this.secondary = secondary;
        this._fileNameToKey = createFileNameToKeyMapper(options);
      }
      _fileNameToKey;
      async listDirContents(path3) {
        const primaryContent = await this.primary.listDirContents(path3);
        const secondaryContent = await this.secondary.listDirContents(path3);
        return uniqueWith([...primaryContent, ...secondaryContent], this._fileNameToKey);
      }
      async getEntryType(path3) {
        return await this.primary.getEntryType(path3) ?? await this.secondary.getEntryType(path3);
      }
      async getFileContents(path3) {
        return await this.primary.getFileContents(path3) ?? await this.secondary.getFileContents(path3);
      }
    };
    function uniqueWith(fileNames, toKey) {
      const map = /* @__PURE__ */ new Map();
      for (const fileName of fileNames) {
        const key = toKey(fileName);
        if (!map.has(key)) {
          map.set(key, fileName);
        }
      }
      return Array.from(map.values());
    }
    var InMemoryFilesResolver = class {
      _tree = {};
      _fileNameToKey;
      constructor(options) {
        this._fileNameToKey = createFileNameToKeyMapper(options);
      }
      addFile(absolutePath, content) {
        const dirs = absolutePath.split(/[\\/]/);
        const fileName = dirs.pop();
        if (!fileName) {
          throw new Error(`Path is empty`);
        }
        let currentDirRecord = this._tree;
        for (const dir of dirs) {
          const key = this._fileNameToKey(dir);
          let nextDirNode = currentDirRecord[key];
          if (!nextDirNode) {
            nextDirNode = {
              canonicalName: dir,
              content: {}
            };
            currentDirRecord[key] = nextDirNode;
          }
          if (typeof nextDirNode.content === "string") {
            throw new Error(`${dir} is a file`);
          }
          currentDirRecord = nextDirNode.content;
        }
        if (typeof currentDirRecord[fileName]?.content === "object") {
          throw new Error(`${absolutePath} is a directory`);
        }
        currentDirRecord[this._fileNameToKey(fileName)] = {
          canonicalName: fileName,
          content
        };
      }
      getInMemoryContent(absolutePath) {
        const keys = absolutePath.split(/[\\/]/).map((fileName) => this._fileNameToKey(fileName));
        let currentRecord = this._tree;
        for (const key of keys) {
          if (typeof currentRecord !== "object") {
            return void 0;
          }
          currentRecord = currentRecord[key]?.content;
        }
        return currentRecord;
      }
      listDirContents(filePath) {
        return Promise.resolve().then(() => {
          const dirContent = this.getInMemoryContent(filePath);
          if (typeof dirContent !== "object") {
            return [];
          }
          return Object.values(dirContent).map((node) => node.canonicalName);
        });
      }
      getEntryType(filePath) {
        return Promise.resolve().then(() => {
          const entry = this.getInMemoryContent(filePath);
          if (typeof entry === "string") {
            return { kind: "file" };
          }
          if (typeof entry === "object") {
            return { kind: "directory" };
          }
          return void 0;
        });
      }
      getFileContents(filePath) {
        return Promise.resolve().then(() => {
          const entry = this.getInMemoryContent(filePath);
          if (typeof entry === "undefined") {
            return void 0;
          }
          if (typeof entry === "object") {
            throw new Error(`${filePath} is directory`);
          }
          return entry;
        });
      }
    };
    var import_fs_extra = __toESM22(require_lib());
    var realFsResolver = {
      listDirContents(path3) {
        return import_fs_extra.default.readdir(path3);
      },
      async getEntryType(path3) {
        const stat2 = await import_fs_extra.default.lstat(path3);
        if (stat2.isFile()) {
          return { kind: "file" };
        }
        if (stat2.isDirectory()) {
          return { kind: "directory" };
        }
        if (stat2.isSymbolicLink()) {
          return { kind: "symlink", realPath: await import_fs_extra.default.realpath(path3) };
        }
        return { kind: "other" };
      },
      getFileContents(path3) {
        return import_fs_extra.default.readFile(path3, "utf8");
      }
    };
    async function loadSchemaFiles2(folderPath, filesResolver = realFsResolver) {
      const type = await filesResolver.getEntryType(folderPath);
      return processEntry(folderPath, type, filesResolver);
    }
    async function processEntry(entryPath, entryType, filesResolver) {
      if (!entryType) {
        return [];
      }
      if (entryType.kind === "symlink") {
        const realPath = entryType.realPath;
        const realType = await filesResolver.getEntryType(realPath);
        return processEntry(realPath, realType, filesResolver);
      }
      if (entryType.kind === "file") {
        if (import_node_path.default.extname(entryPath) !== ".prisma") {
          return [];
        }
        const content = await filesResolver.getFileContents(entryPath);
        if (typeof content === "undefined") {
          return [];
        }
        return [[entryPath, content]];
      }
      if (entryType.kind === "directory") {
        const dirEntries = await filesResolver.listDirContents(entryPath);
        const nested = await Promise.all(
          dirEntries.map(async (dirEntry) => {
            const fullPath = import_node_path.default.join(entryPath, dirEntry);
            const nestedEntryType = await filesResolver.getEntryType(fullPath);
            return processEntry(fullPath, nestedEntryType, filesResolver);
          })
        );
        return nested.flat();
      }
      return [];
    }
    async function loadRelatedSchemaFiles(filePath, filesResolver = realFsResolver) {
      const rootDir = await findSchemaRoot(filePath, filesResolver);
      if (!rootDir) {
        return singleFile(filePath, filesResolver);
      }
      return await loadSchemaFiles2(rootDir, filesResolver);
    }
    async function singleFile(filePath, filesResolver) {
      const contents = await filesResolver.getFileContents(filePath);
      if (contents === void 0) {
        return [];
      }
      return [[filePath, contents]];
    }
    async function findSchemaRoot(filePath, filesResolver) {
      let dir = import_node_path2.default.dirname(filePath);
      while (dir !== filePath) {
        const parentDir = import_node_path2.default.dirname(dir);
        const contents = await filesResolver.listDirContents(parentDir);
        const prismaFiles = contents.filter((file) => import_node_path2.default.extname(file) === ".prisma");
        if (prismaFiles.length === 0) {
          return dir;
        }
        dir = parentDir;
      }
      return void 0;
    }
    var import_promises = __toESM22((0, import_chunk_2ESYSVXG.__require)("node:fs/promises"));
    async function ensureType2(entryPath, expectedType) {
      try {
        const pathStat = await import_promises.default.stat(entryPath);
        if (expectedType === "file" && pathStat.isFile()) {
          return void 0;
        }
        if (expectedType === "directory" && pathStat.isDirectory()) {
          return void 0;
        }
        return { kind: "WrongType", path: entryPath, expectedTypes: [expectedType] };
      } catch (e) {
        if (e.code === "ENOENT") {
          return { kind: "NotFound", path: entryPath, expectedType };
        }
        throw e;
      }
    }
  }
});
var import_fs_jetpack = (0, import_chunk_2ESYSVXG.__toESM)(require_main());
var import_schema_files_loader = (0, import_chunk_2ESYSVXG.__toESM)(require_dist());
var readFile = (0, import_util.promisify)(import_fs.default.readFile);
var stat = (0, import_util.promisify)(import_fs.default.stat);
var debug = (0, import_debug2.Debug)("prisma:getSchema");
async function getSchemaWithPath(schemaPathFromArgs, schemaPathFromConfig, { cwd = process.cwd(), argumentName = "--schema" } = {}) {
  const result = await getSchemaWithPathInternal(schemaPathFromArgs, schemaPathFromConfig, { cwd, argumentName });
  if (result.ok) {
    return result.schema;
  }
  throw new Error(renderDefaultLookupError(result.error, cwd));
}
async function readSchemaFromSingleFile(schemaPath) {
  debug("Reading schema from single file", schemaPath);
  const typeError = await (0, import_schema_files_loader.ensureType)(schemaPath, "file");
  if (typeError) {
    return { ok: false, error: typeError };
  }
  const file = await readFile(schemaPath, { encoding: "utf-8" });
  const schemaTuple = [schemaPath, file];
  return {
    ok: true,
    schema: { schemaPath, schemaRootDir: import_path2.default.dirname(schemaPath), schemas: [schemaTuple] }
  };
}
async function readSchemaFromDirectory(schemaPath) {
  debug("Reading schema from multiple files", schemaPath);
  const typeError = await (0, import_schema_files_loader.ensureType)(schemaPath, "directory");
  if (typeError) {
    return { ok: false, error: typeError };
  }
  const files = await (0, import_schema_files_loader.loadSchemaFiles)(schemaPath);
  return { ok: true, schema: { schemaPath, schemaRootDir: schemaPath, schemas: files } };
}
async function readSchemaFromFileOrDirectory(schemaPath) {
  let stats;
  try {
    stats = await stat(schemaPath);
  } catch (e) {
    if (e.code === "ENOENT") {
      return { ok: false, error: { kind: "NotFound", path: schemaPath } };
    }
    throw e;
  }
  if (stats.isFile()) {
    return readSchemaFromSingleFile(schemaPath);
  }
  if (stats.isDirectory()) {
    return readSchemaFromDirectory(schemaPath);
  }
  return { ok: false, error: { kind: "WrongType", path: schemaPath, expectedTypes: ["file", "directory"] } };
}
async function getSchemaWithPathInternal(schemaPathFromArgs, schemaPathFromConfig, { cwd, argumentName }) {
  if (schemaPathFromArgs) {
    const absPath = import_path2.default.resolve(cwd, schemaPathFromArgs);
    const customSchemaResult = await readSchemaFromFileOrDirectory(absPath);
    if (!customSchemaResult.ok) {
      const relPath = import_path2.default.relative(cwd, absPath);
      throw new Error(
        `Could not load \`${argumentName}\` from provided path \`${relPath}\`: ${renderLookupError(
          customSchemaResult.error
        )}`
      );
    }
    return customSchemaResult;
  }
  const prismaConfigResult = await readSchemaFromPrismaConfigBasedLocation(schemaPathFromConfig);
  if (prismaConfigResult.ok) {
    return prismaConfigResult;
  }
  const pkgJsonResult = await getSchemaFromPackageJson(cwd);
  if (pkgJsonResult.ok) {
    return pkgJsonResult;
  }
  const defaultResult = await getDefaultSchema(cwd);
  if (defaultResult.ok) {
    return defaultResult;
  }
  return {
    ok: false,
    error: defaultResult.error
  };
}
function renderLookupError(error) {
  switch (error.kind) {
    case "NotFound": {
      const expected = error.expectedType ?? "file or directory";
      return `${expected} not found`;
    }
    case "WrongType":
      return `expected ${error.expectedTypes.join(" or ")}`;
  }
}
function renderDefaultLookupError(error, cwd) {
  const parts = [
    `Could not find Prisma Schema that is required for this command.`,
    `You can either provide it with ${(0, import_chunk_SKRR5WT4.green)("`--schema`")} argument,`,
    `set it in your Prisma Config file (e.g., ${(0, import_chunk_SKRR5WT4.green)("`prisma.config.ts`")}),`,
    `set it as ${(0, import_chunk_SKRR5WT4.green)("`prisma.schema`")} in your ${(0, import_chunk_SKRR5WT4.green)("package.json")},`,
    `or put it into the default location (${(0, import_chunk_SKRR5WT4.green)("`./prisma/schema.prisma`")}, or ${(0, import_chunk_SKRR5WT4.green)("`./schema.prisma`")}.`,
    "Checked following paths:\n"
  ];
  const printedPaths = /* @__PURE__ */ new Set();
  for (const failure of error.failures) {
    const filePath = failure.path;
    if (!printedPaths.has(failure.path)) {
      parts.push(`${import_path2.default.relative(cwd, filePath)}: ${renderLookupError(failure.error)}`);
      printedPaths.add(filePath);
    }
  }
  parts.push("\nSee also https://pris.ly/d/prisma-schema-location");
  return parts.join("\n");
}
async function readSchemaFromPrismaConfigBasedLocation(schemaPathFromConfig) {
  if (!schemaPathFromConfig) {
    return {
      ok: false,
      error: { kind: "PrismaConfigNotConfigured" }
    };
  }
  const schemaResult = await readSchemaFromFileOrDirectory(schemaPathFromConfig);
  if (!schemaResult.ok) {
    throw new Error(
      `Could not load schema from \`${schemaPathFromConfig}\` provided by "prisma.config.ts"\`: ${renderLookupError(
        schemaResult.error
      )}`
    );
  }
  return schemaResult;
}
async function getSchemaFromPackageJson(cwd) {
  const prismaConfig = await (0, import_config.loadConfigFromPackageJson)(cwd);
  debug("prismaConfig", prismaConfig);
  if (!prismaConfig || !prismaConfig.config?.schema) {
    return { ok: false, error: { kind: "PackageJsonNotConfigured" } };
  }
  const schemaPathFromPkgJson = prismaConfig.config.schema;
  if (typeof schemaPathFromPkgJson !== "string") {
    throw new Error(
      `Provided schema path \`${schemaPathFromPkgJson}\` from \`${import_path2.default.relative(
        cwd,
        prismaConfig.loadedFromFile
      )}\` must be of type string`
    );
  }
  const absoluteSchemaPath = import_path2.default.isAbsolute(schemaPathFromPkgJson) ? schemaPathFromPkgJson : import_path2.default.resolve(import_path2.default.dirname(prismaConfig.loadedFromFile), schemaPathFromPkgJson);
  const lookupResult = await readSchemaFromFileOrDirectory(absoluteSchemaPath);
  if (!lookupResult.ok) {
    throw new Error(
      `Could not load schema from \`${import_path2.default.relative(
        cwd,
        absoluteSchemaPath
      )}\` provided by "prisma.schema" config of \`${import_path2.default.relative(
        cwd,
        prismaConfig.loadedFromFile
      )}\`: ${renderLookupError(lookupResult.error)}`
    );
  }
  return lookupResult;
}
async function getDefaultSchema(cwd, failures = []) {
  const lookupPaths = [import_path2.default.join(cwd, "schema.prisma"), import_path2.default.join(cwd, "prisma", "schema.prisma")];
  for (const path3 of lookupPaths) {
    debug(`Checking existence of ${path3}`);
    const schema = await readSchemaFromSingleFile(path3);
    if (!schema.ok) {
      failures.push({ path: path3, error: schema.error });
      continue;
    }
    return schema;
  }
  return {
    ok: false,
    error: {
      kind: "NotFoundMultipleLocations",
      failures
    }
  };
}
var debug2 = (0, import_debug.default)("prisma:migrate:diff");
var helpOptions = (0, import_internals.format)(
  `${(0, import_chunk_SKRR5WT4.bold)("Usage")}

  ${(0, import_chunk_SKRR5WT4.dim)("$")} prisma migrate diff [options]

${(0, import_chunk_SKRR5WT4.bold)("Options")}

  -h, --help               Display this help message
  --config                 Custom path to your Prisma config file
  -o, --output             Writes to a file instead of stdout

${(0, import_chunk_SKRR5WT4.italic)("From and To inputs (1 `--from-...` and 1 `--to-...` must be provided):")}
  --from-url               A datasource URL
  --to-url

  --from-empty             Flag to assume from or to is an empty datamodel
  --to-empty

  --from-schema-datamodel  Path to a Prisma schema file, uses the ${(0, import_chunk_SKRR5WT4.italic)("datamodel")} for the diff
  --to-schema-datamodel

  --from-schema-datasource Path to a Prisma schema file, uses the ${(0, import_chunk_SKRR5WT4.italic)("datasource url")} for the diff
  --to-schema-datasource

  --from-migrations        Path to the Prisma Migrate migrations directory
  --to-migrations

  --from-local-d1          Automatically locate the local Cloudflare D1 database
  --to-local-d1

${(0, import_chunk_SKRR5WT4.italic)("Shadow database (only required if using --from-migrations or --to-migrations):")}
  --shadow-database-url    URL for the shadow database

${(0, import_chunk_SKRR5WT4.bold)("Flags")}

  --script                 Render a SQL script to stdout instead of the default human readable summary (not supported on MongoDB)
  --exit-code              Change the exit code behavior to signal if the diff is empty or not (Empty: 0, Error: 1, Not empty: 2). Default behavior is Success: 0, Error: 1.`
);
var MigrateDiff = class _MigrateDiff {
  static new() {
    return new _MigrateDiff();
  }
  static help = (0, import_internals.format)(`
${process.platform === "win32" ? "" : "\u{1F50D} "}Compares the database schema from two arbitrary sources, and outputs the differences either as a human-readable summary (by default) or an executable script.

${(0, import_chunk_SKRR5WT4.green)(`prisma migrate diff`)} is a read-only command that does not write to your datasource(s).
${(0, import_chunk_SKRR5WT4.green)(`prisma db execute`)} can be used to execute its ${(0, import_chunk_SKRR5WT4.green)(`--script`)} output.

The command takes a source ${(0, import_chunk_SKRR5WT4.green)(`--from-...`)} and a destination ${(0, import_chunk_SKRR5WT4.green)(`--to-...`)}.
The source and destination must use the same provider,
e.g. a diff using 2 different providers like PostgreSQL and SQLite is not supported.

It compares the source with the destination to generate a diff. 
The diff can be interpreted as generating a migration that brings the source schema (from) to the shape of the destination schema (to).
The default output is a human readable diff, it can be rendered as SQL using \`--script\` on SQL databases.

See the documentation for more information ${(0, import_internals.link)("https://pris.ly/d/migrate-diff")}

${helpOptions}
${(0, import_chunk_SKRR5WT4.bold)("Examples")}
 
  From database to database as summary
    e.g. compare two live databases
  ${(0, import_chunk_SKRR5WT4.dim)("$")} prisma migrate diff \\
    --from-url "$DATABASE_URL" \\
    --to-url "postgresql://login:password@localhost:5432/db2"
  
  From a live database to a Prisma datamodel
    e.g. roll forward after a migration failed in the middle
  ${(0, import_chunk_SKRR5WT4.dim)("$")} prisma migrate diff \\
    --shadow-database-url "$SHADOW_DB" \\
    --from-url "$PROD_DB" \\
    --to-schema-datamodel=next_datamodel.prisma \\
    --script
  
  From a live database to a datamodel 
    e.g. roll backward after a migration failed in the middle
  ${(0, import_chunk_SKRR5WT4.dim)("$")} prisma migrate diff \\
    --shadow-database-url "$SHADOW_DB" \\
    --from-url "$PROD_DB" \\
    --to-schema-datamodel=previous_datamodel.prisma \\
    --script

  From a local D1 database to a datamodel
  ${(0, import_chunk_SKRR5WT4.dim)("$")} prisma migrate diff \\
    --from-local-d1 \\
    --to-schema-datamodel=./prisma/schema.prisma \\
    --script

  From a Prisma datamodel to a local D1 database
  ${(0, import_chunk_SKRR5WT4.dim)("$")} prisma migrate diff \\
    --from-schema-datamodel=./prisma/schema.prisma \\
    --to-local-d1 \\
    --script
  
  From a Prisma Migrate \`migrations\` directory to another database
    e.g. generate a migration for a hotfix already applied on production
  ${(0, import_chunk_SKRR5WT4.dim)("$")} prisma migrate diff \\
    --shadow-database-url "$SHADOW_DB" \\
    --from-migrations ./migrations \\
    --to-url "$PROD_DB" \\
    --script

  Execute the --script output with \`prisma db execute\` using bash pipe \`|\`
  ${(0, import_chunk_SKRR5WT4.dim)("$")} prisma migrate diff \\
    --from-[...] \\
    --to-[...] \\
    --script | prisma db execute --stdin --url="$DATABASE_URL"

  Detect if both sources are in sync, it will exit with exit code 2 if changes are detected
  ${(0, import_chunk_SKRR5WT4.dim)("$")} prisma migrate diff \\
    --exit-code \\
    --from-[...] \\
    --to-[...]
`);
  async parse(argv, config) {
    const args = (0, import_internals.arg)(
      argv,
      {
        "--help": Boolean,
        "-h": "--help",
        "--output": String,
        "-o": "--output",
        // From
        "--from-empty": Boolean,
        "--from-schema-datasource": String,
        "--from-schema-datamodel": String,
        "--from-url": String,
        "--from-migrations": String,
        "--from-local-d1": Boolean,
        // To
        "--to-empty": Boolean,
        "--to-schema-datasource": String,
        "--to-schema-datamodel": String,
        "--to-url": String,
        "--to-migrations": String,
        "--to-local-d1": Boolean,
        // Others
        "--shadow-database-url": String,
        "--script": Boolean,
        "--exit-code": Boolean,
        "--telemetry-information": String,
        "--config": String
      },
      false
    );
    if ((0, import_internals.isError)(args)) {
      return this.help(args.message);
    }
    const cmd = "migrate diff";
    (0, import_internals.checkUnsupportedDataProxy)({
      cmd,
      urls: [args["--to-url"], args["--from-url"], args["--shadow-database-url"]]
    });
    (0, import_internals.checkUnsupportedSchemaEngineWasm)({
      cmd,
      config,
      args,
      flags: [
        "--from-url",
        "--to-url",
        "--from-schema-datasource",
        "--to-schema-datasource",
        "--shadow-database-url",
        "--to-local-d1",
        "--from-local-d1"
      ]
    });
    if (args["--help"]) {
      return this.help();
    }
    const numberOfFromParameterProvided = Number(Boolean(args["--from-empty"])) + Number(Boolean(args["--from-schema-datasource"])) + Number(Boolean(args["--from-schema-datamodel"])) + Number(Boolean(args["--from-url"])) + Number(Boolean(args["--from-migrations"])) + Number(Boolean(args["--from-local-d1"]));
    const numberOfToParameterProvided = Number(Boolean(args["--to-empty"])) + Number(Boolean(args["--to-schema-datasource"])) + Number(Boolean(args["--to-schema-datamodel"])) + Number(Boolean(args["--to-url"])) + Number(Boolean(args["--to-migrations"])) + Number(Boolean(args["--to-local-d1"]));
    if (numberOfFromParameterProvided !== 1 || numberOfToParameterProvided !== 1) {
      const errorMessages = [];
      if (numberOfFromParameterProvided !== 1) {
        errorMessages.push(`${numberOfFromParameterProvided} \`--from-...\` parameter(s) provided. 1 must be provided.`);
      }
      if (numberOfToParameterProvided !== 1) {
        errorMessages.push(`${numberOfToParameterProvided} \`--to-...\` parameter(s) provided. 1 must be provided.`);
      }
      return this.help(`${errorMessages.join("\n")}`);
    }
    if (args["--shadow-database-url"] && (args["--from-local-d1"] || args["--to-local-d1"])) {
      return this.help(
        `The flag \`--shadow-database-url\` is not compatible with \`--from-local-d1\` or \`--to-local-d1\`.`
      );
    }
    let from;
    if (args["--from-empty"]) {
      from = {
        tag: "empty"
      };
    } else if (args["--from-schema-datasource"]) {
      await (0, import_internals.loadEnvFile)({ schemaPath: args["--from-schema-datasource"], printMessage: false, config });
      const schemaContext = await (0, import_internals.loadSchemaContext)({
        schemaPathFromArg: args["--from-schema-datasource"],
        schemaPathArgumentName: "--from-schema-datasource",
        printLoadMessage: false
      });
      (0, import_internals.checkUnsupportedDataProxy)({ cmd: "migrate diff", schemaContext });
      from = {
        tag: "schemaDatasource",
        ...(0, import_internals.toSchemasWithConfigDir)(schemaContext)
      };
    } else if (args["--from-schema-datamodel"]) {
      const schema = await getSchemaWithPath(import_path.default.resolve(args["--from-schema-datamodel"]), config.schema, {
        argumentName: "--from-schema-datamodel"
      });
      from = {
        tag: "schemaDatamodel",
        ...(0, import_internals.toSchemasContainer)(schema.schemas)
      };
    } else if (args["--from-url"]) {
      from = {
        tag: "url",
        url: args["--from-url"]
      };
    } else if (args["--from-migrations"]) {
      from = {
        tag: "migrations",
        ...await (0, import_chunk_GGA2F64G.listMigrations)(args["--from-migrations"], config.migrations?.initShadowDb ?? "")
      };
    } else if (args["--from-local-d1"]) {
      const d1Database = await (0, import_internals.locateLocalCloudflareD1)({ arg: "--from-local-d1" });
      from = {
        tag: "url",
        url: `file:${d1Database}`
      };
    }
    let to;
    if (args["--to-empty"]) {
      to = {
        tag: "empty"
      };
    } else if (args["--to-schema-datasource"]) {
      await (0, import_internals.loadEnvFile)({ schemaPath: args["--to-schema-datasource"], printMessage: false, config });
      const schemaContext = await (0, import_internals.loadSchemaContext)({
        schemaPathFromArg: args["--to-schema-datasource"],
        schemaPathArgumentName: "--to-schema-datasource",
        printLoadMessage: false
      });
      (0, import_internals.checkUnsupportedDataProxy)({ cmd: "migrate diff", schemaContext });
      to = {
        tag: "schemaDatasource",
        ...(0, import_internals.toSchemasWithConfigDir)(schemaContext)
      };
    } else if (args["--to-schema-datamodel"]) {
      const schema = await getSchemaWithPath(import_path.default.resolve(args["--to-schema-datamodel"]), config.schema, {
        argumentName: "--to-schema-datamodel"
      });
      to = {
        tag: "schemaDatamodel",
        ...(0, import_internals.toSchemasContainer)(schema.schemas)
      };
    } else if (args["--to-url"]) {
      to = {
        tag: "url",
        url: args["--to-url"]
      };
    } else if (args["--to-migrations"]) {
      to = {
        tag: "migrations",
        ...await (0, import_chunk_GGA2F64G.listMigrations)(args["--to-migrations"], config.migrations?.initShadowDb ?? "")
      };
    } else if (args["--to-local-d1"]) {
      const d1Database = await (0, import_internals.locateLocalCloudflareD1)({ arg: "--to-local-d1" });
      to = {
        tag: "url",
        url: `file:${d1Database}`
      };
    }
    const adapter = await config.adapter?.();
    const schemaFilter = {
      externalTables: config.tables?.external ?? [],
      externalEnums: config.enums?.external ?? []
    };
    const migrate = await import_chunk_F3JIZWIS.Migrate.setup({ adapter, schemaFilter });
    const captureStdout = new import_chunk_VAJ4VX67.CaptureStdout();
    const outputPath = args["--output"];
    const isOutputDefined = Boolean(outputPath);
    if (isOutputDefined) {
      captureStdout.startCapture();
    }
    let result;
    try {
      result = await migrate.engine.migrateDiff({
        from,
        to,
        script: args["--script"] || false,
        // default is false
        shadowDatabaseUrl: args["--shadow-database-url"] ?? null,
        exitCode: args["--exit-code"] ?? null,
        filters: {
          externalTables: config.tables?.external ?? [],
          externalEnums: config.enums?.external ?? []
        }
      });
    } finally {
      await migrate.stop();
    }
    if (isOutputDefined) {
      captureStdout.stopCapture();
      const diffOutput = captureStdout.getCapturedText();
      captureStdout.clearCaptureText();
      await import_fs_jetpack.default.writeAsync(outputPath, diffOutput.join("\n"));
    }
    debug2({ migrateDiffOutput: result });
    if (args["--exit-code"] && result.exitCode) {
      process.exit(result.exitCode);
    }
    return ``;
  }
  help(error) {
    if (error) {
      throw new import_internals.HelpError(`
${error}

${helpOptions}`);
    }
    return _MigrateDiff.help;
  }
};
